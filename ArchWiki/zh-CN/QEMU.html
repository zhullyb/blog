<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>QEMU (简体中文) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-QEMU_简体中文 rootpage-QEMU_简体中文 skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">QEMU (简体中文)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>相关文章</p>
<ul>
<li><a href="../zh-CN/Category:Hypervisors.html" title="Category:Hypervisors (简体中文)">Category:Hypervisors (简体中文)</a></li>
<li><a href="../zh-CN/Libvirt.html" title="Libvirt (简体中文)">Libvirt (简体中文)</a></li>
<li><a href="../en/QEMU/Guest_graphics_acceleration.html" title="QEMU/Guest graphics acceleration">QEMU/Guest graphics acceleration</a></li>
<li><a href="../zh-CN/PCI_passthrough_via_OVMF.html" title="PCI passthrough via OVMF (简体中文)">PCI passthrough via OVMF (简体中文)</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>翻译状态：</strong>本文是 <a href="../en/QEMU.html" title="QEMU">QEMU</a> 的<a href="../zh-CN/ArchWiki:Translation_Team.html" title="ArchWiki:Translation Team (简体中文)">翻译</a>。上次翻译日期：2021-1-14。如果英文版本有所<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=QEMU&amp;diff=0&amp;oldid=648898">更改</a>，则您可以帮助同步翻译。</div>
<p>来自 <a rel="nofollow" class="external text" href="http://wiki.qemu.org/Main_Page">QEMU 关于页面</a>：“Qemu”是一个广泛使用的开源计算机模拟器和虚拟机。"
</p>
<p>当作为模拟器时，可以在一种架构（如x86 PC）下运行另一种架构（如ARM）下的操作系统和程序。通过使用动态转换，它可以获得非常好的性能。
</p>
<p>作为虚拟机时，QEMU可以使用其他虚拟机管理程序（如 <a href="../zh-CN/Xen.html" title="Xen (简体中文)">Xen</a> 或 <a href="../zh-CN/KVM.html" title="KVM (简体中文)">KVM</a>）来使用CPU扩展（<a href="https://en.wikipedia.org/wiki/Hardware-assisted_virtualization" class="extiw" title="wikipedia:Hardware-assisted virtualization">HVM</a>）进行虚拟化，通过在主机CPU上直接执行客户机代码来获得接近于宿主机的性能。 
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#%E5%AE%89%E8%A3%85"><span class="tocnumber">1</span> <span class="toctext">安装</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#QEMU_%E5%8F%98%E7%A7%8D"><span class="tocnumber">1.1</span> <span class="toctext">QEMU 变种</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Arch_Linux%E4%B8%AD%E7%9B%B8%E5%85%B3%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="tocnumber">1.2</span> <span class="toctext">Arch Linux中相关安装包的详细信息</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#QEMU_%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%89%8D%E7%AB%AF"><span class="tocnumber">2</span> <span class="toctext">QEMU 的图形前端</span></a></li>
<li class="toclevel-1 tocsection-5">
<a href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F"><span class="tocnumber">3</span> <span class="toctext">创建新虚拟系统</span></a>
<ul>
<li class="toclevel-2 tocsection-6">
<a href="#%E5%88%9B%E5%BB%BA%E7%A1%AC%E7%9B%98%E9%95%9C%E5%83%8F"><span class="tocnumber">3.1</span> <span class="toctext">创建硬盘镜像</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#%E4%B8%8A%E5%B1%82%E5%AD%98%E5%82%A8%E9%95%9C%E5%83%8F"><span class="tocnumber">3.1.1</span> <span class="toctext">上层存储镜像</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#%E8%B0%83%E6%95%B4%E9%95%9C%E5%83%8F%E5%A4%A7%E5%B0%8F"><span class="tocnumber">3.1.2</span> <span class="toctext">调整镜像大小</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#%E5%87%86%E5%A4%87%E5%AE%89%E8%A3%85%E4%BB%8B%E8%B4%A8"><span class="tocnumber">3.2</span> <span class="toctext">准备安装介质</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="tocnumber">3.3</span> <span class="toctext">安装操作系统</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11">
<a href="#%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="tocnumber">4</span> <span class="toctext">运行虚拟化的系统</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#%E5%90%AF%E7%94%A8_KVM"><span class="tocnumber">4.1</span> <span class="toctext">启用 KVM</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#%E5%90%AF%E7%94%A8_IOMMU_(Intel_VT-d/AMD-Vi)_%E7%9A%84%E6%94%AF%E6%8C%81"><span class="tocnumber">4.2</span> <span class="toctext">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14">
<a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="tocnumber">5</span> <span class="toctext">宿主机和虚拟机数据交互</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#%E7%BD%91%E7%BB%9C"><span class="tocnumber">5.1</span> <span class="toctext">网络</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#QEMU_%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="tocnumber">5.2</span> <span class="toctext">QEMU 端口转发</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#QEMU_%E7%9A%84%E5%86%85%E7%BD%AESMB%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="tocnumber">5.3</span> <span class="toctext">QEMU 的内置SMB服务器</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#%E4%BD%BF%E7%94%A8%E7%9B%B4%E9%80%9A%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8CVirtFS"><span class="tocnumber">5.4</span> <span class="toctext">使用直通式文件系统和VirtFS</span></a></li>
<li class="toclevel-2 tocsection-19">
<a href="#%E5%9C%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8A%E6%8C%82%E8%BD%BD%E5%AE%A2%E6%88%B7%E6%9C%BA%E7%9A%84%E5%88%86%E5%8C%BA"><span class="tocnumber">5.5</span> <span class="toctext">在宿主机上挂载客户机的分区</span></a>
<ul>
<li class="toclevel-3 tocsection-20"><a href="#%E6%89%8B%E5%8A%A8%E6%8C%87%E5%87%BA%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="tocnumber">5.5.1</span> <span class="toctext">手动指出偏移量</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#loop%E6%A8%A1%E5%9D%97%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E5%88%86%E5%8C%BA"><span class="tocnumber">5.5.2</span> <span class="toctext">loop模块自动检测分区</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#%E4%BD%BF%E7%94%A8_kpartx"><span class="tocnumber">5.5.3</span> <span class="toctext">使用 kpartx</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#%E6%8C%82%E8%BD%BDqcow2%E9%95%9C%E5%83%8F%E5%86%85%E7%9A%84%E5%88%86%E5%8C%BA"><span class="tocnumber">5.5.4</span> <span class="toctext">挂载qcow2镜像内的分区</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-24">
<a href="#%E5%B0%86%E4%BB%BB%E6%84%8F%E5%88%86%E5%8C%BA%E4%BD%9C%E4%B8%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%94%AF%E4%B8%80%E4%B8%BB%E5%88%86%E5%8C%BA"><span class="tocnumber">5.6</span> <span class="toctext">将任意分区作为磁盘镜像唯一主分区</span></a>
<ul>
<li class="toclevel-3 tocsection-25"><a href="#%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A_kernel_%E5%92%8C_initrd"><span class="tocnumber">5.6.1</span> <span class="toctext">手动指定 kernel 和 initrd</span></a></li>
<li class="toclevel-3 tocsection-26">
<a href="#%E6%A8%A1%E6%8B%9F%E4%B8%80%E5%9D%97%E5%B8%A6MBR%E7%9A%84%E7%A3%81%E7%9B%98"><span class="tocnumber">5.6.2</span> <span class="toctext">模拟一块带MBR的磁盘</span></a>
<ul>
<li class="toclevel-4 tocsection-27"><a href="#%E8%AE%BE%E5%A4%87%E6%98%A0%E5%B0%84%E5%99%A8"><span class="tocnumber">5.6.2.1</span> <span class="toctext">设备映射器</span></a></li>
<li class="toclevel-4 tocsection-28"><a href="#%E7%BA%BF%E6%80%A7_RAID"><span class="tocnumber">5.6.2.2</span> <span class="toctext">线性 RAID</span></a></li>
<li class="toclevel-4 tocsection-29"><a href="#%E7%BD%91%E7%BB%9C%E5%9D%97%E8%AE%BE%E5%A4%87"><span class="tocnumber">5.6.2.3</span> <span class="toctext">网络块设备</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-30">
<a href="#%E7%BD%91%E7%BB%9C_2"><span class="tocnumber">6</span> <span class="toctext">网络</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#%E5%85%B3%E4%BA%8E%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%B0%E5%9D%80%E7%9A%84%E9%99%90%E5%88%B6"><span class="tocnumber">6.1</span> <span class="toctext">关于链路层地址的限制</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F"><span class="tocnumber">6.2</span> <span class="toctext">用户模式</span></a></li>
<li class="toclevel-2 tocsection-33">
<a href="#Tap_%E7%BD%91%E7%BB%9C"><span class="tocnumber">6.3</span> <span class="toctext">Tap 网络</span></a>
<ul>
<li class="toclevel-3 tocsection-34"><a href="#%E4%BB%85%E4%B8%BB%E6%9C%BA_%E7%BD%91%E7%BB%9C"><span class="tocnumber">6.3.1</span> <span class="toctext">仅主机 网络</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="tocnumber">6.3.2</span> <span class="toctext">内部网络</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#%E4%BD%BF%E7%94%A8_qemu-bridge-helper_%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="tocnumber">6.3.3</span> <span class="toctext">使用 qemu-bridge-helper 桥接网络</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#%E6%89%8B%E5%B7%A5%E5%88%9B%E5%BB%BA%E7%BD%91%E6%A1%A5"><span class="tocnumber">6.3.4</span> <span class="toctext">手工创建网桥</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8CTap%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E9%80%9A%E8%BF%87iptables%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB"><span class="tocnumber">6.3.5</span> <span class="toctext">物理设备和Tap设备之间通过iptables进行网络共享</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39">
<a href="#%E9%80%9A%E8%BF%87_VDE2_%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C"><span class="tocnumber">6.4</span> <span class="toctext">通过 VDE2 配置网络</span></a>
<ul>
<li class="toclevel-3 tocsection-40"><a href="#%E4%BD%95%E4%B8%BAVDE?"><span class="tocnumber">6.4.1</span> <span class="toctext">何为VDE?</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="tocnumber">6.4.2</span> <span class="toctext">基础操作</span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="tocnumber">6.4.3</span> <span class="toctext">启动脚本</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="#%E5%A4%87%E7%94%A8%E6%96%B9%E6%B3%95"><span class="tocnumber">6.4.4</span> <span class="toctext">备用方法</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-44">
<a href="#VDE2_%E7%BD%91%E6%A1%A5"><span class="tocnumber">6.5</span> <span class="toctext">VDE2 网桥</span></a>
<ul>
<li class="toclevel-3 tocsection-45"><a href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C_2"><span class="tocnumber">6.5.1</span> <span class="toctext">基础操作</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC_2"><span class="tocnumber">6.5.2</span> <span class="toctext">启动脚本</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-47"><a href="#%E7%AE%80%E5%8C%96%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="tocnumber">6.6</span> <span class="toctext">简化配置参数</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-48">
<a href="#%E5%9B%BE%E5%BD%A2"><span class="tocnumber">7</span> <span class="toctext">图形</span></a>
<ul>
<li class="toclevel-2 tocsection-49"><a href="#std"><span class="tocnumber">7.1</span> <span class="toctext">std</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="#qxl"><span class="tocnumber">7.2</span> <span class="toctext">qxl</span></a></li>
<li class="toclevel-2 tocsection-51"><a href="#vmware"><span class="tocnumber">7.3</span> <span class="toctext">vmware</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#virtio"><span class="tocnumber">7.4</span> <span class="toctext">virtio</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#cirrus"><span class="tocnumber">7.5</span> <span class="toctext">cirrus</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#none"><span class="tocnumber">7.6</span> <span class="toctext">none</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-55">
<a href="#SPICE"><span class="tocnumber">8</span> <span class="toctext">SPICE</span></a>
<ul>
<li class="toclevel-2 tocsection-56"><a href="#Enabling_SPICE_support_on_the_host"><span class="tocnumber">8.1</span> <span class="toctext">Enabling SPICE support on the host</span></a></li>
<li class="toclevel-2 tocsection-57">
<a href="#%E9%80%9A%E8%BF%87_SPICE_%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%AE%A2%E6%88%B7%E6%9C%BA"><span class="tocnumber">8.2</span> <span class="toctext">通过 SPICE 客户端连接到客户机</span></a>
<ul>
<li class="toclevel-3 tocsection-58"><a href="#%E6%89%8B%E5%8A%A8%E5%BC%80%E5%90%AFSPICE%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="tocnumber">8.2.1</span> <span class="toctext">手动开启SPICE客户端</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="#QEMU%E8%BF%90%E8%A1%8C%E6%97%B6%E5%90%AF%E5%8A%A8SPICE"><span class="tocnumber">8.2.2</span> <span class="toctext">QEMU运行时启动SPICE</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-60"><a href="#%E5%9C%A8%E5%AE%A2%E6%88%B7%E6%9C%BA%E4%B8%8A%E5%BC%80%E5%90%AFSPICE%E7%9A%84%E6%94%AF%E6%8C%81"><span class="tocnumber">8.3</span> <span class="toctext">在客户机上开启SPICE的支持</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#%E5%BC%80%E5%90%AFSPICE%E5%8F%A3%E4%BB%A4%E9%AA%8C%E8%AF%81"><span class="tocnumber">8.4</span> <span class="toctext">开启SPICE口令验证</span></a></li>
<li class="toclevel-2 tocsection-62"><a href="#%E7%94%A8TLS%E5%AF%B9%E4%B8%8ESPICE%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86"><span class="tocnumber">8.5</span> <span class="toctext">用TLS对与SPICE的通信进行加密</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-63">
<a href="#VNC"><span class="tocnumber">9</span> <span class="toctext">VNC</span></a>
<ul>
<li class="toclevel-2 tocsection-64"><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8F%A3%E4%BB%A4%E9%AA%8C%E8%AF%81"><span class="tocnumber">9.1</span> <span class="toctext">基本的口令验证</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-65">
<a href="#%E9%9F%B3%E9%A2%91"><span class="tocnumber">10</span> <span class="toctext">音频</span></a>
<ul>
<li class="toclevel-2 tocsection-66"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA"><span class="tocnumber">10.1</span> <span class="toctext">宿主机</span></a></li>
<li class="toclevel-2 tocsection-67">
<a href="#%E5%AE%A2%E6%88%B7%E6%9C%BA"><span class="tocnumber">10.2</span> <span class="toctext">客户机</span></a>
<ul>
<li class="toclevel-3 tocsection-68">
<a href="#%E4%BD%BF%E7%94%A8%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87"><span class="tocnumber">10.2.1</span> <span class="toctext">使用音频设备</span></a>
<ul>
<li class="toclevel-4 tocsection-69"><a href="#Intel_HD_Audio"><span class="tocnumber">10.2.1.1</span> <span class="toctext">Intel HD Audio</span></a></li>
<li class="toclevel-4 tocsection-70"><a href="#Intel_82801AA_AC97"><span class="tocnumber">10.2.1.2</span> <span class="toctext">Intel 82801AA AC97</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-71"><a href="#%E6%97%A0%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87"><span class="tocnumber">10.2.2</span> <span class="toctext">无音频设备</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-72">
<a href="#%E5%AE%89%E8%A3%85_virtio_%E9%A9%B1%E5%8A%A8"><span class="tocnumber">11</span> <span class="toctext">安装 virtio 驱动</span></a>
<ul>
<li class="toclevel-2 tocsection-73"><a href="#(Arch)_Linux_%E5%AE%A2%E6%88%B7%E6%9C%BA"><span class="tocnumber">11.1</span> <span class="toctext">(Arch) Linux 客户机</span></a></li>
<li class="toclevel-2 tocsection-74">
<a href="#Windows_%E5%AE%A2%E6%88%B7%E6%9C%BA"><span class="tocnumber">11.2</span> <span class="toctext">Windows 客户机</span></a>
<ul>
<li class="toclevel-3 tocsection-75">
<a href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="tocnumber">11.2.1</span> <span class="toctext">块设备驱动</span></a>
<ul>
<li class="toclevel-4 tocsection-76"><a href="#%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Windows"><span class="tocnumber">11.2.1.1</span> <span class="toctext">安装一个新的Windows</span></a></li>
<li class="toclevel-4 tocsection-77"><a href="#%E5%B0%86%E7%8E%B0%E6%9C%89%E7%9A%84Windows_VM%E8%BD%AC%E4%B8%BA%E4%BD%BF%E7%94%A8virtio"><span class="tocnumber">11.2.1.2</span> <span class="toctext">将现有的Windows VM转为使用virtio</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-78"><a href="#%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8"><span class="tocnumber">11.2.2</span> <span class="toctext">网络驱动</span></a></li>
<li class="toclevel-3 tocsection-79"><a href="#Balloon_%E9%A9%B1%E5%8A%A8"><span class="tocnumber">11.2.3</span> <span class="toctext">Balloon 驱动</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-80"><a href="#FreeBSD%E5%AE%A2%E6%88%B7%E6%9C%BA"><span class="tocnumber">11.3</span> <span class="toctext">FreeBSD客户机</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-81">
<a href="#QEMU_%E7%9B%91%E8%A7%86%E5%99%A8"><span class="tocnumber">12</span> <span class="toctext">QEMU 监视器</span></a>
<ul>
<li class="toclevel-2 tocsection-82">
<a href="#%E8%AE%BF%E9%97%AEQEMU%E7%9B%91%E8%A7%86%E5%99%A8Console"><span class="tocnumber">12.1</span> <span class="toctext">访问QEMU监视器Console</span></a>
<ul>
<li class="toclevel-3 tocsection-83"><a href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="tocnumber">12.1.1</span> <span class="toctext">图形化界面</span></a></li>
<li class="toclevel-3 tocsection-84"><a href="#Telnet"><span class="tocnumber">12.1.2</span> <span class="toctext">Telnet</span></a></li>
<li class="toclevel-3 tocsection-85"><a href="#UNIX_socket"><span class="tocnumber">12.1.3</span> <span class="toctext">UNIX socket</span></a></li>
<li class="toclevel-3 tocsection-86"><a href="#TCP"><span class="tocnumber">12.1.4</span> <span class="toctext">TCP</span></a></li>
<li class="toclevel-3 tocsection-87"><a href="#%E6%A0%87%E5%87%86_I/O"><span class="tocnumber">12.1.5</span> <span class="toctext">标准 I/O</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-88"><a href="#%E5%9C%A8Monitor_conosle%E4%B8%8B%E5%90%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%91%E9%80%81%E6%8C%89%E9%94%AE%E8%A1%8C%E4%B8%BA"><span class="tocnumber">12.2</span> <span class="toctext">在Monitor conosle下向虚拟机发送按键行为</span></a></li>
<li class="toclevel-2 tocsection-89"><a href="#%E9%80%9A%E8%BF%87_monitor_console_%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E5%92%8C%E7%AE%A1%E7%90%86%E5%BF%AB%E7%85%A7"><span class="tocnumber">12.3</span> <span class="toctext">通过 monitor console 创建快照和管理快照</span></a></li>
<li class="toclevel-2 tocsection-90"><a href="#%E4%BB%A5%E5%86%BB%E7%BB%93%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="tocnumber">12.4</span> <span class="toctext">以冻结模式运行虚拟机</span></a></li>
<li class="toclevel-2 tocsection-91"><a href="#monitor_console%E4%B8%AD%E7%9A%84%E5%BC%80%E6%9C%BA%E5%92%8C%E6%9A%82%E5%81%9C%E5%91%BD%E4%BB%A4"><span class="tocnumber">12.5</span> <span class="toctext">monitor console中的开机和暂停命令</span></a></li>
<li class="toclevel-2 tocsection-92"><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%88%AA%E5%B1%8F"><span class="tocnumber">12.6</span> <span class="toctext">虚拟机截屏</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-93">
<a href="#QEMU_%E6%9C%BA%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="tocnumber">13</span> <span class="toctext">QEMU 机器协议</span></a>
<ul>
<li class="toclevel-2 tocsection-94"><a href="#%E5%90%AF%E5%8A%A8_QMP"><span class="tocnumber">13.1</span> <span class="toctext">启动 QMP</span></a></li>
<li class="toclevel-2 tocsection-95"><a href="#%E5%8D%B3%E6%97%B6%E5%B0%86%E5%AD%90%E9%95%9C%E5%83%8F%E5%90%88%E5%B9%B6%E8%87%B3%E7%88%B6%E9%95%9C%E5%83%8F%E4%B8%AD"><span class="tocnumber">13.2</span> <span class="toctext">即时将子镜像合并至父镜像中</span></a></li>
<li class="toclevel-2 tocsection-96"><a href="#%E5%8D%B3%E6%97%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BF%AB%E7%85%A7"><span class="tocnumber">13.3</span> <span class="toctext">即时创建一个新的快照</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-97">
<a href="#%E6%8A%80%E5%B7%A7"><span class="tocnumber">14</span> <span class="toctext">技巧</span></a>
<ul>
<li class="toclevel-2 tocsection-98"><a href="#%E6%94%B9%E5%96%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0"><span class="tocnumber">14.1</span> <span class="toctext">改善虚拟机的性能表现</span></a></li>
<li class="toclevel-2 tocsection-99">
<a href="#%E5%BC%80%E6%9C%BA%E6%97%B6%E5%90%AF%E5%8A%A8QEMU%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="tocnumber">14.2</span> <span class="toctext">开机时启动QEMU虚拟机</span></a>
<ul>
<li class="toclevel-3 tocsection-100"><a href="#%E9%80%9A%E8%BF%87libvirt%E5%AE%9E%E7%8E%B0"><span class="tocnumber">14.2.1</span> <span class="toctext">通过libvirt实现</span></a></li>
<li class="toclevel-3 tocsection-101"><a href="#%E9%80%9A%E8%BF%87systemd_service%E5%AE%9E%E7%8E%B0"><span class="tocnumber">14.2.2</span> <span class="toctext">通过systemd service实现</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-102"><a href="#%E9%BC%A0%E6%A0%87%E6%95%B4%E5%90%88"><span class="tocnumber">14.3</span> <span class="toctext">鼠标整合</span></a></li>
<li class="toclevel-2 tocsection-103"><a href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84USB%E8%AE%BE%E5%A4%87%E4%BC%A0%E9%80%92%E8%87%B3%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="tocnumber">14.4</span> <span class="toctext">宿主机的USB设备传递至虚拟机</span></a></li>
<li class="toclevel-2 tocsection-104"><a href="#%E4%BD%BF%E7%94%A8SPICE%E8%BF%9B%E8%A1%8CUSB%E9%87%8D%E5%AE%9A%E5%90%91"><span class="tocnumber">14.5</span> <span class="toctext">使用SPICE进行USB重定向</span></a></li>
<li class="toclevel-2 tocsection-105"><a href="#%E5%BC%80%E5%90%AFKSM"><span class="tocnumber">14.6</span> <span class="toctext">开启KSM</span></a></li>
<li class="toclevel-2 tocsection-106"><a href="#%E5%A4%9A%E5%B1%8F%E6%94%AF%E6%8C%81"><span class="tocnumber">14.7</span> <span class="toctext">多屏支持</span></a></li>
<li class="toclevel-2 tocsection-107"><a href="#%E5%A4%8D%E5%88%B6%E5%92%8C%E7%B2%98%E8%B4%B4"><span class="tocnumber">14.8</span> <span class="toctext">复制和粘贴</span></a></li>
<li class="toclevel-2 tocsection-108">
<a href="#Windows%E4%B8%93%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="tocnumber">14.9</span> <span class="toctext">Windows专用说明</span></a>
<ul>
<li class="toclevel-3 tocsection-109"><a href="#%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE"><span class="tocnumber">14.9.1</span> <span class="toctext">快速启动设置</span></a></li>
<li class="toclevel-3 tocsection-110"><a href="#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%8D%8F%E8%AE%AE"><span class="tocnumber">14.9.2</span> <span class="toctext">远程桌面协议</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-111"><a href="#%E5%9C%A8%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%85%8B%E9%9A%86%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84Linux%E7%B3%BB%E7%BB%9F"><span class="tocnumber">14.10</span> <span class="toctext">在物理设备上克隆一个已安装的Linux系统</span></a></li>
<li class="toclevel-2 tocsection-112"><a href="#%E4%BB%8Ex86_64%E7%8E%AF%E5%A2%83%E4%B8%ADChroot%E8%87%B3arm/arm64%E7%8E%AF%E5%A2%83"><span class="tocnumber">14.11</span> <span class="toctext">从x86_64环境中Chroot至arm/arm64环境</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-113">
<a href="#%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="tocnumber">15</span> <span class="toctext">处理常见问题</span></a>
<ul>
<li class="toclevel-2 tocsection-114"><a href="#%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%8A%96%E5%8A%A8%E6%88%96%E8%80%85%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="tocnumber">15.1</span> <span class="toctext">鼠标指针抖动或者不稳定</span></a></li>
<li class="toclevel-2 tocsection-115"><a href="#%E7%9C%8B%E4%B8%8D%E8%A7%81%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88"><span class="tocnumber">15.2</span> <span class="toctext">看不见鼠标指针</span></a></li>
<li class="toclevel-2 tocsection-116"><a href="#%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88"><span class="tocnumber">15.3</span> <span class="toctext">有两个不同的鼠标指针</span></a></li>
<li class="toclevel-2 tocsection-117"><a href="#%E4%BD%BF%E7%94%A8VNC%E6%97%B6%E9%94%AE%E7%9B%98%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="tocnumber">15.4</span> <span class="toctext">使用VNC时键盘出现问题</span></a></li>
<li class="toclevel-2 tocsection-118"><a href="#%E9%94%AE%E7%9B%98%E5%83%8F%E5%9D%8F%E4%BA%86%E4%B8%80%E6%A0%B7%E6%88%96%E8%80%85%E6%96%B9%E5%90%91%E9%94%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8"><span class="tocnumber">15.5</span> <span class="toctext">键盘像坏了一样或者方向键不起作用</span></a></li>
<li class="toclevel-2 tocsection-119"><a href="#%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="tocnumber">15.6</span> <span class="toctext">无法读取键盘映射文件</span></a></li>
<li class="toclevel-2 tocsection-120"><a href="#%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%9C%A8%E8%B0%83%E6%95%B4%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E6%97%B6%E4%B8%80%E8%B5%B7%E8%A2%AB%E6%8B%89%E4%BC%B8%E4%BA%86"><span class="tocnumber">15.7</span> <span class="toctext">客户机在调整窗口大小时一起被拉伸了</span></a></li>
<li class="toclevel-2 tocsection-121"><a href="#ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy"><span class="tocnumber">15.8</span> <span class="toctext">ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</span></a></li>
<li class="toclevel-2 tocsection-122"><a href="#libgfapi_%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="tocnumber">15.9</span> <span class="toctext">libgfapi 的错误信息</span></a></li>
<li class="toclevel-2 tocsection-123"><a href="#LIVE-environments_%E4%B8%8A%E5%8F%91%E7%94%9F%E5%86%85%E6%A0%B8%E9%94%99%E8%AF%AF"><span class="tocnumber">15.10</span> <span class="toctext">LIVE-environments 上发生内核错误</span></a></li>
<li class="toclevel-2 tocsection-124"><a href="#Windows_7_%E5%AE%A2%E6%88%B7%E6%9C%BA%E7%9A%84%E9%9F%B3%E9%A2%91%E8%B4%A8%E9%87%8F%E5%B7%AE"><span class="tocnumber">15.11</span> <span class="toctext">Windows 7 客户机的音频质量差</span></a></li>
<li class="toclevel-2 tocsection-125"><a href="#Could_not_access_KVM_kernel_module:_Permission_denied"><span class="tocnumber">15.12</span> <span class="toctext">Could not access KVM kernel module: Permission denied</span></a></li>
<li class="toclevel-2 tocsection-126"><a href="#%E5%90%AF%E5%8A%A8Windows_VM%E6%97%B6%E4%BA%A7%E7%94%9F_%22System_Thread_Exception_Not_Handled%22"><span class="tocnumber">15.13</span> <span class="toctext">启动Windows VM时产生 "System Thread Exception Not Handled"</span></a></li>
<li class="toclevel-2 tocsection-127"><a href="#%E6%9F%90%E4%BA%9BWindows%E6%B8%B8%E6%88%8F/%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%87%B4%E8%93%9D%E5%B1%8F%E5%87%BA%E7%8E%B0"><span class="tocnumber">15.14</span> <span class="toctext">某些Windows游戏/程序导致蓝屏出现</span></a></li>
<li class="toclevel-2 tocsection-128"><a href="#VM%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%BE%88%E9%AB%98%E7%9A%84%E5%BB%B6%E8%BF%9F%EF%BC%8C%E6%88%96%E6%98%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E5%BE%88%E9%95%BF%E7%9A%84%E6%97%B6%E9%97%B4%E6%89%8D%E4%BC%9A%E5%90%AF%E5%8A%A8"><span class="tocnumber">15.15</span> <span class="toctext">VM中的应用程序有很高的延迟，或是需要等待很长的时间才会启动</span></a></li>
<li class="toclevel-2 tocsection-129"><a href="#%E4%B8%AD%E6%96%AD%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E4%B8%8D%E6%B5%81%E7%95%85"><span class="tocnumber">15.16</span> <span class="toctext">中断时间过长以及运行不流畅</span></a></li>
<li class="toclevel-2 tocsection-130"><a href="#QXL%E5%AF%BC%E8%87%B4%E8%A7%86%E9%A2%91%E5%88%86%E8%BE%A8%E7%8E%87%E9%99%8D%E4%BD%8E"><span class="tocnumber">15.17</span> <span class="toctext">QXL导致视频分辨率降低</span></a></li>
<li class="toclevel-2 tocsection-131"><a href="#%E5%9C%A8_VM_initramfs_%E6%97%B6%E6%8C%82%E8%B5%B7"><span class="tocnumber">15.18</span> <span class="toctext">在 VM initramfs 时挂起</span></a></li>
<li class="toclevel-2 tocsection-132"><a href="#%E4%BD%BF%E7%94%A8%E5%90%AF%E7%94%A8%E4%BA%86%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8%E7%9A%84OVMF%E6%97%B6%EF%BC%8CVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8"><span class="tocnumber">15.19</span> <span class="toctext">使用启用了安全启动的OVMF时，VM无法启动</span></a></li>
<li class="toclevel-2 tocsection-133"><a href="#%E5%AE%A2%E6%88%B7%E6%9C%BA%E4%B8%8A%E7%9A%84%E4%B8%AD%E6%96%AD%E6%B2%A1%E6%9C%89%E8%A2%AB%E8%A7%A6%E5%8F%91"><span class="tocnumber">15.20</span> <span class="toctext">客户机上的中断没有被触发</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-134"><a href="#%E5%8F%82%E9%98%85"><span class="tocnumber">16</span> <span class="toctext">参阅</span></a></li>
</ul>
</div>

<h2>
<span id=".E5.AE.89.E8.A3.85"></span><span class="mw-headline" id="安装">安装</span>
</h2>
<p><a href="../zh-CN/Help:Reading.html#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85" class="mw-redirect" title="安装">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu">qemu</a></span>，(或 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-headless">qemu-headless</a></span>，一个没有GUI的版本）并根据需要安装下面的可选软件包：
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-arch-extra">qemu-arch-extra</a></span> - 额外架构支持</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span> - <a href="../en/Glusterfs.html" title="Glusterfs">Glusterfs</a> block 支持</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span> - <a href="../en/ISCSI.html" title="ISCSI">iSCSI</a> block 支持</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-rbd">qemu-block-rbd</a></span> - RBD block 支持</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=samba">samba</a></span> - <a href="../en/Samba.html" title="Samba">SMB/CIFS</a> 服务器支持</li>
</ul>
<p>除了这些之外, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-user-static/">qemu-user-static</a></span><sup><small>AUR</small></sup> 提供了qemu在user-mode下运行静态编译程序的支持
</p>
<h3>
<span id="QEMU_.E5.8F.98.E7.A7.8D"></span><span class="mw-headline" id="QEMU_变种">QEMU 变种</span>
</h3>
<p>QEMU提供了多个变种以供用户在不同场景中使用。
</p>
<p>粗略地说，QEMU有两种运行模式:
</p>
<dl>
<dt>全系统模拟模式 (full-system emulation)</dt>
<dd>在该模式下, QEMU将会模拟一个完整的系统，包含一个或多个处理器以及各种外围设备。这种模式更加贴近真实的系统，且这种模式不要求被模拟的客户机系统是Linux，但它的速度较慢。</dd>
<dd>QEMU中启用full-system模式的命令依照如下规则进行命名 <code>qemu-system-<i>目标机器架构</i></code>, 例如 <code>qemu-system-x86_64</code> 用于模拟64位intel架构CPU, <code>qemu-system-i386</code> 模拟32位intel架构CPU, <code>qemu-system-arm</code> 模拟ARM架构(32 位), <code>qemu-system-aarch64</code> 模拟ARM架构(64位), 等等。</dd>
<dd>如果模拟的CPU架构与宿主机的CPU架构相同, 那么即使在此模式下，QEMU仍有可能使用hypervisor(例如<a href="#%E5%90%AF%E7%94%A8_KVM">KVM</a> or Xen)的技术对模拟机进行加速。</dd>
<dt><a rel="nofollow" class="external text" href="https://www.qemu.org/docs/master/user/main.html">用户模式(Usermode emulation)</a></dt>
<dd>在此模式下, QEMU能够利用宿主机的系统资源来调用为其他架构编译的Linux可执行文件。当然，里面依旧存在一些小问题, 比如说一些功能特性没有被实现, 采用动态链接的可执行文件无法直接在上面使用 (参阅<a href="#%E4%BB%8Ex86_64%E7%8E%AF%E5%A2%83%E4%B8%ADChroot%E8%87%B3arm/arm64%E7%8E%AF%E5%A2%83">#从x86_64环境中Chroot至arm/arm64环境</a>解决该问题) 并且只支持Linux程序 (尽管我们可以使用<a rel="nofollow" class="external text" href="https://wiki.winehq.org/Emulation">wine</a>在Linux上运行windows程序)。</dd>
<dd>QEMU中启用user模式的命令依照如下规则进行命名 <code>qemu-<i>目标机器架构</i></code>, 例如 <code>qemu-x86_64</code> 用于模拟intel 64位的CPU。</dd>
</dl>
<p>QEMU 拥有动态链接和静态链接两个变种:
</p>
<dl>
<dt>动态链接 (默认)</dt>
<dd>
<code>qemu-*</code> 命令依赖于宿主机上的库文件, 因此整个程序体积较小。</dd>
<dt>静态链接</dt>
<dd>
<code>qemu-*</code> 命令则可以在任何架构相同的Linux系统上使用。</dd>
</dl>
<p>在Arch Linux中，全系统模拟有两个变种:
</p>
<dl>
<dt>有界面 (Non-Headless) (默认)</dt>
<dd>这个变种启用了一些GUI相关的特性，需要额外的依赖(例如SDL或GTK)。</dd>
<dt>无界面 (Headless)</dt>
<dd>这个变种不需要GUI相关的依赖 (适用于服务器场景)。</dd>
</dl>
<p>需要注意这两个版本的安装名是一样的 (例如 <code>qemu-system-x86_64</code>) 因此系统上不能同时安装这两个版本。
</p>
<h3>
<span id="Arch_Linux.E4.B8.AD.E7.9B.B8.E5.85.B3.E5.AE.89.E8.A3.85.E5.8C.85.E7.9A.84.E8.AF.A6.E7.BB.86.E4.BF.A1.E6.81.AF"></span><span class="mw-headline" id="Arch_Linux中相关安装包的详细信息">Arch Linux中相关安装包的详细信息</span>
</h3>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu">qemu</a></span> 包提供了 <code>x86_64</code> 架构的模拟器， 可以进行全系统模拟 (<code>qemu-system-x86_64</code>)。 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-arch-extra">qemu-arch-extra</a></span> 包提供了 <code>x86_64</code> 用户模式的模拟 (<code>qemu-x86_64</code>)。 对于其他支持的架构，这个包都提供了全系统模拟和用户模拟两个变种 (比如说 <code>qemu-system-arm</code> 和 <code>qemu-arm</code>)。</li>
<li>这些包的无界面版本 (仅适用于全系统模拟模式) 的名字是 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-headless">qemu-headless</a></span> (仅<code>x86_64</code>) 和 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-headless-arch-extra">qemu-headless-arch-extra</a></span> (其余架构).</li>
<li>可以用如下独立的安装包中的qemu模块扩展全系统模拟的功能: <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-gluster">qemu-block-gluster</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-iscsi">qemu-block-iscsi</a></span>, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-block-rbd">qemu-block-rbd</a></span> 和 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span>.</li>
<li>非官方的AUR包 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-user-static/">qemu-user-static</a></span><sup><small>AUR</small></sup> 为所有QEMU支持的架构提供了一个带用户模式和静态链接模式的变种。它的预编译版本在这个包中: <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-user-static-bin/">qemu-user-static-bin</a></span><sup><small>AUR</small></sup>。 它的QEMU命令依照 <code>qemu-<i>target_architecture</i>-static</code>的规则命名, 例如, <code>qemu-x86_64-static</code> 代表目标架构为intel 64位CPU。</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 目前为止，Arch Linux 无论是在官方仓库还是AUR仓库中都不提供full-system模式和静态链接的QEMU变种，原因是很少有用户需要它们</div>
<h2>
<span id="QEMU_.E7.9A.84.E5.9B.BE.E5.BD.A2.E5.89.8D.E7.AB.AF"></span><span class="mw-headline" id="QEMU_的图形前端">QEMU 的图形前端</span>
</h2>
<p>与其他的虚拟化程序如 <a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a> 和 <a href="../en/VMware.html" title="VMware">VMware</a> 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。
</p>
<p><a href="../zh-CN/Libvirt.html" title="Libvirt (简体中文)">Libvirt</a>提供了一种管理 QEMU 虚拟机的便捷方式。有关可用的前端，请参阅 <a href="../zh-CN/Libvirt.html#.E5.AE.A2.E6.88.B7.E7.AB.AF" title="Libvirt (简体中文)">libvirt 客户端列表</a>。
</p>
<p>QEMU的其他图形化前端:
</p>
<ul><li>
<b>AQEMU</b> — QEMU GUI Qt5编写.</li></ul>
<dl><dd>
<a rel="nofollow" class="external free" href="https://github.com/tobimensch/aqemu">https://github.com/tobimensch/aqemu</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/aqemu/">aqemu</a></span><sup><small>AUR</small></sup>
</dd></dl>
<h2>
<span id=".E5.88.9B.E5.BB.BA.E6.96.B0.E8.99.9A.E6.8B.9F.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="创建新虚拟系统">创建新虚拟系统</span>
</h2>
<h3>
<span id=".E5.88.9B.E5.BB.BA.E7.A1.AC.E7.9B.98.E9.95.9C.E5.83.8F"></span><span class="mw-headline" id="创建硬盘镜像">创建硬盘镜像</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 本页面的英文wiki中，对该节的准确性提出了怀疑，暂时停止该部分的翻译，原页面告警如下： If I get the man page right the raw format only allocates the full size if the filesystem does not support "holes" or it is explicitly told to preallocate. See man qemu-img in section Notes. (Discuss in Talk:QEMU#)</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 有关QEMU图像的更多信息，请参阅 <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Images">QEMU Wikibook</a>。</div>
<p>除非直接从 CD-ROM 或网络引导（并且不安装系统到本地），运行 QEMU 时都需要硬盘镜像。硬盘镜像是一个文件，存储虚拟机硬盘上的内容。
</p>
<p>一个硬盘镜像可能是 <i>raw</i>镜像, 和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。
</p>
<p>另外一种方式是<i>qcow2</i> 格式，仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能（有关详细信息，请参阅 <a href="#%E9%80%9A%E8%BF%87_monitor_console_%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E5%92%8C%E7%AE%A1%E7%90%86%E5%BF%AB%E7%85%A7">#通过 monitor console 创建快照和管理快照</a>）。但是，使用此格式而不是 <i>raw</i> 可能会影响性能。
</p>
<p>QEMU 提供 <code>qemu-img</code>命令创建硬盘镜像.例如创建一个 4 GB <i>raw</i> 格式的镜像:
</p>
<pre>$ qemu-img create -f raw <i>image_file</i> 4G
</pre>
<p>您也可以用 <code>-f qcow2</code> 创建一个 <i>qcow2</i> 镜像。
</p>
<p>用 <code>dd</code> 或 <code>fallocate</code> 也可以创建一个 <i>raw</i> 镜像。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Note:</strong> 您也可以通过 <code>dd</code> 或 <code>fallocate</code> 创建一个所需大小的 <i>raw</i> 镜像。</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> 如果硬盘镜像存储在 <a href="../en/Btrfs.html" title="Btrfs">Btrfs</a> 系统上，则应在创建任何映像之前考虑禁用该目录的 <a href="../en/Btrfs.html#Copy-on-Write_(CoW)" title="Btrfs">写时复制</a>。</div>
<h4>
<span id=".E4.B8.8A.E5.B1.82.E5.AD.98.E5.82.A8.E9.95.9C.E5.83.8F"></span><span class="mw-headline" id="上层存储镜像">上层存储镜像</span>
</h4>
<p>可以创建一个基础镜像，and have QEMU keep mutations to this image in an overlay image. This allows you to revert to a previous state of this storage image. You could revert by creating a new overlay image at the time you wish to revert, based on the original backing image.
</p>
<p>To create an overlay image, issue a command like:
</p>
<pre>$ qemu-img create -o backing_file=<i>img1.raw</i>,backing_fmt=<i>raw</i> -f <i>qcow2</i> <i>img1.cow</i>
</pre>
<p>After that you can run your QEMU VM as usual (see <a href="#%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E7%B3%BB%E7%BB%9F">#运行虚拟化的系统</a>):
</p>
<pre>$ qemu-system-i386 <i>img1.cow</i>
</pre>
<p>The backing image will then be left intact and mutations to this storage will be recorded in the overlay image file.
</p>
<p>When the path to the backing image changes, repair is required.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Warning:</strong> The backing image's absolute filesystem path is stored in the (binary) overlay image file. Changing the backing image's path requires some effort.</div>
<p>Make sure that the original backing image's path still leads to this image. If necessary, make a symbolic link at the original path to the new path. Then issue a command like:
</p>
<pre>$ qemu-img rebase -b <i>/new/img1.raw</i> <i>/new/img1.cow</i>
</pre>
<p>At your discretion, you may alternatively perform an 'unsafe' rebase where the old path to the backing image is not checked:
</p>
<pre>$ qemu-img rebase -u -b <i>/new/img1.raw</i> <i>/new/img1.cow</i>
</pre>
<h4>
<span id=".E8.B0.83.E6.95.B4.E9.95.9C.E5.83.8F.E5.A4.A7.E5.B0.8F"></span><span class="mw-headline" id="调整镜像大小">调整镜像大小</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 调整包含NTFS引导文件系统的镜像将无法启动已安装的操作系统，推荐在操作之前进行备份</div>
<p>执行 <code>qemu-img</code> 带 <code>resize</code> 选项调整硬盘驱动镜像的大小.它适用于 <i>raw</i> 和 <i>qcow2</i>. 例如, 增加镜像 10 GB 大小, 运行:
</p>
<pre>$ qemu-img resize <i>disk_image</i> +10G
</pre>
<p>在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。
在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！
</p>
<h3>
<span id=".E5.87.86.E5.A4.87.E5.AE.89.E8.A3.85.E4.BB.8B.E8.B4.A8"></span><span class="mw-headline" id="准备安装介质">准备安装介质</span>
</h3>
<p>要将操作系统安装到您的磁盘镜像, 你需要操作系统的安装介质 (例如 光盘, USB设备, 或 ISO 镜像). 不要挂载安装介质，因为 QEMU 要直接访问媒体。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 如果使用光盘，最好先将媒体转储到文件中，因为这既可以提高性能，又不需要您直接访问设备（也就是说，您可以将QEMU作为普通用户，而无需更改对媒体设备文件的访问权限）。例如，如果CD-ROM设备节点名为<code>/dev/cdrom</code>，则可以使用以下命令将其转储到文件中：<pre>$ dd if=/dev/cdrom of=<i>cd_image.iso</i></pre>
</div>
<h3>
<span id=".E5.AE.89.E8.A3.85.E6.93.8D.E4.BD.9C.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="安装操作系统">安装操作系统</span>
</h3>
<p>这是你第一次需要去启动模拟器的步骤，为了在磁盘镜像上安装操作系统，你必须同时将磁盘镜像与安装介质装载到虚拟机上，从安装介质中启动操作系统。
</p>
<p>以i386的客户机为例，为了从CD-ROM内的把可用于启动的ISO文件安装到磁盘镜像上，你需要：
</p>
<pre>$ qemu-system-x86_64 -cdrom <i>iso_image</i> -boot order=d -drive file=<i>disk_image</i>,format=raw
</pre>
<p>参阅 <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> 获得更多关于不同类型安装介质的信息 (例如floppy，磁盘镜像和物理驱动盘)，参阅 <a href="#%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E7%B3%BB%E7%BB%9F">#运行虚拟化的系统</a> 了解更多有用的选项。
</p>
<p>在安装完操作系统后，就可以直接从QEMU镜像内启动了。（参阅 <a href="#%E8%BF%90%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E7%B3%BB%E7%BB%9F">#运行虚拟化的系统</a> ）
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 <code>-m</code> 调整， 比如 <code>-m 512M</code> 或 <code>-m 2G</code>。</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 
<ul>
<li>相较于指定 <code>-boot order=x</code> ，一部分用户感觉使用 <code>-boot menu=on</code> 启用boot菜单的体验更舒服些，至少在配置和实验时是这样的。</li>
<li>当使用无界面（headless）模式时， 将会默认在本地5900端口启动一个VNC服务器， 可以用 <a href="../en/TigerVNC.html" title="TigerVNC">TigerVNC</a> 连接到客户机的系统上: <code>vncviewer :5900</code>
</li>
<li>若你在安装过程中需要替换软盘或CD，可以使用QEMU机器监视器（在虚拟机窗口中按<code>Ctrl + Alt + 2</code>）来删除存储设备并将其连接到虚拟机。使用<code> info block</code>查看块设备，然后使用<code>change</code>命令换出设备。按下<code> Ctrl + Alt + 1</code>返回虚拟机。</li>
</ul>
</div>
<h2>
<span id=".E8.BF.90.E8.A1.8C.E8.99.9A.E6.8B.9F.E5.8C.96.E7.9A.84.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="运行虚拟化的系统">运行虚拟化的系统</span>
</h2>
<p><code>qemu-system-*</code> 程序 (例如 <code>qemu-system-i386</code> 或 <code>qemu-system-x86_64</code>, 取决于客户机架构)用来运行虚拟化的客户机. 用法是:
</p>
<pre>$ qemu-system-i386 <i>options</i> <i>disk_image</i>
</pre>
<p>所有 <code>qemu-system-*</code>的选项是相同的,参见 <span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span> 查看文档和所有选项
</p>
<p>默认 QEMU会在窗口中显示虚拟机的视频输出.有一点要记住:当您单击QEMU窗口,鼠标指针被捕获。要放开，按 <code>Ctrl+Alt+g</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> QEMU 不应以 root 身份运行. 如果必须以root身份在某个脚本中运行QEMU，那么你需要使用 <code>-runas</code> 选项让QEMU放弃root权限</div>
<h3>
<span id=".E5.90.AF.E7.94.A8_KVM"></span><span class="mw-headline" id="启用_KVM">启用 KVM</span>
</h3>
<p>KVM 必须要您处理器和内核支持, 和必要的 <a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">kernel modules</a>加载. 更多信息参见 <a href="../en/KVM.html" title="KVM">KVM</a>.
</p>
<p>要在KVM模式中启动QEMU, 追加 <code>-enable-kvm</code>到启动选项. To check if KVM is enabled for a running VM, enter the QEMU <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Monitor">Monitor</a> using <code>Ctrl+Alt+Shift+2</code>, and type <code>info kvm</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 
<ul>
<li>
<code>-machine</code> 选项中的 <code>accel=kvm</code> 参数与<code>-enable-kvm</code> 或 <code>-accel kvm</code> 选项是等价的。</li>
<li>CPU模型 <code>host</code> 需要 KVM。</li>
<li>如果你使用GUI工具去启动QEMU，但是性能体验极差，那么最好检查一下是否真的开启了KVM支持，因为QEMU可能选择了备用的模拟模式，即软件级模拟。</li>
<li>需要启用KVM才能正常启动windows7和windows8，否则会出现“蓝屏”.</li>
</ul>
</div>
<h3>
<span id=".E5.90.AF.E7.94.A8_IOMMU_.28Intel_VT-d.2FAMD-Vi.29_.E7.9A.84.E6.94.AF.E6.8C.81"></span><span class="mw-headline" id="启用_IOMMU_(Intel_VT-d/AMD-Vi)_的支持">启用 IOMMU (Intel VT-d/AMD-Vi) 的支持</span>
</h3>
<p>首先启用IOMMU, 参阅 <a href="../en/PCI_passthrough_via_OVMF.html#Setting_up_IOMMU" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Setting up IOMMU</a>.
</p>
<p>添加 <code>-device intel-iommu</code> 选项创建IOMMU设备:
</p>
<pre>$ qemu-system-x86_64 <b>-enable-kvm -machine q35 -device intel-iommu</b> -cpu host ..
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 
在基于Intel CPU的系统上用 <code>-device intel-iommu</code> 创建QEMU内的IOMMU设备将会禁用PCI直通， 并返回一个像这样的错误报告：  <pre>Device at bus pcie.0 addr 09.0 requires iommu notifier which is currently not supported by intel-iommu emulation</pre>， 虽然仍然需要添加内核参数 <code>intel_iommu=on</code> 来重新映射IO（例如，<a href="../en/PCI_passthrough_via_OVMF.html#Isolating_the_GPU" title="PCI passthrough via OVMF">通过vfio-pci的PCI直通</a>），但如果需要PCI直通，则不应设置<code>-device intel-iommu</code>。</div>
<h2>
<span id=".E5.AE.BF.E4.B8.BB.E6.9C.BA.E5.92.8C.E8.99.9A.E6.8B.9F.E6.9C.BA.E6.95.B0.E6.8D.AE.E4.BA.A4.E4.BA.92"></span><span class="mw-headline" id="宿主机和虚拟机数据交互">宿主机和虚拟机数据交互</span>
</h2>
<h3>
<span id=".E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="网络">网络</span>
</h3>
<p>我们可以利用任何支持文件传输的网络协议实现客户机和宿主机之间的数据交互, 例如 <a href="../en/NFS.html" title="NFS">NFS</a>, <a href="../en/Samba.html" class="mw-redirect" title="SMB">SMB</a>, <a href="https://en.wikipedia.org/wiki/Network_block_device" class="extiw" title="wikipedia:Network block device">NBD</a>, HTTP, <a href="../en/Very_Secure_FTP_Daemon.html" title="Very Secure FTP Daemon">FTP</a>, 或 <a href="../en/Secure_Shell.html" class="mw-redirect" title="SSH">SSH</a>, 当然这么做的前提是你已经配置好二者之间的网络，且在系统上启动了相应的服务程序。
</p>
<p>在默认情况下，用户模式的客户机能够通过10.0.2.2这个IP访问到宿主机。任何运行于宿主机上的服务端程序都可以通过这个地址被访问到，比如说我们可以通过这个IP访问到宿主机上的SSH服务器或SMB服务器。因此在这种情况下，客户机能够挂载宿主机通过<a href="../en/Samba.html" class="mw-redirect" title="SMB">SMB</a> or <a href="../en/NFS.html" title="NFS">NFS</a>暴露出来的目录，也可以访问宿主机上的HTTP服务器等。
通常情况下宿主机无法访问客户机上的服务，不过你也可以通过一些特殊的网络配置达到这个目的 (参阅<a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>)
</p>
<h3>
<span id="QEMU_.E7.AB.AF.E5.8F.A3.E8.BD.AC.E5.8F.91"></span><span class="mw-headline" id="QEMU_端口转发">QEMU 端口转发</span>
</h3>
<p>QEMU能够将宿主机的端口转发到客户机上以实现一些功能，例如从宿主机上访问客户机的SSH端口。
</p>
<p>举个例子，将宿主机上的10022端口与客户机上的22 (SSH) 端口进行绑定， 对应的QEMU命令如下：
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::10022-:22
</pre>
<p>确认你客户机上的sshd程序正在运行，然后可以通过如下命令连接到客户机的SSH端口
</p>
<pre>$ ssh <i>guest-user</i>@localhost -p 10022
</pre>
<p>你可以用 <a href="../en/SSHFS.html" title="SSHFS">SSHFS</a> 把客户机的整个文件系统都挂到宿主机上，这样就可以在宿主机上对客户机的文件系统进行读写了。
</p>
<p>想进行多端口转发的话, 只需要在<code>-nic</code>参数中指定多个<code>hostfwd</code>, 以VNC端口为例:
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -nic user,hostfwd=tcp::10022-:22,hostfwd=tcp::5900-:5900
</pre>
<h3>
<span id="QEMU_.E7.9A.84.E5.86.85.E7.BD.AESMB.E6.9C.8D.E5.8A.A1.E5.99.A8"></span><span class="mw-headline" id="QEMU_的内置SMB服务器">QEMU 的内置SMB服务器</span>
</h3>
<p>QEMU的文档中指出它有一个内置的SMB服务器，但实际上，它只是在宿主机上加载一个自动生成的<code>smb.conf</code>配置文件 (位于<code>/tmp/qemu-smb.<i>random_string</i></code>)，然后启动宿主机上的<a href="../en/Samba.html" title="Samba">Samba</a>，使得客户机能够通过一个IP地址进行访问 (默认的IP地址是10.0.2.4)。这个方法只适用于用户网络，在你不想在宿主机开启通常的<a href="../en/Samba.html" title="Samba">Samba</a>服务 (客户机同样能访问这类Samba服务) 时这个方法还挺好用的。
</p>
<p>选项<code>smb=</code>可以设置仅共享一个目录，如果QEMU的SMB配置允许用户使用符号链接，那么即使在虚拟机运行时新加入更多的目录也很容易，只需要通过在共享目录里创建相应的软链接就行。然而他并没有这么配置，我们可以依照如下进行配置SMB服务器
</p>
<p>宿主机上必须安装 <i>Samba</i>。通过如下QEMU命令启用这项特性:
</p>
<pre>$ qemu-system-x86_64 <i>disk_image</i> -net nic -net user,smb=<i>shared_dir_path</i>
</pre>
<p><code><i>shared_dir_path</i></code> 就是你想要在宿主机和客户机之间共享的目录。
</p>
<p>接着，在客户机内，你应该能够通过10.0.2.4访问到名为qemu的共享文件夹。例如在Windows Explorer中前往 <code>\\10.0.2.4\qemu</code> 这个地址。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 
<ul>
<li>如果你像这样多次指定共享选项 <code>-net user,smb=<i>shared_dir_path1</i> -net user,smb=<i>shared_dir_path2</i></code> or <code>-net user,smb=<i>shared_dir_path1</i>,smb=<i>shared_dir_path2</i></code> qemu只会共享参数中最后的一个目录。</li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows, 请检查 <a rel="nofollow" class="external text" href="http://ecross.mvps.org/howto/enable-netbios-over-tcp-ip-with-windows.htm">NetBIOS 协议是否被启用</a> 并确认防火墙没有屏蔽NetBIOS协议的 <a rel="nofollow" class="external text" href="https://technet.microsoft.com/en-us/library/cc940063.aspx">端口</a>
</li>
<li>如果你不能访问共享文件夹且客户机系统为 Windows 10 Enterprise 或 Education 或 Windows Server 2016, 请<a rel="nofollow" class="external text" href="https://support.microsoft.com/en-us/help/4046019">启用游客访问</a>.</li>
</ul>
</div>
<p>共享多个文件夹并在运行时增删文件夹的一个方法是：共享一个空目录，然后在其中创建指向其余共享目录的符号链接。可以用下面的脚本修改SMB服务器的配置，这个脚本还能使宿主机上不允许执行的文件在客户机内拥有执行权限。
</p>
<pre>#!/bin/bash
eval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print "pid="$1";conf="$6}')
echo "[global]
allow insecure wide links = yes
[qemu]
follow symlinks = yes
wide links = yes
acl allow execute always = yes" &gt;&gt; $conf
# in case the change is not detected automatically:
smbcontrol --configfile=$conf $pid reload-config
</pre>
<p>仅当客户机第一次访问到网络驱动后，才能将该脚本启用，并作用于qemu启动的SMB服务器。共享多文件的另一个方法是在配置文件里加入额外的共享路径，就像下面这样
</p>
<pre>echo "[<i>myshare</i>]
path=<i>another_path</i>
read only=no
guest ok=yes
force user=<i>username</i>" &gt;&gt; $conf
</pre>
<p>这个共享文件夹可以在客户机内通过<code>\\10.0.2.4\<i>myshare</i></code>访问。
</p>
<h3>
<span id=".E4.BD.BF.E7.94.A8.E7.9B.B4.E9.80.9A.E5.BC.8F.E6.96.87.E4.BB.B6.E7.B3.BB.E7.BB.9F.E5.92.8CVirtFS"></span><span class="mw-headline" id="使用直通式文件系统和VirtFS">使用直通式文件系统和VirtFS</span>
</h3>
<p>参阅 <a rel="nofollow" class="external text" href="https://wiki.qemu.org/Documentation/9psetup">QEMU 文档</a>.
</p>
<h3>
<span id=".E5.9C.A8.E5.AE.BF.E4.B8.BB.E6.9C.BA.E4.B8.8A.E6.8C.82.E8.BD.BD.E5.AE.A2.E6.88.B7.E6.9C.BA.E7.9A.84.E5.88.86.E5.8C.BA"></span><span class="mw-headline" id="在宿主机上挂载客户机的分区">在宿主机上挂载客户机的分区</span>
</h3>
<p>在虚拟机运行时，我们仍可以将磁盘镜像内的分区作为loop设备挂载到宿主机，不过一些特殊的磁盘镜像文件并不支持这样的操作，比如说qcow2格式的文件，尽管说在平时能够使用<code>qemu-nbd</code>将qcow2挂载到文件系统上。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 请确保重新运行虚拟机之前，所有挂载的分区都被卸载，否则很可能造成磁盘数据的损坏。</div>
<h4>
<span id=".E6.89.8B.E5.8A.A8.E6.8C.87.E5.87.BA.E5.81.8F.E7.A7.BB.E9.87.8F"></span><span class="mw-headline" id="手动指出偏移量">手动指出偏移量</span>
</h4>
<p>挂载磁盘镜像中分区的一个方法是手动指定挂载的偏移量，你可以使用类似下面的命令完成这个操作：
</p>
<pre># mount -o loop,offset=32256 <i>disk_image</i> <i>mountpoint</i>
</pre>
<p><code>offset=32256</code> 选项实际上会被传递给 <code>losetup</code> 程序，用于设置一个起始地址为32256字节处的loop设备。接着这个loop设备将会被挂载。 你也可以使用 <code>sizelimit</code> 选项指定这个分区的具体大小，通常不需要指定该选项。
具体的偏移量取决于你的磁盘镜像，你所需要的分区可能并不以32256字节处作为起始地址。运行 <code>fdisk -l <i>disk_image</i></code> 查看磁盘镜像中的分区，fdisk会显示分区的起始地址和结束地址，地址以512字节的扇区为单位，因此需要将该地址乘以512获得可用于 <code>mount</code> 的字节偏移量。
</p>
<h4>
<span id="loop.E6.A8.A1.E5.9D.97.E8.87.AA.E5.8A.A8.E6.A3.80.E6.B5.8B.E5.88.86.E5.8C.BA"></span><span class="mw-headline" id="loop模块自动检测分区">loop模块自动检测分区</span>
</h4>
<p>Linux的loop驱动支持loop设备的分区，不过默认情况下它是关闭的，可以通过下面的方法启用：
</p>
<ul>
<li>卸载所有loop设备 (比如说卸载所有挂载的镜像)。</li>
<li>
<a href="../en/Kernel_module.html#Manual_module_handling" class="mw-redirect" title="Kernel modules">卸下</a> the <code>loop</code> 内核模块, 以 <code>max_part=15</code> 参数重新加载该模块。 此外，你可以用 <code>max_loop</code> 参数设置loop设备的最大数量。</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 你可以在 <code>/etc/modprobe.d</code> 增加一个条目使得每次加载loop模块时带上 <code>max_part=15</code> 参数, 或者把 <code>loop.max_part=15</code> 加入内核命令行, 这得看你的内核是否有编译 <code>loop.ko</code> 模块</div>
<p>将镜像文件设置为loop设备:
</p>
<pre># losetup -f -P <i>disk_image</i>
</pre>
<p>接着，假设创建的loop设备名称为 <code>/dev/loop0</code> ，相应的 <code>/dev/loop0pX</code> 也会被自动创建， X代表分区的号码，这些分区可以被直接挂载，例如：
</p>
<pre># mount /dev/loop0p1 <i>mountpoint</i>
</pre>
<p>如要使用 <i>udisksctl</i> 挂载磁盘镜像, 参阅 <a href="../en/Udisks.html#Mount_loop_devices" title="Udisks">Udisks#Mount loop devices</a>.
</p>
<h4>
<span id=".E4.BD.BF.E7.94.A8_kpartx"></span><span class="mw-headline" id="使用_kpartx">使用 kpartx</span>
</h4>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=multipath-tools">multipath-tools</a></span> 包内的 <b>kpartx</b> 可以读取设备的分区表，然后为每个分区创建一个新设备，举个例子：
</p>
<pre># kpartx -a <i>disk_image</i>
</pre>
<p>这条命令将会为你设置loop设备，并在 <code>/dev/mapper/</code> 下创建必要的分区设备。
</p>
<h4>
<span id=".E6.8C.82.E8.BD.BDqcow2.E9.95.9C.E5.83.8F.E5.86.85.E7.9A.84.E5.88.86.E5.8C.BA"></span><span class="mw-headline" id="挂载qcow2镜像内的分区">挂载qcow2镜像内的分区</span>
</h4>
<p>我们将使用 <code>qemu-nbd</code> 完成这一功能, 同时它也能让我们使用 NBD (<i>network block device</i>) 协议共享该磁盘镜像。
</p>
<p>首先，我们需要加载nbd模块：
</p>
<pre># modprobe nbd max_part=16
</pre>
<p>接着，共享该磁盘并创建设备条目：
</p>
<pre># qemu-nbd -c /dev/nbd0 <i>/path/to/image.qcow2</i>
</pre>
<p>进行分区发现检测：
</p>
<pre># partprobe /dev/nbd0
</pre>
<p><i>fdisk</i> 可以获取 {<code><i>nbd0</i></code> 内各分区的相关信息 :
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l /dev/nbd0</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Disk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xa6a4d542

Device      Boot   Start      End  Sectors  Size Id Type
/dev/nbd0p1 *       2048  1026047  1024000  500M  7 HPFS/NTFS/exFAT
/dev/nbd0p2      1026048 52877311 51851264 24.7G  7 HPFS/NTFS/exFAT</pre>
<p>接下来可以挂载镜像的任意分区了，比如说我们要挂载分区2：
</p>
<pre># mount /dev/nbd0<b>p2</b> <i>mountpoint</i>
</pre>
<p>完成任务后，切记卸载镜像文件，然后根据之前的操作一步步还原，即分区并断开与nbd设备的连接：
</p>
<pre># umount <i>mountpoint</i>
# qemu-nbd -d /dev/nbd0
</pre>
<h3>
<span id=".E5.B0.86.E4.BB.BB.E6.84.8F.E5.88.86.E5.8C.BA.E4.BD.9C.E4.B8.BA.E7.A3.81.E7.9B.98.E9.95.9C.E5.83.8F.E5.94.AF.E4.B8.80.E4.B8.BB.E5.88.86.E5.8C.BA"></span><span class="mw-headline" id="将任意分区作为磁盘镜像唯一主分区">将任意分区作为磁盘镜像唯一主分区</span>
</h3>
<p>有时，你可能想在QEMU中使用物理机的一个系统分区。在虚拟机里使用原始分区可以改善读写性能，因为此时QEMU不需要经过宿主机的文件系统层完成读写操作，该分区同样可以用于在宿主机和客户机之间进行数据共享。
</p>
<p>在Arch Linux的默认设置中，代表原始分区的设备文件的所有者为 <i>root</i> ， 隶属于 <i>disk</i>组， 如果你希望使用一个非root用户能够对原始分区进行读写，那么请更改对应设备文件的所有者为该用户，将这个用户加入 <i>disk</i> 组中，或者使用 <a href="../en/Access_Control_Lists.html" class="mw-redirect" title="ACL">ACL</a> 完成更精细的权限管理。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 
<ul>
<li>不推荐给予虚拟机修改宿主机系统上重要数据的权限，比如说对root分区的修改权限，尽管你拥有这么做的能力。</li>
<li>不要同时挂载一块在宿主机和客户机内都可读写的分区，否则会造成数据的损坏。</li>
</ul>
</div>
<p>在完成上述设置后，你可以将该分区作为一块虚拟磁盘添加到QEMU虚拟机内了。
</p>
<p>然而，如果你想使得<i>整个</i>虚拟机都包含在单个分区中，事情就开始变得有些复杂了。在这个场景下，由于系统分区本身是作为文件系统完成格式化的，而非一个带有MBR的分区设备，我们便无法在这个分区上安装bootloader程序，进而也就没有办法启动虚拟机了。要启动这类虚拟机你需要手动指定 <a href="../en/Kernel.html" title="Kernel">kernel</a> 和 <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initrd">initrd</a>， 或者用 <a rel="nofollow" class="external text" href="https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/index.html">Device-mapper</a>/线性 <a href="../en/RAID.html" title="RAID">RAID</a>/<a rel="nofollow" class="external text" href="https://www.kernel.org/doc/html/latest/admin-guide/blockdev/nbd.html">Linux网络块设备</a>模拟一块带MBR的磁盘。
</p>
<h4>
<span id=".E6.89.8B.E5.8A.A8.E6.8C.87.E5.AE.9A_kernel_.E5.92.8C_initrd"></span><span class="mw-headline" id="手动指定_kernel_和_initrd">手动指定 kernel 和 initrd</span>
</h4>
<p>QEMU支持直接加载 <a href="../en/Kernel.html" class="mw-redirect" title="Kernels">Linux kernels</a> 和 <a href="../en/Arch_boot_process.html#initramfs" class="mw-redirect" title="Initramfs">init ramdisks</a>， 从而绕过了类似 <a href="../en/GRUB.html" title="GRUB">GRUB</a> 这类的bootloader程序。它会把包含根文件系统的物理分区作为虚拟机的虚拟磁盘，然后启动虚拟机。通过类似下面的命令可以完成这些操作：
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 在示例中， 我们使用的是 <b>宿主机的</b> 镜像，而非客户机的。如果你希望使用客户机的镜像，请将 <code>/dev/sda3</code> 设置为只读（为了保护宿主机上的文件系统）， 并且指定 <code>/full/path/to/images</code> ， 或者在客户机内使用一些 kexec的技巧， 重新加载客户机的内核（延长启动时）</div>
<pre>$ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3
</pre>
<p>在上面这个例子中， 宿主机上的 <code>/dev/sda3</code> 物理分区被用于客户机的根文件系统， 但是在虚拟机内部它的名字则是 <code>/dev/sda</code> 
</p>
<p>当然你可以指定任意一个kernel和initrd，而不局限于Arch Linux提供的。
</p>
<p><code>-append</code> 中可以传递许多 <a href="../en/Kernel_parameters.html" class="mw-redirect" title="Kernel parameter">kernel parameter</a>， 需要用单引号或双引号将他们包起来，比如：
</p>
<pre>... -append 'root=/dev/sda1 console=ttyS0'
</pre>
<h4>
<span id=".E6.A8.A1.E6.8B.9F.E4.B8.80.E5.9D.97.E5.B8.A6MBR.E7.9A.84.E7.A3.81.E7.9B.98"></span><span class="mw-headline" id="模拟一块带MBR的磁盘">模拟一块带MBR的磁盘</span>
</h4>
<p>当我们想要既保持物理分区遵循文件系统的格式，又作为客户机的虚拟磁盘包含客户机内的分区时，我们有一个比较复杂的方法，那就是模拟一块带MBR的磁盘，这样就使得它可以被类似GRUB的引导程序正常启动。
</p>
<p>假设你有一块普通的、未挂载的硬盘分区 <code>/dev/hda<i>N</i></code> ，分区内有些文件系统， 若想将其制作为QEMU硬盘镜像，需要在该物理分区内动态地预置一个主引导记录（MBR）。更宽泛地说，该分区可以是更大的模拟磁盘中的一部分，尤其是那种模拟了物理磁盘，但仅向虚拟机暴露 <code>/dev/hda<i>N</i></code> 名称的块设备。
</p>
<p>这类虚拟磁盘可以用带引用的VMDK文件形容，VMDK内的引用指向MBR的副本以及实际的分区。 但QEMU并不支持这类VMDK格式，例如通过<a rel="nofollow" class="external text" href="https://www.virtualbox.org/manual/ch09.html#rawdisk">如下命令创建</a>的虚拟机：
</p>
<pre>$ VBoxManage internalcommands createrawvmdk -filename <i>/path/to/file.vmdk</i> -rawdisk /dev/hda
</pre>
<p>将会被QEMU拒绝，并返回一个错误信息
</p>
<pre>Unsupported image type 'partitionedDevice'
</pre>
<p>注意 <code>VBoxManage</code> 会创建两个文件, <code><i>file.vmdk</i></code> 和 <code><i>file-pt.vmdk</i></code>, 后一个是MBR的副本, <code>file.vmdk</code> 。 对目标分区外的数据或MBR本身的读操作将会返回0， 而写操作则会被丢弃。
</p>
<h5>
<span id=".E8.AE.BE.E5.A4.87.E6.98.A0.E5.B0.84.E5.99.A8"></span><span class="mw-headline" id="设备映射器">设备映射器</span>
</h5>
<p>与使用VMDK描述文件类似的方法就是使用设备映射器，设备映射器会在目标分区内添加一份带有有loop设备的MBR文件。在此种情况下，不要求虚拟磁盘与原始分区拥有同样的大小。首先创建一个包含MBR的文件：
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=2048
</pre>
<p>在这里，我们通过这个命令，使用现代化的磁盘分区程序创建了一个符合分区对齐策略的文件，总共大小为1MB （2048 * 512 字节）。为了兼容老式的磁盘分区程序（老式的分区程序可能要求其为63个扇区而非2048个扇区）， MBR表仅占一块512字节的块，剩余的空间可以用于创建一个BIOS启动分区，或者在创建一个在混合分区方案中需要用到的GUID分区表。接着我们将loop设备附加到MBR文件上：
</p>
<pre># losetup --show -f <i>/path/to/mbr</i>
/dev/loop0
</pre>
<p>在这个例子里，最终生成的设备为 <code>/dev/loop0</code> ，设备映射器将会把MBR文件与分区结合起来。
</p>
<pre># echo "0 2048 linear /dev/loop0 0
2048 `blockdev --getsz /dev/hda<i>N</i>` linear /dev/hda<i>N</i> 0" | dmsetup create qemu
</pre>
<p>生成的 <code>/dev/mapper/qemu</code> 可以被作为QEMU原生镜像使用了，额外的步骤需要你去在虚拟磁盘上创建一个分区表(参阅关于 linear RAID 的部分， 它可以作为创建分区表的一个范例)， 以及相应的bootloader代码 (代码会存放在  
</p>
<pre><code><i>/path/to/mbr</i></code> )
</pre>
<p>下面的步骤中， <code>/dev/hda<i>N</i></code> 在虚拟磁盘和物理磁盘上的位置都相同，并且除了MBR（副本）外磁盘的其余部分都是隐藏的：
</p>
<pre># dd if=/dev/hda count=1 of=<i>/path/to/mbr</i>
# loop=`losetup --show -f <i>/path/to/mbr</i>`
# start=`blockdev --report /dev/hda<i>N</i> | tail -1 | awk '{print $5}'`
# size=`blockdev --getsz /dev/hda<i>N</i>`
# disksize=`blockdev --getsz /dev/hda`
# echo "0 1 linear $loop 0
1 $((start-1)) zero
$start $size linear /dev/hda<i>N</i> 0
$((start+size)) $((disksize-start-size)) zero" | dmsetup create qemu
</pre>
<p>通过管道传入作为 <code>dmsetup</code> 标准输入的是一张表，该表的格式与 <code>VBoxManage</code> 创建的VMDK描述文件中的表格式相同， 即我们同样能通过 <code>dmsetup create qemu --table <i>table_file</i></code> 加载VMDK描述文件中的表。 对于虚拟机来说， 仅 <code>/dev/hda<i>N</i></code> 能被访问， 而对其余部分， 除了第一个扇区外，对其他扇区的读操作都只会返回0， 写操作都会被丢弃。 可以用  <code>dmsetup table qemu</code> 显示 <code>/dev/mapper/qemu</code> 的表（用 <code>udevadm info -rq name /sys/dev/block/<i>major</i>:<i>minor</i></code> 将 <code><i>major</i>:<i>minor</i></code> 转化为类似 <code>/dev/<i>blockdevice</i></code> 的名字）。若要删除创建的设备，请使用 <code>dmsetup remove qemu</code> 和 <code>losetup -d $loop</code>。 
</p>
<p>设备映射器方法一个可能的应用场景与Windows XP有关，比如说要在Windows XP安装中进行多引导配置，并且有可能要采用混合分区方案（从物理硬件上说，Windows XP可能是唯一使用MBR分区表的系统，更现代化的操作系统能使用GUID分区表）。Windows XP支持硬件配置文件，因此同样的安装可以选择不同的硬件配置完成（在本例中是裸机与虚拟机），而Windows仅需为每个配置文件安装一次新检测到的硬件的驱动即可。注意在这个例子里， 要更新MBR副本中bootloader代码的部分，使得它直接从 <code>/dev/hda<i>N</i></code> 加载Windows XP而不是系统内自带的多引导bootloader（比如GRUB）。或者，将包含bootloader安装的启动分区之副本包含于虚拟磁盘中，同样也可起到类似MBR的作用。
</p>
<h5>
<span id=".E7.BA.BF.E6.80.A7_RAID"></span><span class="mw-headline" id="线性_RAID">线性 RAID</span>
</h5>
<p>你同样能用 线性模式（需要 <code>linear.ko</code> 内核驱动）的<a href="../en/RAID.html" title="RAID">RAID</a>以及一块loop设备完成这件事。 
</p>
<p>首先创建一个用于容纳MBR的小文件：
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=32
</pre>
<p>这样就创建了一个 16 KB（32 * 512字节）的小文件。该文件最好不要太小（尽管MBR只需要一个512字节大小的块），过小的话将会限制软RAID设备的chunk大小，对于性能是有影响的。将loop设备设置到MBR文件上。
</p>
<pre># losetup -f <i>/path/to/mbr</i>
</pre>
<p>因为我们尚无法使用其他loop设备， 因此就先假设产生的设备名为 <code>/dev/loop0</code>。下一步将创建合并式MBR + 使用软件RAID的磁盘镜像 <code>/dev/hda<i>N</i></code> ：
</p>
<pre># modprobe linear
# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hda<i>N</i>
</pre>
<p>这一步产生的 <code>/dev/md0</code> 设备将在之后作为一个QEMU原始镜像（别忘了给模拟器相应的访问权限）。最后一步（也是比较取巧的一步）是设置磁盘配置，使得MBR内主分区的起始地址与 <code>/dev/md0</code> 中某一块 <code>/dev/hda<i>N</i></code> 的起始地址（在这个例子中是 16 * 512 = 16384字节的偏移处）。请在宿主机上用 <code>fdisk</code> 完成该操作，别在虚拟机里面这么做，因为默认的QEMU内的磁盘检测程序常给出无法进行千位舍入的偏移量（比如31.5 KB），软件RAID无法处理这样的情况。因此请在主机上进行下面的操作：
</p>
<pre># fdisk /dev/md0
</pre>
<p>按下 <code>X</code> 进入专家选单， 设置每个磁道上 's'ectors 的数目，使得一个柱面的大小与MBR文件中相符。对于双磁头柱面，且每个扇区为512字节的情况， 每个磁道上的扇区数当为16， 因此我们通过计算 2x16x512=16k 得到柱面的大小。
</p>
<p>按下 <code>R</code> 返回主界面。
</p>
<p><br>
按下 <code>P</code> 并检查柱面大小为16K。
</p>
<p>现在，来创建与 <code>/dev/hda<i>N</i></code> 对应的主分区。 设置它的起始地址为柱面2， 结束地址在磁盘的末端（注意现在的柱面编号已经与进入fdisk时的编号不同了）。
</p>
<p>最后，把结果写入：完成～ 现在你拥有了一块可以直接从宿主机进行挂载的分区，该分区同样也是QEMU磁盘镜像的一部分。
</p>
<pre>$ qemu-system-x86_64 -hdc /dev/md0 <i>[...]</i>
</pre>
<p>现在，若原始的 <code>/dev/hda<i>N</i></code> 分区中包含必要的一些工具，你就可以安全地用QEMU在磁盘镜像上设置任何一个bootloader。
</p>
<h5>
<span id=".E7.BD.91.E7.BB.9C.E5.9D.97.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="网络块设备">网络块设备</span>
</h5>
<p>除了上面描述的各种方法外，你也可以用 <code>nbd-server</code> （在 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=nbd">nbd</a></span> 包中）为QEMU创建一个MBR封装器。
</p>
<p>假设你已经用上面所说的方法创建了一个方法创建了一个MBR封装文件，将其重命名为 <code>wrapper.img.0</code>。然后在同一个目录下创建一个名为 <code>wrapper.img.1</code>的符号链接，指向你选择的分区。然后，还是在这个文件夹下，创建如下的脚本：
</p>
<pre>#!/bin/sh
dir="$(realpath "$(dirname "$0")")"
cat &gt;wrapper.conf &lt;&lt;EOF
[generic]
allowlist = true
listenaddr = 127.713705
port = 10809

[wrap]
exportname = $dir/wrapper.img
multifile = true
EOF

nbd-server \
    -C wrapper.conf \
    -p wrapper.pid \
    "$@"
</pre>
<p><br>
<code>.0</code> and <code>.1</code> 这两个后缀名是关键，名字的其他其他部分都可以更改。在运行上面的脚本（有可能需要以root身份运行，保证nbd-server能够去访问该分区）后，你可以用如下命令启动QEMU：
</p>
<pre>qemu-system-x86_64 -drive file=nbd:127.713705:10809:exportname=wrap <i>[...]</i>
</pre>
<h2>
<span id=".E7.BD.91.E7.BB.9C_2"></span><span class="mw-headline" id="网络_2">网络</span>
</h2>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 本部分在翻译过程中，英文wiki产生style告警，这代表日后本节的内容将会有相应调整，暂停本节的翻译： 网络拓扑 (<a href="#Host-only_networking">#Host-only networking</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>, <a href="#Internal_networking">#Internal networking</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup> 节中以及其他节中引用的部分) 不应当根据不同的虚拟网络接口实现进行划分和描述， 例如<a href="#User-mode_networking">#User-mode networking</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>, <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>, <a href="#Networking_with_VDE2">#Networking with VDE2</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。</div>
<p>采用TAP设备和网桥的虚拟网络的性能应该会比使用用户模式网络或VDE要好，原因在于TAP设备和网桥是在内核中实现的。
</p>
<p>此外，虚拟网络的性能可以通过将网络设备直接注册到虚拟机中改善，这比默认情况下模拟e1000 NIC的性能表现要更好，参阅 <a href="#Installing_virtio_drivers">#Installing virtio drivers</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup> 获得更多相关信息。
</p>
<h3>
<span id=".E5.85.B3.E4.BA.8E.E9.93.BE.E8.B7.AF.E5.B1.82.E5.9C.B0.E5.9D.80.E7.9A.84.E9.99.90.E5.88.B6"></span><span class="mw-headline" id="关于链路层地址的限制">关于链路层地址的限制</span>
</h3>
<p>若在QEMU启动中指定了 <code>-net nic</code> 参数，QEMU将会为虚拟机注册一块虚拟网卡，其链路层地址为 <code>52:54:00:12:34:56</code> 。然而，当在多台虚拟机之间搭建桥接网络时，每台虚拟机在tap设备的虚拟机端都需要拥有一个独一无二的链路层地址 (MAC)，否则网桥会因为收到多个不同源却拥有相同MAC地址的数据包而无法正常工作。即使你为多个tap设备配置了不同的MAC地址也依旧会出现这个问题，因为当数据包通过tap设备时，tap设备并不会改写包内的链路层地址。
</p>
<p>因此请确保每个虚拟机拥有自己独一无二的网卡地址, 并且它们都以 <code>52:54:</code> 开头。 可以通过如下命令手动设置虚拟机的MAC地址, 下面的'X'可以替换成任何16进制字符:
</p>
<pre>$ qemu-system-x86_64 -net nic,macaddr=52:54:<i>XX:XX:XX:XX</i> -net vde <i>disk_image</i>
</pre>
<p>生成不同的链路层地址有很多方法:
</p>
<ul>
<li>手动为每个NIC设置独一无二的链路层地址，这么做的优点在于每次启动虚拟机时，DHCP服务器都会将相同的IP地址分配给对应的MAC地址，但是这个方法在需要大量虚拟机的情况下就不适用了。</li>
<li>在每次启动虚拟机时随机生成链路层地址，实际情况下地址冲突的概率可视为0， 不过此方法的缺点在于DHCP服务器每次都会分配一个不同的IP地址。你可以用如下的这些脚本生成随机的链路层地址，并用于 <code>macaddr</code> 参数中。</li>
</ul>
<pre>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
qemu-system-x86_64 -net nic,macaddr="$macaddr" -net vde <i>disk_image</i></pre>
<ul><li>使用这个脚本 <code>qemu-mac-hasher.py</code> 可以根据虚拟机的名字进行Hash得到一个链路层地址。 只要每台虚拟机的名字是独一无二的, 这个方法就结合了上述两种方法的优点: 每次运行脚本生成的链路层地址都是相同的, 且冲突概率在实际应用中仍可视为0.</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">qemu-mac-hasher.py</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/usr/bin/env python

import sys
import zlib

if len(sys.argv) != 2:
    print("usage: %s &lt;VM Name&gt;" % sys.argv[0])
    sys.exit(1)

crc = zlib.crc32(sys.argv[1].encode("utf-8")) &amp; 0xffffffff
crc = str(hex(crc))[2:]
print("52:54:%s%s:%s%s:%s%s:%s%s" % tuple(crc))
</pre>
<p>如果要在脚本调用这个方法，你可以参照下面的例子:
</p>
<pre>vm_name="<i>VM Name</i>"
qemu-system-x86_64 -name "$vm_name" -net nic,macaddr=$(qemu-mac-hasher.py "$vm_name") -net vde <i>disk_image</i>
</pre>
<h3>
<span id=".E7.94.A8.E6.88.B7.E6.A8.A1.E5.BC.8F"></span><span class="mw-headline" id="用户模式">用户模式</span>
</h3>
<p>默认情况下，没有任何<code>-netdev</code>参数，QEMU将使用带有内置DHCP服务器的用户模式网络。当您的虚拟机运行其DHCP客户端时，将为其分配IP地址，它们将能够通过QEMU伪装的IP来访问物理主机的网络。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 仅适用于TCP和UDP协议，因此ICMP协议（包括<code>ping</code>）将不起作用。 请勿使用<code>ping</code>测试网络连接。 要在来宾中执行ping操作，请参阅<a href="../en/Sysctl.html#Allow_unprivileged_users_to_create_IPPROTO_ICMP_sockets" title="Sysctl">Sysctl#Allow unprivileged users to create IPPROTO_ICMP sockets</a>。</div>
<p>如果主机已连接Internet，则此默认配置可以使您的虚拟机轻松访问Internet。但是如果您同时启动多个虚拟机，则虚拟机将无法在外部网络上直接看到，虚拟机也将无法相互通信。
</p>
<p>QEMU的用户模式网络可以提供更多功能，例如内置TFTP或SMB服务器，将主机端口重定向到虚拟机（例如，允许SSH连接到虚拟机）或将虚拟机连接到VLAN，以便它们可以彼此通信。 有关更多详细信息，请参见<code>-net user</code>标志上的QEMU文档。
</p>
<p>但是，用户模式网络在效用和性能上都有局限性。更高级的网络配置需要使用TAP设备或其他方法。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果主机系统使用<a href="../en/Systemd-networkd.html" title="Systemd-networkd">systemd-networkd</a>，请确保按照<a href="../en/Systemd-networkd.html#Required_services_and_setup" title="Systemd-networkd">systemd-networkd#Required services and setup</a>中的描述对<code>/etc/resolv.conf</code>文件进行符号链接，否则虚拟机系统中的DNS查找将无法进行。</div>
<h3>
<span id="Tap_.E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="Tap_网络">Tap 网络</span>
</h3>
<p><a href="https://en.wikipedia.org/wiki/TUN/TAP" class="extiw" title="wikipedia:TUN/TAP">Tap devices</a>是一个Linux内核特性，允许您创建作为真实网络接口的虚拟网络接口。发送到tap接口的包将被传递到一个用户空间程序(如QEMU)，该程序将自己绑定到该接口。
</p>
<p>QEMU可以为虚拟机使用tap网络，因此发送到tap接口的包将被发送到虚拟机，并显示为来自虚拟机中的网络接口(通常是以太网接口)。相反，虚拟机通过其网络接口发送的所有内容都将出现在tap接口上。
</p>
<p>Linux桥接驱动程序支持Tap设备，因此可以将Tap设备彼此桥接在一起，也可以连接其他主机接口，如<code>eth0</code>。如果您希望您的虚拟机能够相互通信，或者希望LAN上的其他机器能够与虚拟机通信，那么这是非常理想的方案。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 如果您将tap设备和一些主机接口桥接在一起，例如<code>eth0</code>，您的虚拟机将直接出现在外部网络上，这将使它们遭受攻击的可能。根据您的虚拟机可以访问的资源，您可能需要采取所有<a href="../en/Category:Firewalls.html" class="mw-redirect" title="Firewalls">precautions</a>来保护您的虚拟机。如果风险太大,虚拟机没有资源或您设置多个虚拟机,一个更好的解决方案可能是使用<a href="#Host-only_networking">host-only networking</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>建立NAT。在这种情况下，您只需要在主机上安装一个防火墙，而不是为每个虚拟机安装多个防火墙。</div>
<p>正如在用户模式网络部分中指出的，tap设备提供比用户模式具有更高的网络性能。如果虚拟机中的操作系统支持virtio网络驱动程序，那么网络性能也会显著提高。假设使用tap0设备，virtio驱动程序在客户端上使用，并且没有使用脚本来帮助启动/停止网络，使用下面的qemu命令：
</p>
<pre>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no
</pre>
<p>但是，如果已经使用带有virtio网络驱动程序的Tap设备，则甚至可以通过启用vhost来提高网络性能，例如：
</p>
<pre>-net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no,vhost=on
</pre>
<p>详情请参考：<a rel="nofollow" class="external free" href="http://www.linux-kvm.com/content/how-maximize-virtio-net-performance-vhost-net">http://www.linux-kvm.com/content/how-maximize-virtio-net-performance-vhost-net</a> 
</p>
<h4>
<span id=".E4.BB.85.E4.B8.BB.E6.9C.BA_.E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="仅主机_网络">仅主机 网络</span>
</h4>
<p>如果为网桥提供了IP地址，并且使能发往该网桥的流量允许，但没有实际接口（例如<code>eth0</code>）连接到网桥，则虚拟机与虚拟机间，虚拟机与主机间能够相互通信。但是，如果您没有在物理主机上设置IP掩蔽，则他们将无法与外部网络进行通信。 此配置被其他虚拟化软件（例如<a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a>）称为“仅主机网络模式”。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>如果你想设置IP掩蔽，例如虚拟机的NAT，请查看<a href="../en/Internet_sharing.html#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a>页面。</li>
<li>您也许想在网桥接口上运行一个DHCP服务器来服务虚拟网络。例如，使用<code>172.20.0.1/16</code>子网，<a href="../en/Dnsmasq.html" title="Dnsmasq">dnsmasq</a>作为DHCP服务器:</li>
</ul>
<pre># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254
</pre>
</div>
<h4>
<span id=".E5.86.85.E9.83.A8.E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="内部网络">内部网络</span>
</h4>
<p>如果您不为网桥提供IP地址并在<a href="../en/Iptables.html" title="Iptables">iptables</a>添加INPUT规则链，将所有流向网桥中的数据丢弃，则虚拟机将能够彼此通信，但无法与物理主机或外部网络通信。此配置被其他虚拟化软件（例如<a href="../en/VirtualBox.html" title="VirtualBox">VirtualBox</a>）称为“内部网络”。您将需要为虚拟机分配静态IP地址，或在其中一个虚拟机上运行DHCP服务器。
</p>
<p>在默认情况下，iptables将丢弃桥接网络中的数据包。您可能需要使用这样的iptables规则来允许桥接网络中的数据包:
</p>
<pre># iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4>
<span id=".E4.BD.BF.E7.94.A8_qemu-bridge-helper_.E6.A1.A5.E6.8E.A5.E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="使用_qemu-bridge-helper_桥接网络">使用 qemu-bridge-helper 桥接网络</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 这个方法从QEMU 1.1开始就可用了，参见http://wiki.qemu.org/Features/HelperNetworking。</div>
<p>这种方法不需要启动脚本，并且很容易适应多个tap和多个桥。它使用<code>/usr/lib/qemu/qemu-bridge-helper</code>，允许在现有桥上创建tap设备。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 参见 <a href="../en/Network_bridge.html" title="Network bridge">Network bridge</a> 获取创建网桥的信息.</div>
<p>首先，创建一个配置文件，包含QEMU使用的所有网桥的名称:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu/bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">allow <i>bridge0</i>
allow <i>bridge1</i>
...</pre>
<p>现在启动虚拟机：
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> <i>[...]</i>
</pre>
<p>在多个TAP设备的情况下，最基本的用法是要为所有NIC指定VLAN：
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> -net nic,vlan=1 -net bridge,vlan=1,br=<i>bridge1</i> <i>[...]</i>
</pre>
<h4>
<span id=".E6.89.8B.E5.B7.A5.E5.88.9B.E5.BB.BA.E7.BD.91.E6.A1.A5"></span><span class="mw-headline" id="手工创建网桥">手工创建网桥</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 自QEMU 1.1起，<a rel="nofollow" class="external text" href="http://wiki.qemu.org/Features/HelperNetworking">network bridge helper</a>可以为您设置tun/tap，而无需其他脚本。 请参阅<a href="#Bridged_networking_using_qemu-bridge-helper">#Bridged networking using qemu-bridge-helper</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。</div>
<p>下面介绍如何将虚拟机连接到主机接口，如<code>eth0</code>，这可能是最常见的配置。这种配置使虚拟机看起来直接位于外部网络，与物理主机位于同一以太网段。
</p>
<p>我们将用桥适配器替换普通的以太网适配器，然后将普通的以太网适配器绑定到它。
</p>
<ul><li>安装<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>，它提供<code>brctl</code>来操作网桥。</li></ul>
<ul><li>启用IPv4转发:</li></ul>
<pre># sysctl net.ipv4.ip_forward=1
</pre>
<p>要使更改永久生效，请将<code>/etc/sysctl.d/99-sysctl.conf</code>中的<code>net.ipv4.ip_forward = 0</code>更改为<code>net.ipv4.ip_forward = 1</code>。
</p>
<ul><li>加载<code>tun</code>模块，并将其配置为在引导时加载。详见<a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">Kernel modules</a>。</li></ul>
<ul>
<li>现在创建桥。有关详细信息，请参见<a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">Bridge with netctl</a>。请记住网桥的命名，如<code> br0</code>，或将以下脚本更改为网桥的名称。</li>
<li>创建QEMU用于打开tap适配器的脚本，该脚本具有<code>root:kvm</code> 750权限:</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifup</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifup"
echo "Bringing up $1 for bridged mode..."
sudo /usr/bin/ip link set $1 up promisc on
echo "Adding $1 to br0..."
sudo /usr/bin/brctl addif br0 $1
sleep 2
</pre>
<ul><li>创建QEMU用于在<code>/etc/qemu-ifdown</code>中关闭tap适配器的脚本，该脚本具有<code>root:kvm</code> 750权限:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifdown</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh

echo "Executing /etc/qemu-ifdown"
sudo /usr/bin/ip link set $1 down
sudo /usr/bin/brctl delif br0 $1
sudo /usr/bin/ip link delete dev $1
</pre>
<ul><li>使用<code>visudo</code>将以下内容添加到<code>sudoers</code>文件中:</li></ul>
<pre>Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
%kvm     ALL=NOPASSWD: QEMU
</pre>
<ul><li>您可以使用以下<code>run-qemu</code>脚本启动QEMU:</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">run-qemu</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/bash
USERID=$(whoami)

# Get name of newly created TAP device; see https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079
precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
sudo /usr/bin/ip tuntap add user $USERID mode tap
postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
IFACE=$(comm -13 &lt;(echo "$precreationg") &lt;(echo "$postcreation"))

# This line creates a random MAC address. The downside is the DHCP server will assign a different IP address each time
printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
# Instead, uncomment and edit this line to set a static MAC address. The benefit is that the DHCP server will assign the same IP address.
# macaddr='52:54:be:36:42:a9'

qemu-system-i386 -net nic,macaddr=$macaddr -net tap,ifname="$IFACE" $*

sudo ip link set dev $IFACE down &amp;&gt; /dev/null
sudo ip tuntap del $IFACE mode tap &amp;&gt; /dev/null
</pre>
<p>然后，要启动VM，可以这样做：
</p>
<pre>$ run-qemu -hda <i>myvm.img</i> -m 512 -vga std
</pre>
<ul><li>出于性能和安全原因，建议禁用网桥上的防火墙<a rel="nofollow" class="external autonumber" href="http://ebtables.netfilter.org/documentation/bridge-nf.html">[1]</a>：</li></ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/10-disable-firewall-on-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
</pre>
<p>运行<code>sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf</code>立即应用更改。
</p>
<p>参见<a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Networking#Creating_network_initscripts">libvirt wiki</a>和<a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=512206">Fedora bug 512206</a>。如果在引导过程中sysctl发现关于不存在文件的错误，请在引导时加载<code>bridge</code>模块。参见<a href="../en/Kernel_module.html#Automatic_module_handling" class="mw-redirect" title="Kernel modules">Kernel modules#Automatic module handling</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。
</p>
<p>或者，您可以配置<a href="../en/Iptables.html" title="Iptables">iptables</a>，通过添加类似这样的规则，允许所有流量通过桥进行转发:
</p>
<pre>-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h4>
<span id=".E7.89.A9.E7.90.86.E8.AE.BE.E5.A4.87.E5.92.8CTap.E8.AE.BE.E5.A4.87.E4.B9.8B.E9.97.B4.E9.80.9A.E8.BF.87iptables.E8.BF.9B.E8.A1.8C.E7.BD.91.E7.BB.9C.E5.85.B1.E4.BA.AB"></span><span class="mw-headline" id="物理设备和Tap设备之间通过iptables进行网络共享">物理设备和Tap设备之间通过iptables进行网络共享</span>
</h4>
<div class="noprint archwiki-template-message">
<p><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a><b>This article or section is a candidate for merging with <a href="../en/Internet_sharing.html" title="Internet sharing">Internet_sharing</a>.</b><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notes:</b> Duplication, not specific to QEMU. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:QEMU (简体中文)#</a>)</div>
</div>
<p>桥接网络能在有线接口(例如eth0)之间工作，并且很容易设置。但是，如果主机通过无线设备连接到网络，则无法进行桥接。
</p>
<p>参见 <a href="../en/Network_bridge.html#Wireless_interface_on_a_bridge" title="Network bridge">Network bridge#Wireless interface on a bridge</a>.
</p>
<p>解决这个问题的一种方法是，给tap设备设置一个静态IP，使linux自动处理它的路由，然后通过iptables规则转发tap接口和连接到网络的设备之间的通信。
</p>
<p>参见 <a href="../en/Internet_sharing.html" title="Internet sharing">Internet sharing</a>.
</p>
<p>在那里你可以找到在设备之间共享网络所需要的东西，包括tap和tun。下面将进一步介绍所需的一些主机配置。如上所述，需要为静态IP配置客户机，使用分配给tap接口的IP作为网关。需要注意的是，如果客户机上的DNS服务器在从一个连接到网络的主机设备切换到另一个时发生了更改，那么它们可能需要手动编辑。
</p>
<p>要在每次启动时允许IP转发，需要在/etc/sysctl.d中，向sysctl配置文件添加以下信息:
</p>
<pre>net.ipv4.ip_forward = 1
net.ipv6.conf.default.forwarding = 1
net.ipv6.conf.all.forwarding = 1
</pre>
<p>iptables规则如下：
</p>
<pre># Forwarding from/to outside
iptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT
iptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT
iptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT
iptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT
# NAT/Masquerade (network address translation)
iptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE
iptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE
</pre>
<p>假设有3个设备连接到一个内部设备的网络共享流量，例如:
</p>
<pre>INT=tap0
EXT_0=eth0
EXT_1=wlan0
EXT_2=tun0
</pre>
<p>前面显示了一个转发，允许与tap设备共享有线和无线连接。
</p>
<p>所示的转发规则是无状态的，用于纯转发。可以考虑限制特定的流量，设置防火墙来保护来宾和其他人。然而，这些会降低网络性能，而简单的网桥不包括这些。
</p>
<p>好处:不管连接是有线还是无线，如果使用tun设备通过VPN连接到远程站点，假设为该连接打开的tun设备是tun0，并且应用了先前的iptables规则，那么远程连接也将与客户机共享。这避免了客户也需要打开VPN连接。同样，由于来宾网络需要是静态的，因此如果以这种方式远程连接主机，很可能需要编辑来宾网络上的DNS服务器。
</p>
<h3>
<span id=".E9.80.9A.E8.BF.87_VDE2_.E9.85.8D.E7.BD.AE.E7.BD.91.E7.BB.9C"></span><span class="mw-headline" id="通过_VDE2_配置网络">通过 VDE2 配置网络</span>
</h3>
<h4>
<span id=".E4.BD.95.E4.B8.BAVDE.3F"></span><span class="mw-headline" id="何为VDE?">何为VDE?</span>
</h4>
<p>VDE全称为Virtual Distributed Ethernet，作为<a href="../en/User-mode_Linux.html" title="User-mode Linux">uml</a>_switch的一个扩展，是一个用于管理虚拟网络的工具包
</p>
<p>其基本的思想是创建一个虚拟的开关，就如插座那样，允许虚拟机和物理机通过"插入"连接彼此。下面的配置非常简单，然而，VDE的功能远比展示的更强大，其能够接入虚拟开关，在不同的主机上运行它们并监听开关上的通信。恳请您阅读<a rel="nofollow" class="external text" href="https://wiki.virtualsquare.org/">该项目的文档</a>获取更多信息。
</p>
<p>本方法的优点在于无需sudo特权，普通用户一般没有运行modprobe的权限。
</p>
<h4>
<span id=".E5.9F.BA.E7.A1.80.E6.93.8D.E4.BD.9C"></span><span class="mw-headline" id="基础操作">基础操作</span>
</h4>
<p>可以通过<a href="../en/Pacman.html" title="Pacman">安装</a><a href="../en/Official_repositories.html" title="Official repositories">official repositories</a>中的<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=vde2">vde2</a></span>包获得VDE支持。
</p>
<p>在此处配置中，我们使用tun/tap在主机上创建一块虚拟网卡，用如下命令加载<code>tun</code>模块(参阅<a href="../en/Kernel_module.html" class="mw-redirect" title="Kernel modules">Kernel modules</a>获取更多信息)
</p>
<pre># modprobe tun
</pre>
<p>现在来创建一个虚拟开关：
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
</pre>
<p>这条命令完成了开关创建，<code>tap0</code>创建并将其"插入"，然后允许<code>users</code>组内的用户使用之。
</p>
<p>该网卡已插入，然而还没有进行配置。需要用下面的命令进行配置：
</p>
<pre># ip addr add 192.168.100.254/24 dev tap0
</pre>
<p>现在，只需要以普通用户的身份，指定<code>-net</code>参数启动KVM即可：
</p>
<pre>$ qemu-system-i386 -net nic -net vde -hda <i>[...]</i>
</pre>
<p>接下来只需同配置物理机网络一般，对客户机网络进行配置就行。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 你可能想在tap设备上设置NAT，实现在虚拟机内访问互联网，那就参考<a href="../en/Internet_sharing.html#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a>获取更多的帮助吧</div>
<h4>
<span id=".E5.90.AF.E5.8A.A8.E8.84.9A.E6.9C.AC"></span><span class="mw-headline" id="启动脚本">启动脚本</span>
</h4>
<p>启动VDE的一个示例脚本：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/scripts/qemu-network-env</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">#!/bin/sh
# QEMU/VDE network environment preparation script

# The IP configuration for the tap device that will be used for
# the virtual machine network:

TAP_DEV=tap0
TAP_IP=192.168.100.254
TAP_MASK=24
TAP_NETWORK=192.168.100.0

# Host interface
NIC=eth0

case "$1" in
  start)
        echo -n "Starting VDE network for QEMU: "

        # If you want tun kernel module to be loaded by script uncomment here
	#modprobe tun 2&gt;/dev/null
	## Wait for the module to be loaded
 	#while ! lsmod | grep -q "^tun"; do echo "Waiting for tun device"; sleep 1; done

        # Start tap switch
        vde_switch -tap "$TAP_DEV" -daemon -mod 660 -group users

        # Bring tap interface up
        ip address add "$TAP_IP"/"$TAP_MASK" dev "$TAP_DEV"
        ip link set "$TAP_DEV" up

        # Start IP Forwarding
        echo "1" &gt; /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -s "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE
        ;;
  stop)
        echo -n "Stopping VDE network for QEMU: "
        # Delete the NAT rules
        iptables -t nat -D POSTROUTING "$TAP_NETWORK"/"$TAP_MASK" -o "$NIC" -j MASQUERADE

        # Bring tap interface down
        ip link set "$TAP_DEV" down

        # Kill VDE switch
        pgrep -f vde_switch | xargs kill -TERM
        ;;
  restart|reload)
        $0 stop
        sleep 1
        $0 start
        ;;
  *)
        echo "Usage: $0 {start|stop|restart|reload}"
        exit 1
esac
exit 0
</pre>
<p>使用上面的脚本作为systemd服务：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu-network-env.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Manage VDE Switch

[Service]
Type=oneshot
ExecStart=/etc/systemd/scripts/qemu-network-env start
ExecStop=/etc/systemd/scripts/qemu-network-env stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</pre>
<p>修改<code>qemu-network-env</code>权限至可执行
</p>
<pre># chmod u+x /etc/systemd/scripts/qemu-network-env
</pre>
<p>可以像其他服务一样，<a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Start">start</a> <code>qemu-network-env.service</code>服务。
</p>
<h4>
<span id=".E5.A4.87.E7.94.A8.E6.96.B9.E6.B3.95"></span><span class="mw-headline" id="备用方法">备用方法</span>
</h4>
<p>如果上面的方法不起作用，或者说不想折腾内核配置、TUN、dnsmasq和iptables，可以采用下面的方法，也可以获得同样的效果，
</p>
<pre># vde_switch -daemon -mod 660 -group users
# slirpvde --dhcp --daemon
</pre>
<p>然后，启动VM并连接至主机网络中：
</p>
<pre>$ qemu-system-i386 -net nic,macaddr=52:54:00:00:EE:03 -net vde <i>disk_image</i>
</pre>
<h3>
<span id="VDE2_.E7.BD.91.E6.A1.A5"></span><span class="mw-headline" id="VDE2_网桥">VDE2 网桥</span>
</h3>
<p>根据<a rel="nofollow" class="external text" href="https://selamatpagicikgu.wordpress.com/2011/06/08/quickhowto-qemu-networking-using-vde-tuntap-and-bridge/">quickhowto: qemu networking using vde, tun/tap, and bridge</a>所描述的. 任何连接到vde上的虚拟机都会暴露给外部。举个例子，每台虚拟机都能直接从ADSL路由器那收到DHCP的配置信息。
</p>
<h4>
<span id=".E5.9F.BA.E7.A1.80.E6.93.8D.E4.BD.9C_2"></span><span class="mw-headline" id="基础操作_2">基础操作</span>
</h4>
<p>要记得，你需要有<code>tun</code>模块并安装了<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>包。
</p>
<p>创建一个vde2/tap设备：
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
# ip link set tap0 up
</pre>
<p>创建一个网桥:
</p>
<pre># brctl addbr br0
</pre>
<p>添加设备:
</p>
<pre># brctl addif br0 eth0
# brctl addif br0 tap0
</pre>
<p>配置网桥接口:
</p>
<pre># dhcpcd br0
</pre>
<h4>
<span id=".E5.90.AF.E5.8A.A8.E8.84.9A.E6.9C.AC_2"></span><span class="mw-headline" id="启动脚本_2">启动脚本</span>
</h4>
<p>所有设备应该都设置好了，且只有网桥拥有IP地址。对于网桥上的物理设备(比如<code>eth0</code>)，可以通过<a href="../en/Netctl.html" title="Netctl">netctl</a>使用一个自定义的配置文件完成上面所述设置：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/netctl/ethernet-noip</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Description='A more versatile static Ethernet connection'
Interface=eth0
Connection=ethernet
IP=no
</pre>
<p>下面的systemd服务用于为<code>users</code>用户组内的成员创建和启动VDE2 tap网卡。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/vde2@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=Network Connectivity for %i
Wants=network.target
Before=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users
ExecStart=/usr/bin/ip link set dev %i up
ExecStop=/usr/bin/ip addr flush dev %i
ExecStop=/usr/bin/ip link set dev %i down

[Install]
WantedBy=multi-user.target
</pre>
<p>最后，通过<a href="../en/Bridge_with_netctl.html" title="Bridge with netctl">netctl创建网桥</a>
</p>
<h3>
<span id=".E7.AE.80.E5.8C.96.E9.85.8D.E7.BD.AE.E5.8F.82.E6.95.B0"></span><span class="mw-headline" id="简化配置参数">简化配置参数</span>
</h3>
<p>如果你经常需要以不同的网络配置选项运行QEMU，就会发现时常得输入大量的<code>-netdev</code>和<code>-device</code>选项组合，这些是大量重复性的劳动。可以用<code>-nic</code>选项将二者结合，就如下面这样，底下这些参数：
</p>
<pre>-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0
</pre>
<p>可简化为:
</p>
<pre>-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci
</pre>
<p>要注意的是缺失了网络ID，因此将会以<code>model=</code>创建这些设备。{ic|-nic}}命令的前半部分参数正是<code>-netdev</code>的参数，而后半部分参数（<code>model=</code>之后的部分）则与设备有关，原本设备所提供的参数同样可以在此使用（例如，可以指定<code>smb=</code>）。若要完全禁用网络，可以用<code>-nic none</code>。
</p>
<p>参阅 <a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/qemu-doc.html#Network-options">QEMU networking文档</a>了解更多的相关参数。
</p>
<h2>
<span id=".E5.9B.BE.E5.BD.A2"></span><span class="mw-headline" id="图形">图形</span>
</h2>
<p>QEMU 可以使用一下几个图形输出：std, cirrus, vmware, qxl, xenfs 和 vnc。
</p>
<p>使用 <code>vnc</code> 选项，你可以单独运行客户机，并且通过 VNC 连接。其他选项是使用<code>std</code>, <code>vmware</code>, <code>cirrus</code>:
</p>
<h3><span class="mw-headline" id="std">std</span></h3>
<p>使用 <code>-vga std</code> 你可以得到最高 2560 x 1600 像素的分辨率。从 QEMU 2.2 开始是默认选项。
</p>
<h3><span class="mw-headline" id="qxl">qxl</span></h3>
<p>QXL是一个支持2D的并行虚拟化图形驱动。需要在客户机中安装驱动并在启动QEMU时设置<code>-vga qxl</code>选项。你可能也会想使用<a href="#SPICE">#SPICE</a>优化QXL的图形表现。
</p>
<p>在Linux客户机中，需要加载<code>qxl</code>和<code>bochs_drm</code>这两个内核模块，以获得一个比较好的效果。
</p>
<p>QXL设备的默认VGA内存大小为16M，这样的内存大小最高支持QHD (2560x1440)的分辨率，如果想要一个更高的分辨率，请<a href="#Multi-monitor_support">增加vga_memmb</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。
</p>
<h3><span class="mw-headline" id="vmware">vmware</span></h3>
<p>尽管Bug有点多，但相比于std和cirrus它的表现会更好。对于Arch Linux客户机来说可以安装<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a></span>和<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a></span>获取VMware驱动。
</p>
<h3><span class="mw-headline" id="virtio">virtio</span></h3>
<p><code>virtio-vga</code> / <code>virtio-gpu</code> 是一个基于<a rel="nofollow" class="external text" href="https://virgil3d.github.io/">virgl</a>的3D并行虚拟化图形驱动。目前依旧处于开发中，仅支持最近的（&gt;= 4.4）的Linux客户机，且需要以<code>gallium-drivers=virgl</code>选项编译<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mesa">mesa</a></span> (&gt;=11.2)。
</p>
<p>若要在客户机上启用3D加速，那么需要用<code>-vga virtio</code>选项选择此vga，并用<code>-display sdl,gl=on</code>或<code>-display gtk,gl=on</code>在显示设备上启用opengl上下文，这两个选项分别适用于sdl输出和gtk输出。如果配置成功了，那么在客户机的kernel log里可以看到：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ dmesg | grep drm </pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[drm] pci: virtio-vga detected
[drm] virgl 3d acceleration enabled
</pre>
<h3><span class="mw-headline" id="cirrus">cirrus</span></h3>
<p>cirrus是<a rel="nofollow" class="external text" href="http://wiki.qemu.org/ChangeLog/2.2#VGA">2.2之前</a>默认的图形选项，<a rel="nofollow" class="external text" href="https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/">不应当</a>在现代操作系统中使用它。
</p>
<h3><span class="mw-headline" id="none">none</span></h3>
<p>这就像一台完全没有VGA卡的PC，无法通过<code>-vnc</code>访问它。另外，这种情况与使用<code>-nographic</code>选项不同，<code>-nographic</code>会让QEMU模拟VGA卡，只是关闭了SDL输出。
</p>
<h2><span class="mw-headline" id="SPICE">SPICE</span></h2>
<p><a rel="nofollow" class="external text" href="http://spice-space.org/">SPICE project</a>旨在为用户提供一种完全开源的方式，无缝地对虚拟机进行远程访问。
</p>
<h3><span class="mw-headline" id="Enabling_SPICE_support_on_the_host">Enabling SPICE support on the host</span></h3>
<p>下面是一个启用SPICE作为远程桌面协议的例子，并支持复制和粘贴操作：
</p>
<pre>$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>这些参数的含义如下：
</p>
<ol>
<li>
<code>-device virtio-serial-pci</code> 添加一块virtio-serial设备</li>
<li>
<code>-spice port=5930,disable-ticketing</code> 在TCP <code>5930</code>端口上进行spice channel的监听，允许客户端不经验证即可连接。</li>
</ol>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 使用<a href="https://en.wikipedia.org/wiki/Unix_socket" class="extiw" title="wikipedia:Unix socket">Unix sockets</a>而非TCP端口不会涉及宿主机系统的网络栈，也不意味着可以对数据包进行封装和解封以使用网络和其它相关的协议。这些socket仅通过硬盘上的inode进行表示，这么做是出于性能上的考虑。使用Unix sockets可以使用<code>-spice unix,addr=/tmp/vm_spice.socket,disable-ticketing</code>代替上面的参数。</div>
<ol>
<li>
<code>-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0</code> 在virtio-serial设备上为spice vdagent打开一个端口。</li>
<li>
<code>-chardev spicevmc,id=spicechannel0,name=vdagent</code> 为该端口添加一块spicevmc字符设备。<code>virtserialport</code>的<code>chardev=</code>选项需要与<code>chardev</code>的<code>id=</code>相符，在本例中是<code>spicechannel0</code>。将端口名字设置为<code>com.redhat.spice.0</code>也很重要，因为它就是vdagent在客户机上所搜索的命名空间。最后，指定<code>name=vdagent</code>选项使得spice知道该chennel的服务对象。</li>
</ol>
<h3>
<span id=".E9.80.9A.E8.BF.87_SPICE_.E5.AE.A2.E6.88.B7.E7.AB.AF.E8.BF.9E.E6.8E.A5.E5.88.B0.E5.AE.A2.E6.88.B7.E6.9C.BA"></span><span class="mw-headline" id="通过_SPICE_客户端连接到客户机">通过 SPICE 客户端连接到客户机</span>
</h3>
<p>若要连接到客户机上必须要有一个SPICE客户端。在Arch中，有如下可用的客户端：
</p>
<p><b>virt-viewer</b> — 协议开发者所推荐的SPICE客户端，其是virt-manager project的子集。
</p>
<dl><dd>
<a rel="nofollow" class="external free" href="https://virt-manager.org/">https://virt-manager.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>
</dd></dl>
<p><b>spice-gtk</b> — SPICE GTK客户端，SPICE project的一个子集，作为小部件嵌入其它应用中。
</p>
<dl><dd>
<a rel="nofollow" class="external free" href="https://www.spice-space.org/">https://www.spice-space.org/</a> || <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span>
</dd></dl>
<p>若需要能在智能手机上运行的客户端，或者其他平台的客户端，参照<a rel="nofollow" class="external text" href="http://www.spice-space.org/download.html">spice-space download</a>中的<i>Other clients</i>章节。
</p>
<h4>
<span id=".E6.89.8B.E5.8A.A8.E5.BC.80.E5.90.AFSPICE.E5.AE.A2.E6.88.B7.E7.AB.AF"></span><span class="mw-headline" id="手动开启SPICE客户端">手动开启SPICE客户端</span>
</h4>
<p>连接到一个监听在Unix socket <code>/tmp/vm_spice.socket</code>上的客户机的方法是用<code>$ remote-viewer spice+unix:///tmp/vm_spice.socket</code> or <code>$ spicy --uri="spice+unix:///tmp/vm_spice.socket"</code>命令手动运行SPICE客户端，使用的客户端取决于你的喜好。SPICE模式下的QEMU就如一个远程桌面服务器，可能使用<code>-daemonize</code>参数以daemon模式运行QEMU会更方便一点。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 可以用下面的命令，通过SSH隧道连接到客户机：<pre>$ ssh -fL 5999:localhost:5930 <i>my.domain.org</i> sleep 10; spicy -h 127.0.0.1 -p 5999</pre>。这个例子中<i>spicy</i>连接到了本地的<code>5999</code>端口，该端口通过SSH转发至<i>my.domain.org</i>上的SPICE server端口<code>5930</code>。要注意<code>-f</code>选项让ssh在后台执行了<code>sleep 10</code>命令。这种情况下，在客户端存活时ssh session保持运行，在客户端结束运行时将自动关闭ssh session。</div>
<h4>
<span id="QEMU.E8.BF.90.E8.A1.8C.E6.97.B6.E5.90.AF.E5.8A.A8SPICE"></span><span class="mw-headline" id="QEMU运行时启动SPICE">QEMU运行时启动SPICE</span>
</h4>
<p>QEMU可以自动地开启一个SPICE客户端并创建一个合适的socket。如果通过<code>-display spice-app</code>参数将显示设置为SPICE，那么将会使用系统默认的SPICE客户端作为viewer，默认的客户端取决于你的<a href="../en/XDG_MIME_Applications.html#mimeapps.list" title="XDG MIME Applications">mimeapps.list</a>文件。
</p>
<h3>
<span id=".E5.9C.A8.E5.AE.A2.E6.88.B7.E6.9C.BA.E4.B8.8A.E5.BC.80.E5.90.AFSPICE.E7.9A.84.E6.94.AF.E6.8C.81"></span><span class="mw-headline" id="在客户机上开启SPICE的支持">在客户机上开启SPICE的支持</span>
</h3>
<p>对于<b>Arch Linux客户机</b>，如要支持多屏和共享剪贴板，需要安装以下的包：
</p>
<ul>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-vdagent">spice-vdagent</a></span>: Spice的xorg客户端代理，使得用户能够在客户端和X-session之间进行复制和粘贴等。</li>
<li>
<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xf86-video-qxl">xf86-video-qxl</a></span>: Xorg X11 qxl视频驱动</li>
</ul>
<p>对于<b>其它的操作系统</b>客户机, 参照<a rel="nofollow" class="external text" href="http://www.spice-space.org/download.html">spice-space download</a>的<i>Guest</i>章节。
</p>
<h3>
<span id=".E5.BC.80.E5.90.AFSPICE.E5.8F.A3.E4.BB.A4.E9.AA.8C.E8.AF.81"></span><span class="mw-headline" id="开启SPICE口令验证">开启SPICE口令验证</span>
</h3>
<p>若要启用SPICE的口令验证，需要从<code>-spice</code>的参数中移除<code>disable-ticketing</code>，改为<code>password=<i>yourpassword</i></code>，例如：
</p>
<pre>$ qemu-system-x86_64 -vga qxl -spice port=5900,password=<i>yourpassword</i> -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>现在SPICE客户端在连接SPICE服务器的时候应该就会进行口令询问了。
</p>
<h3>
<span id=".E7.94.A8TLS.E5.AF.B9.E4.B8.8ESPICE.E7.9A.84.E9.80.9A.E4.BF.A1.E8.BF.9B.E8.A1.8C.E5.8A.A0.E5.AF.86"></span><span class="mw-headline" id="用TLS对与SPICE的通信进行加密">用TLS对与SPICE的通信进行加密</span>
</h3>
<p>同样可以为客户端与SPICE服务器的通信配置TLS加密。首先，需要有一个包含如下文件的目录（文件名必须与下面保持一致）：
</p>
<ul>
<li>
<code>ca-cert.pem</code>: CA主证书。</li>
<li>
<code>server-cert.pem</code>: <code>ca-cert.pem</code>签名后的服务器证书。</li>
<li>
<code>server-key.pem</code>: 服务器的私钥。</li>
</ul>
<p><a rel="nofollow" class="external text" href="https://www.spice-space.org/spice-user-manual.html#_generating_self_signed_certificates">Spice User Manual</a>还展示了使用服务器自己生成的CA生成自签名证书的例子。
</p>
<p>这些完成后，你可以用前文描述的<code>-spice</code>的参数在QEMU启动时自动开启SPICE：<code>-spice tls-port=5901,password=<i>yourpassword</i>,x509-dir=<i>/path/to/pki_certs</i></code>，<code><i>/path/to/pki_certs</i></code>代表包含那三个文件的目录。
</p>
<p>现在可以用<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>连接到服务器了：
</p>
<pre>$ remote-viewer spice://<i>hostname</i>?tls-port=5901 --spice-ca-file=<i>/path/to/ca-cert.pem</i> --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<p>要记住的是，<code>--spice-host-subject</code>参数需要根据你的<code>server-cert.pem</code>中的子条目进行设置。此外还需要将<code>ca-cert.pem</code>复制到每个客户端上用于验证服务器证书。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 使用下面的命令，就可以获得服务器证书中的子条目格式，可用于<code>--spice-host-subject</code>参数中（以逗号进行分隔）：
<pre>$ openssl x509 -noout -subject -in server-cert.pem | cut -d' ' -f2- | sed 's/\///' | sed 's/\//,/g'</pre>
</div>
<p>等效的 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span> 命令为:
</p>
<pre>$ spicy -h <i>hostname</i> -s 5901 --spice-ca-file=ca-cert.pem --spice-host-subject="C=<i>XX</i>,L=<i>city</i>,O=<i>organization</i>,CN=<i>hostname</i>" --spice-secure-channels=all
</pre>
<h2><span class="mw-headline" id="VNC">VNC</span></h2>
<p>可以用<code>-vnc :<i>X</i></code>选项将QEMU的VGA输出重定向至VNC会话中。将<code><i>X</i></code>替换为输出目标的编号（0代表之后监听在5900，1代表监听在5901...）。
</p>
<pre>$ qemu-system-x86_64 -vnc :0
</pre>
<p>在<a href="#Starting_QEMU_virtual_machines_on_boot">#Starting QEMU virtual machines on boot</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>这一小节中同样提供了一个VNC的示例。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 默认的VNC服务器没有使用任何验证手段，用户可以从任何主机上连接到VNC。</div>
<h3>
<span id=".E5.9F.BA.E6.9C.AC.E7.9A.84.E5.8F.A3.E4.BB.A4.E9.AA.8C.E8.AF.81"></span><span class="mw-headline" id="基本的口令验证">基本的口令验证</span>
</h3>
<p>可以通过使用<code>password</code>选项很容易地设置访问口令。必须在QEMU Monitor中指定口令，仅当用户提供口令时才有可能连接到VNC。
</p>
<pre>$ qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<p>在QEMU Monitor中设置口令需使用<code>change vnc password</code>命令，然后指定一个口令。
</p>
<p>底下的命令将在启动VNC时直接为其设置口令：
</p>
<pre>$ printf "change vnc password\n%s\n" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 口令被限制在8个字符内，可以用暴力破解的方式猜到口令。因此在公网上推荐使用更细致的保护措施。</div>
<h2>
<span id=".E9.9F.B3.E9.A2.91"></span><span class="mw-headline" id="音频">音频</span>
</h2>
<h3>
<span id=".E5.AE.BF.E4.B8.BB.E6.9C.BA"></span><span class="mw-headline" id="宿主机">宿主机</span>
</h3>
<p><code>-audiodev</code>标识用于设定后端音频驱动及其相关选项。在<span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span>man页面中详细列出了可用的后端音频驱动以及可选的设置项。
</p>
<p>最简单的情况下，你需要选择一个驱动并设置一个id。
</p>
<pre>-audiodev pa,id=snd0
</pre>
<h3>
<span id=".E5.AE.A2.E6.88.B7.E6.9C.BA"></span><span class="mw-headline" id="客户机">客户机</span>
</h3>
<h4>
<span id=".E4.BD.BF.E7.94.A8.E9.9F.B3.E9.A2.91.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="使用音频设备">使用音频设备</span>
</h4>
<h5><span class="mw-headline" id="Intel_HD_Audio">Intel HD Audio</span></h5>
<p>模拟Intel HD Audio需要添加控制器和编解码器设备。可以用如下命令列出可用的Intel HDA Audio设备：
</p>
<pre>$ qemu-system-x86_64 -device help | grep hda
</pre>
<p>添加音频控制器：
</p>
<pre>-device ich9-intel-hda
</pre>
<p>添加音频编解码器并将其映射到宿主机的音频后端id上。
</p>
<pre>-device hda-output,audiodev=snd0
</pre>
<h5><span class="mw-headline" id="Intel_82801AA_AC97">Intel 82801AA AC97</span></h5>
<p>模拟AC97需要添加声卡设备并将其映射到宿主机的一个音频后端id上。
</p>
<pre>-device AC97,audiodev=snd0
</pre>
<h4>
<span id=".E6.97.A0.E9.9F.B3.E9.A2.91.E8.AE.BE.E5.A4.87"></span><span class="mw-headline" id="无音频设备">无音频设备</span>
</h4>
<p>通过如下命令获取支持模拟的音频驱动列表：
</p>
<pre>$ qemu-system-x86_64 -soundhw help
</pre>
<p>比如，要在客户机上模拟<code>hda</code>驱动，需要使用<code>-device intel-hda -device hda-duplex</code>选项启动QEMU。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 客户机的显卡模拟驱动可能也会导致客户机中的音频质量出现问题，需要一个个进行排查。使用<code>qemu-system-x86_64 -h | grep vga</code>列出可用的选项</div>
<h2>
<span id=".E5.AE.89.E8.A3.85_virtio_.E9.A9.B1.E5.8A.A8"></span><span class="mw-headline" id="安装_virtio_驱动">安装 virtio 驱动</span>
</h2>
<p>QEMU为用户提供并行虚拟化块设备和网络设备的能力，其是借助<a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Virtio">virtio</a>驱动实现的，拥有更好的性能表现以及更低的开销。
</p>
<ul><li>virtio块设备需要使用<code>-drive</code>指定一个disk image的参数，且需要带上<code>if=virtio</code>参数：</li></ul>
<pre>$ qemu-system-x86_64 -boot order=c -drive file=<i>disk_image</i>,if=virtio
</pre>
<ul><li>网络配置也是类似的：</li></ul>
<pre>$ qemu-system-x86_64 -nic user,model=virtio-net-pci
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 仅有当客户机有virtio设备对应的驱动时该方法才能起效，Linux是有这方面支持的，而在Arch Linux中已经包含所需的驱动了，不过无法保证这些驱动能够兼容其他操作系统。</div>
<h3>
<span id=".28Arch.29_Linux_.E5.AE.A2.E6.88.B7.E6.9C.BA"></span><span class="mw-headline" id="(Arch)_Linux_客户机">(Arch) Linux 客户机</span>
</h3>
<p>要在Arch Linux客户机中使用virtio设备，必须在客户端加载以下模块:<code>virtio_pci</code>、<code>virtio_pci</code>、<code>virtio_blk</code>、<code>virtio_net</code>、<code>virtio_ring</code>。对于32位系统来说，不需要特定的“virtio”模块。
</p>
<p>如果希望从virtio磁盘引导，ramdisk必须包含必要的模块。默认情况下，这是由<a href="../en/Mkinitcpio.html" title="Mkinitcpio">mkinitcpio</a>的<code>autodetect</code>钩子处理的。否则要在<code>/etc/mkinitcpio.conf</code>中使用<code>MODULES</code>数组包含必要的模块并重新构建ramdisk。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/mkinitcpio.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">MODULES="virtio virtio_blk virtio_pci virtio_net"</pre>
<p>Virtio磁盘公认的前缀为<code>“v”</code>(例如:<code>“v”da</code>, <code>“v”db</code>,等等)。因此，当从virtio磁盘启动时，需要在<code>/etc/fstab</code>和<code>/boot/grub/grub.cfg</code>中进行更改。。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong>  当在<code>/etc/fstab</code>和bootloader中通过<a href="../en/Persistent_block_device_naming.html#by-uuid" class="mw-redirect" title="UUID">UUID</a>引用磁盘时，不需要执行任何操作。</div>
<p>关于使用KVM进行半虚拟化的更多信息，可以参考<a rel="nofollow" class="external text" href="http://www.linux-kvm.org/page/Boot_from_virtio_block_device">Boot_from_virtio_block_device</a>。
</p>
<p>您可以安装<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-guest-agent">qemu-guest-agent</a></span>来实现对QMP命令的支持，从而增强管理程序的管理能力。安装完成后，您需要启动<code>qemu-guest-agent.service</code>。
</p>
<h3>
<span id="Windows_.E5.AE.A2.E6.88.B7.E6.9C.BA"></span><span class="mw-headline" id="Windows_客户机">Windows 客户机</span>
</h3>
<h4>
<span id=".E5.9D.97.E8.AE.BE.E5.A4.87.E9.A9.B1.E5.8A.A8"></span><span class="mw-headline" id="块设备驱动">块设备驱动</span>
</h4>
<h5>
<span id=".E5.AE.89.E8.A3.85.E4.B8.80.E4.B8.AA.E6.96.B0.E7.9A.84Windows"></span><span class="mw-headline" id="安装一个新的Windows">安装一个新的Windows</span>
</h5>
<p>Windows没有自带virtio驱动，因此需要在安装时加载该驱动。通常有两种方法：通过Floppy Disk或通过ISO文件加载。这两种镜像文件都可以从<a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">Fedora 仓库</a>下载。
</p>
<p>通过floppy加载的方法可能比较困难，因为你需要在QEMU一启动的时候就按下F6（Windows主机上需要按下Shift-F6），但是由于我们是通过VNC console连接到Windows的，这个过程会消耗一些时间，导致我们难以办到这一点。不过你可以试试在boot序列中加入delay延迟，参阅<span class="plainlinks archwiki-template-man" title="$ man 1 qemu"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/qemu.1">qemu(1)</a></span>了解如何在boot中加入delay。
</p>
<p>通过ISO加载是一个比较好的方法，但该方法只对Windows Vista和Windows Server 2008及其之后的版本有效。这个方法的具体操作是在主磁盘设备和Windows安装盘外挂载一个额外的cdrom设备，将系统镜像与virtio驱动一同加载：
</p>
<pre>$ qemu-system-x86_64 ... \
-drive file=<i>windows_disk_image</i>,index=0,media=disk,if=virtio \
-drive file=<i>windows.iso</i>,index=2,media=cdrom \
-drive file=<i>virtio.iso</i>,index=3,media=cdrom \
...
</pre>
<p>在安装过程中，Windows Installer会询问你“Where do you want to install Windows?”，其会返回一个警告表示没有找到任何磁盘设备。接下来跟着如下示例中的步骤进行操作（基于Windows Server 2012 R2 with Update）：
</p>
<ul>
<li>Select the option <i>Load Drivers</i>.</li>
<li>Uncheck the box for <i>Hide drivers that aren't compatible with this computer's hardware</i>.</li>
<li>Click the browse button and open the CDROM for the virtio iso, usually named "virtio-win-XX".</li>
<li>Now browse to <code>E:\viostor\[your-os]\amd64</code>, select it, and confirm.</li>
</ul>
<p>现在应该能看到virtio磁盘出现在列表中了，等待着被选中、格式化并安装。
</p>
<h5>
<span id=".E5.B0.86.E7.8E.B0.E6.9C.89.E7.9A.84Windows_VM.E8.BD.AC.E4.B8.BA.E4.BD.BF.E7.94.A8virtio"></span><span class="mw-headline" id="将现有的Windows_VM转为使用virtio">将现有的Windows VM转为使用virtio</span>
</h5>
<p>若要将现有的Windows客户机改为从virtio磁盘中启动，前提是客户机中有virtio驱动，且该驱动在boot期间就被加载。
</p>
<p>可以在<a rel="nofollow" class="external text" href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">Fedora 仓库</a>内找到virtio磁盘驱动。
</p>
<p>现在，先创建一个新的磁盘镜像，用于搜索virtio驱动：
</p>
<pre>$ qemu-img create -f qcow2 <i>fake.qcow2</i> 1G
</pre>
<p>挂载fake磁盘（处于virtio模式下），带有驱动的CD-ROM，运行原本的Windows客户机（boot磁盘依旧是处于IDE模式中）：
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>windows_disk_image</i>,if=ide -drive file=<i>fake.qcow2</i>,if=virtio -cdrom virtio-win-0.1-185.iso
</pre>
<p>Windows会自动检测fake磁盘，并搜索适配的驱动。如果失败了，前往<i>Device Manager</i>，找到SCSI驱动器（带有感叹号图标，应处于打开状态），点击<i>Update driver</i>并选择虚拟的CD-ROM。不要定位到CD-ROM内的文件夹了，只选择CD-ROM设备就行，Windows会自动找到合适的驱动的。（已在Windows 7 SP1中完成测试）。
</p>
<p>可以让Windows从下一次起为以安全模式启动，可以用Windows上的<i>msconfig.exe</i>工具完成该配置，在安全模式中所有的驱动都会在boot期间被加载，包括我们新装的virtio驱动。只要Windows知道boot期间需要加载virtio，在未来的boot过程中Windows都会记住该设置的。
</p>
<p>将客户机配置为安全模式启动后，可以关机并重新启动它，现在可以以virtio模式挂载boot磁盘：
</p>
<pre>$ qemu-system-x86_64 -m 4G -drive file=<i>windows_disk_image</i>,if=virtio
</pre>
<p>加载virtio驱动需要以安全模式进行boot，若不需要则可以返回<i>msconfig.exe</i>禁用安全模式，并重启Windows。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果使用<code>if=virtio</code>参数时碰上了蓝屏问题，这代表virtio磁盘驱动可能没有在boot期间被安装，以安全模式重启之，然后检查你的驱动配置。</div>
<h4>
<span id=".E7.BD.91.E7.BB.9C.E9.A9.B1.E5.8A.A8"></span><span class="mw-headline" id="网络驱动">网络驱动</span>
</h4>
<p>安装virtio网络驱动程序要容易一些，只需如上所述添加<code>-net</code>参数即可。
</p>
<pre>$ qemu-system-i386 -m 4G -vga std -drive file=<i>windows_disk_image</i>,if=virtio -net nic,model=virtio -cdrom virtio-win-0.1-185.iso
</pre>
<p>Windows将检测网络适配器并尝试为其找到驱动程序。如果失败，请转到“设备管理器”，找到带有感叹号图标的网络适配器（双击打开），切换到驱动程序并单击“更新驱动程序”，然后选择虚拟CD-ROM。别忘了选中显示要递归搜索目录的复选框。
</p>
<h4>
<span id="Balloon_.E9.A9.B1.E5.8A.A8"></span><span class="mw-headline" id="Balloon_驱动">Balloon 驱动</span>
</h4>
<p>如果想要追踪客户机内存状态（比如通过<code>virsh</code>的<code>dommemstat</code>命令）或者在运行时改变客户机内存大小（尽管依然无法改变实际的内存大小，不过可以通过inflating balloon驱动限制内存的使用），那么请在客户机上安装balloon驱动吧。
</p>
<p>安装该驱动需要前往<i>Device Manager</i>，其位于<i>System devices</i>内的<i>PCI standard RAM Controller</i>中（未识别的PCI控制设备则在<i>Other devices</i>中）。选择<i>Update driver</i>，在打开的窗口中选择<i>Browse my computer...</i>，然后选择CD-ROM（记得勾上<i>Include subdirectories</i>选项），安装完成后重启，驱动就安装成功了。现在可以如气球打气一般调整内存限制（例如通过hmp命令<code>balloon <i>memory_size</i></code>，该命令会使balloon从客户机中尽可能地夺取内存，将客户机的内存大小限制至<i>memory_size</i>）。然而，现在依然无法追踪内存的状态，我们还需要正确地安装<i>Balloon</i>服务才行。以管理员身份启动命令行，前往CD-ROM中的<i>Balloon</i>目录，然后在目录下找到对应系统和架构的地方。当深入至 <i>amd64</i> (<i>x86</i>) 目录时，运行<code>blnsrv.exe -i</code>进行安装，安装之后<code>virsh</code>命令<code>dommemstat</code>就会输出命令所支持的各种数据。
</p>
<h3>
<span id="FreeBSD.E5.AE.A2.E6.88.B7.E6.9C.BA"></span><span class="mw-headline" id="FreeBSD客户机">FreeBSD客户机</span>
</h3>
<p>如果你使用的是FreeBSD 8.3之后10.0-CURRENT之间的版本， 那么无论内核中是否包含了virtio-kmod， 都需要安装<code>emulators/virtio-kmod</code>端口。安装之后请在<code>/boot/loader.conf</code>添加如下内容：
</p>
<pre>virtio_load="YES"
virtio_pci_load="YES"
virtio_blk_load="YES"
if_vtnet_load="YES"
virtio_balloon_load="YES"</pre>
<p>按照下面修改<code>/etc/fstab</code> :
</p>
<pre># sed -ibak "s/ada/vtbd/g" /etc/fstab
</pre>
<p>注意确认<code>/etc/fstab</code>内容与该命令的预期效果相同，如果出错了就通过rescue CD启动，然后将<code>/etc/fstab.bak</code>复制到<code>/etc/fstab</code>。
</p>
<h2>
<span id="QEMU_.E7.9B.91.E8.A7.86.E5.99.A8"></span><span class="mw-headline" id="QEMU_监视器">QEMU 监视器</span>
</h2>
<p>QEMU运行时会提供一个监视器console界面以方便用户同虚拟机进行交互。QEMU监视器提供了许多有趣的功能，例如获取当前虚拟机的信息，热插拔设备，创建快照等。在QEMU监视器console中运行<code>help</code>或<code>?</code>命令，或者阅读<a rel="nofollow" class="external text" href="https://qemu.weilnetz.de/doc/qemu-doc.html#pcsys_005fmonitor">official QEMU documentation</a>获得完整的命令列表。
</p>
<h3>
<span id=".E8.AE.BF.E9.97.AEQEMU.E7.9B.91.E8.A7.86.E5.99.A8Console"></span><span class="mw-headline" id="访问QEMU监视器Console">访问QEMU监视器Console</span>
</h3>
<h4>
<span id=".E5.9B.BE.E5.BD.A2.E5.8C.96.E7.95.8C.E9.9D.A2"></span><span class="mw-headline" id="图形化界面">图形化界面</span>
</h4>
<p>当使用默认的<code>std</code>图形选项时，可以通过按下<code>Ctrl+Alt+2</code>组合键或从QEMU窗口上的<i>View &gt; compatmonitor0</i>访问到QEMU监视器。若要返回到虚拟机的图形界面，那么按下<code>Ctrl+Alt+1</code>或者<i>View &gt; VGA</i>就行。
</p>
<p>然而，这种标准的访问方式不够方便，而且并不是在QEMU的所有图形化输出方式中都适用。
</p>
<h4><span class="mw-headline" id="Telnet">Telnet</span></h4>
<p>启动QEMU时带上<code>-monitor telnet:127.0.0.1:<i>port</i>,server,nowait</code>参数可以启用<a href="../en/Telnet.html" title="Telnet">telnet</a>。虚拟机启动后可以通过telnet访问到监视器：
</p>
<pre>$ telnet 127.0.0.1 <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果指定 <code>127.0.0.1</code> 作为监听地址，那么只能在运行QEMU的宿主机上连接到该监视器。如果想要远程访问，QEMU需要在<code>0.0.0.0</code>上进行监听：<code>-monitor telnet:0.0.0.0:<i>port</i>,server,nowait</code>。还要记住的是，最好对<a href="../en/Category:Firewalls.html" class="mw-redirect" title="Firewall">firewall</a>进行配置，该连接是完全不进行认证和加密的，因此需要通过防火墙确保本地网络环境是可信的。</div>
<h4><span class="mw-headline" id="UNIX_socket">UNIX socket</span></h4>
<p>通过<code>-monitor unix:<i>socketfile</i>,server,nowait</code>参数运行QEMU，之后就可以通过<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=socat">socat</a></span>或<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span>连接到监视器上。
</p>
<p>例如，如果QEMU是通过如下命令启动：
</p>
<pre>$ qemu-system-x86_64 <i>[...]</i> -monitor unix:/tmp/monitor.sock,server,nowait <i>[...]</i>
</pre>
<p>就可以像这样连接到监视器上：
</p>
<pre>$ socat - UNIX-CONNECT:/tmp/monitor.sock
</pre>
<p>或者通过这种方式:
</p>
<pre>$ nc -U /tmp/monitor.sock
</pre>
<h4><span class="mw-headline" id="TCP">TCP</span></h4>
<p>可以使用<code>-monitor tcp:127.0.0.1:<i>port</i>,server,nowait</code>参数将监视器暴露于TCP端口上，然后用netcat（<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openbsd-netcat">openbsd-netcat</a></span>或<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gnu-netcat">gnu-netcat</a></span>都可）进行连接：
</p>
<pre>$ nc 127.0.0.1 <i>port</i>
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 为了能够从其它设备上通过TCP socket访问到监视器，而不仅仅从运行QEMU的主机上连接，需要像前面Telnet中描述的那样，在<code>0.0.0.0</code>地址上进行监听。</div>
<h4>
<span id=".E6.A0.87.E5.87.86_I.2FO"></span><span class="mw-headline" id="标准_I/O">标准 I/O</span>
</h4>
<p>如果以<code>-monitor stdio</code>参数运行QEMU，那么其实是可以在运行QEMU的终端下访问到监视器的。
</p>
<h3>
<span id=".E5.9C.A8Monitor_conosle.E4.B8.8B.E5.90.91.E8.99.9A.E6.8B.9F.E6.9C.BA.E5.8F.91.E9.80.81.E6.8C.89.E9.94.AE.E8.A1.8C.E4.B8.BA"></span><span class="mw-headline" id="在Monitor_conosle下向虚拟机发送按键行为">在Monitor conosle下向虚拟机发送按键行为</span>
</h3>
<p>由于在某些配置下，宿主机可能会拦截一些按键组合另作他用，这导致要在虚拟机中触发一些特定按键组合变得有些困难（一个显然的例子就是<code>Ctrl+Alt+F*</code>组合，该组合用于改变当前的tty）。我们采用在monitor console下发送按键组合的方式解决该问题。只需切换到monitor console下，然后使用<code>sendkey</code>命令，即可将按键转发至虚拟机中，例如：
</p>
<pre>(qemu) sendkey ctrl-alt-f2
</pre>
<h3>
<span id=".E9.80.9A.E8.BF.87_monitor_console_.E5.88.9B.E5.BB.BA.E5.BF.AB.E7.85.A7.E5.92.8C.E7.AE.A1.E7.90.86.E5.BF.AB.E7.85.A7"></span><span class="mw-headline" id="通过_monitor_console_创建快照和管理快照">通过 monitor console 创建快照和管理快照</span>
</h3>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 该特性"只"支持<i>qcow2</i>格式的虚拟机磁盘镜像，对于<i>raw</i>是无效的。</div>
<p>有时候我们很需要将虚拟机的当前状态进行保存，或是将虚拟机重置到之前的快照状态，而且最好是随时能进行这些操作。QEMU monitor console为用户提供了必要的功能，进行快照创建，快照管理，以及快照恢复。
</p>
<ul>
<li>Use <code>savevm <i>name</i></code> 用于创建一个名为<i>name</i>的快照。</li>
<li>Use <code>loadvm <i>name</i></code> 用于将虚拟机状态恢复至快照<i>name</i>。</li>
<li>Use <code>delvm <i>name</i></code> 用于删除快照<i>name</i>。</li>
<li>Use <code>info snapshots</code> 用于查看保存的快照列表，这些快照由一个自增长的ID和标签名（用户创建快照时赋予）进行标识。</li>
</ul>
<h3>
<span id=".E4.BB.A5.E5.86.BB.E7.BB.93.E6.A8.A1.E5.BC.8F.E8.BF.90.E8.A1.8C.E8.99.9A.E6.8B.9F.E6.9C.BA"></span><span class="mw-headline" id="以冻结模式运行虚拟机">以冻结模式运行虚拟机</span>
</h3>
<p>QEMU支持以冻结态运行虚拟机（需使用<code>-snapshot</code>参数），换句话说，虚拟机关闭时，对于虚拟机的一切修改都会丢弃。当用户对磁盘镜像写入时，这些变动最终写入的位置是<code>/tmp</code>目录下的一个临时文件，QEMU关机时将会把他们丢弃。
</p>
<p>不过，即使虚拟机运行于冻结状态下，依旧可以通过monitor console将这些变化写入磁盘镜像（如果你想的话）。使用下面的命令：
</p>
<pre>(qemu) commit all
</pre>
<p>另外如果在冻结状态下创建快照，这些快照在QEMU退出时都会被丢弃，除非你显式地commit了他们。
</p>
<h3>
<span id="monitor_console.E4.B8.AD.E7.9A.84.E5.BC.80.E6.9C.BA.E5.92.8C.E6.9A.82.E5.81.9C.E5.91.BD.E4.BB.A4"></span><span class="mw-headline" id="monitor_console中的开机和暂停命令">monitor console中的开机和暂停命令</span>
</h3>
<p>在QEMU monitor console下也可以模拟对物理机的一些操作：
</p>
<ul>
<li>
<code>system_powerdown</code> 会向虚拟机发送ACPI关机信号，效果就类似物理机上按下电源按钮。</li>
<li>
<code>system_reset</code> 会重置虚拟机，类似物理机上的重置按钮。该操作可能导致数据丢失或文件系统的损坏，这是因为虚拟机并不是"干净地"重启的。</li>
<li>
<code>stop</code> 会暂停虚拟机。</li>
<li>
<code>cont</code> 使暂停的虚拟机恢复运行。</li>
</ul>
<h3>
<span id=".E8.99.9A.E6.8B.9F.E6.9C.BA.E6.88.AA.E5.B1.8F"></span><span class="mw-headline" id="虚拟机截屏">虚拟机截屏</span>
</h3>
<p>可以在monitor console下运行该命令，获取PPM格式的截屏图片：
</p>
<pre>(qemu) screendump <i>file.ppm</i>
</pre>
<h2>
<span id="QEMU_.E6.9C.BA.E5.99.A8.E5.8D.8F.E8.AE.AE"></span><span class="mw-headline" id="QEMU_机器协议">QEMU 机器协议</span>
</h2>
<p>QEMU机器协议（QMP）是一个基于JSON格式的协议，使得其他应用程序可以通过该协议控制QEMU实例。类似<a href="#QEMU_monitor">#QEMU monitor</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>，其提供了与运行中的虚拟机进行交互的能力，且能够编程进行控制。关于QMP各命令的描述可以在这个<a rel="nofollow" class="external text" href="https://raw.githubusercontent.com/coreos/qemu/master/qmp-commands.hx">qmp-commands</a>链接中找到。
</p>
<h3>
<span id=".E5.90.AF.E5.8A.A8_QMP"></span><span class="mw-headline" id="启动_QMP">启动 QMP</span>
</h3>
<p>使用QMP协议来控制虚拟机的通常做法是在启动QEMU时使用<code>-qmp</code>打开一个TCP socket。底下是一个使用TCP 4444端口的例子：
</p>
<pre>$ qemu-system-x86_64 <i>[...]</i> -qmp tcp:localhost:4444,server,nowait
</pre>
<p>而与QMP代理进行通信的一个选择是使用<a href="../en/Network_tools.html#Netcat" class="mw-redirect" title="Netcat">netcat</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">nc localhost 4444</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"QMP": {"version": {"qemu": {"micro": 0, "minor": 1, "major": 3}, "package": ""}, "capabilities": []} } </pre>
<p>在目前这个阶段，其能识别的命令仅有<code>qmp_capabilities</code>，QMP将进入了命令模式。敲下：
</p>
<pre>{"execute": "qmp_capabilities"}
</pre>
<p>现在，QMP可以接收命令了。要查看QMP接受的命令列表，使用：
</p>
<pre>{"execute": "query-commands"}
</pre>
<h3>
<span id=".E5.8D.B3.E6.97.B6.E5.B0.86.E5.AD.90.E9.95.9C.E5.83.8F.E5.90.88.E5.B9.B6.E8.87.B3.E7.88.B6.E9.95.9C.E5.83.8F.E4.B8.AD"></span><span class="mw-headline" id="即时将子镜像合并至父镜像中">即时将子镜像合并至父镜像中</span>
</h3>
<p>通过发起一个<code>block-commit</code>可以将一个正处于运行态的快照合并到其父结点上。下面的例子是其最简单的一种形式，将把子镜像提交至父镜像中：
</p>
<pre>{"execute": "block-commit", "arguments": {"device": "<i>devicename</i>"}}
</pre>
<p>QMP收到该命令后，处理程序将会寻找基镜像，把该镜像由只读转为可读写模式，然后完成commit的任务。
</p>
<p>一旦<i>block-commit</i>操作完成，将会触发一个<code>BLOCK_JOB_READY</code>事件，发出同步完成的信号。当然也可以用一种更优雅的方式完成该操作，改为使用<code>block-job-complete</code>：
</p>
<pre>{"execute": "block-job-complete", "arguments": {"device": "<i>devicename</i>"}}
</pre>
<p>在发出该命令之前，<i>commit</i>操作将会保持活动状态。
任务完成后，基镜像将会保持在可读写模式，并变为active层。另一方面，子镜像将变得不可使用，用户有责任将其清除。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 执行<code>query-block</code>命令并对输出进行解析可以获取设备列表和其对应名字。设备名在<code>device</code>字段中，例如本例中磁盘设备名就是<code>ide0-hd0</code>：<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">{"execute": "query-block"}</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">{"return": [{"io-status": "ok", "device": "<b>ide0-hd0</b>", "locked": false, "removable": false, "inserted": {"iops_rd": 0, "detect_zeroes": "off", "image": {"backing-image": {"virtual-size": 27074281472, "filename": "parent.qcow2", ... } </pre> </div>
<h3>
<span id=".E5.8D.B3.E6.97.B6.E5.88.9B.E5.BB.BA.E4.B8.80.E4.B8.AA.E6.96.B0.E7.9A.84.E5.BF.AB.E7.85.A7"></span><span class="mw-headline" id="即时创建一个新的快照">即时创建一个新的快照</span>
</h3>
<p>为运行中的镜像创建一个快照：
</p>
<pre>{"execute": "blockdev-snapshot-sync", "arguments": {"device": "<i>devicename</i>","snapshot-file": "<i>new_snapshot_name</i>.qcow2"}}
</pre>
<p>该命令将会创建一个名为<code><i>new_snapshot_name</i>.qcow2</code>的堆叠文件，该快照也将成为新的active层
</p>
<h2>
<span id=".E6.8A.80.E5.B7.A7"></span><span class="mw-headline" id="技巧">技巧</span>
</h2>
<h3>
<span id=".E6.94.B9.E5.96.84.E8.99.9A.E6.8B.9F.E6.9C.BA.E7.9A.84.E6.80.A7.E8.83.BD.E8.A1.A8.E7.8E.B0"></span><span class="mw-headline" id="改善虚拟机的性能表现">改善虚拟机的性能表现</span>
</h3>
<p>底下是一些可以改善虚拟机性能表现的技术，例如：
</p>
<ul>
<li>启用<a href="#Enabling_KVM">#Enabling KVM</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>：QEMU的启动命令加上<code>-enable-kvm</code>选项。</li>
<li>通过<code>-cpu host</code>选项让QEMU模拟宿主机上的特定CPU，如果没有该选项QEMU尝试模拟的是一个更为通用的CPU。</li>
<li>特别的，如果客户机是Windows，启用<a rel="nofollow" class="external text" href="http://blog.wikichoon.com/2014/07/enabling-hyper-v-enlightenments-with-kvm.html">Hyper-V enlightenments</a>可以改善性能：<code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>.</li>
<li>如果宿主机有多个核心，可以用<code>-smp</code>选项为客户机分配更多核心。</li>
<li>检查是否为虚拟机分配的足够的内存。默认情况下，QEMU仅仅为每台虚拟机分配128MiB的内存，可以使用<code>-m</code>选项分配更多的内存。例如，<code>-m 1024</code>代表启动一台内存为1024MiB的虚拟机。</li>
<li>如果客户机操作系统支持相关的驱动，可以使用<a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Virtio">virtio</a>创建网络设备或块设备，例如：</li>
</ul>
<pre>$ qemu-system-x86_64 -net nic,model=virtio -net tap,if=tap0,script=no -drive file=<i>disk_image</i>,media=disk,if=virtio
</pre>
<ul>
<li>使用TAP设备代替user-mode网络，参阅<a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。</li>
<li>如果客户机需要进行大量的磁盘写工作，在宿主机文件系统上设置合适的挂载选项可以优化该工作。例如，可以用<code>barrier=0</code>选项挂载一个<a href="../en/Ext4.html" title="Ext4">ext4 file system</a>。在使用这些性能强化选项之前最好阅读相关文档，因为性能上的提升通常伴随着数据完整性下降的代价。</li>
<li>如果有一块原始磁盘镜像，你可能会想要禁用cache：</li>
</ul>
<pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=virtio,<b>cache=none</b>
</pre>
<ul><li>使用原生的Linux AIO：</li></ul>
<pre>$ qemu-system-x86_64 -drive file=<i>disk_image</i>,if=virtio<b>,aio=native,cache.direct=on</b>
</pre>
<ul>
<li>如果正同时运行多台虚拟机，而它们拥有同样的操作系统，可以通过启用<a href="https://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)" class="extiw" title="wikipedia:Kernel SamePage Merging (KSM)">内核页归并</a>节省内存。参阅<a href="#Enabling_KSM">#Enabling KSM</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>。</li>
<li>在一些情况下，可以在运行时从安装了balloon驱动的客户机上回收内存，这需要QEMU启动该客户机时使用<code>-device virtio-balloon</code>选项。</li>
<li>允许使用一个ICH-9 AHCI控制器的仿真层，尽管它并不稳定。AHCI的仿真模拟支持<a href="https://en.wikipedia.org/wiki/Native_Command_Queuing" class="extiw" title="wikipedia:Native Command Queuing">NCQ</a>，因此可以同时处理多个读写请求：</li>
</ul>
<pre>$ qemu-system-x86_64 -drive id=disk,file=<i>disk_image</i>,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0
</pre>
<p>参阅 <a rel="nofollow" class="external free" href="http://www.linux-kvm.org/page/Tuning_KVM">http://www.linux-kvm.org/page/Tuning_KVM</a> 获取更多信息
</p>
<h3>
<span id=".E5.BC.80.E6.9C.BA.E6.97.B6.E5.90.AF.E5.8A.A8QEMU.E8.99.9A.E6.8B.9F.E6.9C.BA"></span><span class="mw-headline" id="开机时启动QEMU虚拟机">开机时启动QEMU虚拟机</span>
</h3>
<h4>
<span id=".E9.80.9A.E8.BF.87libvirt.E5.AE.9E.E7.8E.B0"></span><span class="mw-headline" id="通过libvirt实现">通过libvirt实现</span>
</h4>
<p>如果虚拟机是通过<a href="../en/Libvirt.html" title="Libvirt">libvirt</a>设置的，可以用<code>virsh autostart</code>将其配置为开机自启，或者通过<i>virt-manager</i>GUI中虚拟机的Boot Options，选择"Start virtual machine on host boot up"实现开机自启。
</p>
<h4>
<span id=".E9.80.9A.E8.BF.87systemd_service.E5.AE.9E.E7.8E.B0"></span><span class="mw-headline" id="通过systemd_service实现">通过systemd service实现</span>
</h4>
<p>可以用如下的systemd unit和config配置开机时启动QEMU VM。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=QEMU virtual machine

[Service]
Environment="haltcmd=kill -INT $MAINPID"
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args
ExecStop=/usr/bin/bash -c ${haltcmd}
ExecStop=/usr/bin/bash -c 'while nc localhost 7100; do sleep 1; done'

[Install]
WantedBy=multi-user.target</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 为了方便地结束任务，该service会等待至console端口被释放（这意味着VM已被关闭）。</div>
<p>接着创建per-VM配置文件，命名为<code>/etc/conf.d/qemu.d/<i>vm_name</i></code>，在其中设置好<code>args</code>和<code>haltcmd</code>变量，配置示例：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/one</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0"

haltcmd="echo 'system_powerdown' | nc localhost 7100" # or netcat/ncat</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/two</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">args="-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1"

haltcmd="ssh powermanager@vm2 sudo poweroff"</pre>
<p>对该变量的描述如下：
</p>
<ul>
<li>
<code>args</code> - 使用的QEMU命令行参数。</li>
<li>
<code>haltcmd</code> - 安全关闭虚拟机的命令，在第一个例子中，QEMU monitor是通过<code>-monitor telnet:..</code>选项暴露至telnet，因而关闭虚拟机是通过<code>nc</code>命令在monitor console中发送<code>system_powerdown</code>，完成ACPI关机的工作。在另一个例子里，使用的则是SSH。</li>
</ul>
<p>若要设置启动时运行哪个虚拟机，<a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">enable</a><code>qemu@<i>vm_name</i>.service</code>这个systemd单元
</p>
<h3>
<span id=".E9.BC.A0.E6.A0.87.E6.95.B4.E5.90.88"></span><span class="mw-headline" id="鼠标整合">鼠标整合</span>
</h3>
<p>添加<code>-usb -device usb-tablet</code>选项以避免点击客户机系统的窗口时鼠标被捕获。该选项代表QEMU能够在不捕获鼠标的情况下，向系统报告鼠标的位置，该选项启用时还会覆盖PS/2鼠标模拟功能。
命令示例：
</p>
<pre>$ qemu-system-x86_64 -hda <i>disk_image</i> -m 512 -usb -device usb-tablet
</pre>
<p>如果该命令不起作用，试试<code>-vga qxl</code>参数，并看看<a href="#Mouse_cursor_is_jittery_or_erratic">#Mouse cursor is jittery or erratic</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>的操作指导。
</p>
<h3>
<span id=".E5.AE.BF.E4.B8.BB.E6.9C.BA.E7.9A.84USB.E8.AE.BE.E5.A4.87.E4.BC.A0.E9.80.92.E8.87.B3.E8.99.9A.E6.8B.9F.E6.9C.BA"></span><span class="mw-headline" id="宿主机的USB设备传递至虚拟机">宿主机的USB设备传递至虚拟机</span>
</h3>
<p>从客户机访问连接到宿主机USB口的设备是可能的，首先需要识别设备连接的位置，可以用<code>lsusb</code>命令找到设备连接位置，例如：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ lsusb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
Bus <b>003</b> Device <b>007</b>: ID <b>0781</b>:<b>5406</b> SanDisk Corp. Cruzer Micro U3
</pre>
<p>上面以粗体显示的数字分别用于标识“ host_bus”和“ host_addr”或者“ vendor_id”和“ product_id”。
</p>
<p>基本的思想是在QEMU中<code>-device usb-ehci,id=ehci</code>或<code>-device qemu-xhci,id=xhci</code>分别对EHCI (USB 2)或XHCI (USB 3)控制器进行模拟，然后将物理设备通过<code>-device usb-host,..</code>选项进行添加。在本节中的剩余部分，<i>controller_id</i>要么是<code>ehci</code>，要么是<code>xhci</code>。
</p>
<p>接着，这里有两种方法通过qemu连接到宿主机的USB：
</p>
<ol>
<li>识别出该设备，并将其连接至任一总线以及宿主机上的地址，通用的语法如下：<pre>-device usb-host,bus=<i>controller_id</i>.0,vendorid=0x<i>vendor_id</i>,productid=0x<i>product_id</i></pre>Applied to the device used in the example above, it becomes:<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x<b>0781</b>,productid=0x<b>5406</b></pre>此外也可以在上面的选项中添加<code>...,port=<i>port_number</i></code>设置，用于指定设备添加至虚拟机控制器上的哪个物理端口。该设置在为VM添加多个设备时比很有用。另一个方案是使用QEMU 5.1.0之后出现的<code>usb-host</code> <code>hostdevice</code>属性，语法为：<pre>-device qemu-xhci,id=xhci -device usb-host,bus=xhci.0,hostdevice=/dev/bus/usb/003/007</pre>
</li>
<li>若要添加一个已连接至特定USB总线和地址的设备，语法为：<pre>-device usb-host,bus=<i>controller_id</i>.0,hostbus=<i>host_bus</i>,host_addr=<i>host_addr</i></pre>，将其中的参数修改至该总线和地址即可，拿上面的例子来说，需修改为：<pre>-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,hostbus=<b>3</b>,hostaddr=<b>7</b></pre>
</li>
</ol>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果运行QEMU时遇到了权限方面的错误，可以阅读<a href="../en/Udev.html#About_udev_rules" title="Udev">udev#About udev rules</a>获取更多信息，并了解如何为设备设定合适的权限。</div>
<h3>
<span id=".E4.BD.BF.E7.94.A8SPICE.E8.BF.9B.E8.A1.8CUSB.E9.87.8D.E5.AE.9A.E5.90.91"></span><span class="mw-headline" id="使用SPICE进行USB重定向">使用SPICE进行USB重定向</span>
</h3>
<p>使用<a href="#SPICE">#SPICE</a>时可以将USB设备从客户端重定向至虚拟机中，无需使用QEMU命令。还支持为配置USB重定向插槽数（插槽数将决定可同时重定向的最大设备数）。相比于前面那种使用<code>-usbdevice</code>进行重定向的方法，SPICE方法的优势在于可以在虚拟机启动后USB设备热插拔，移除或添加USB设备时无需停机。这个方法还允许通过网络将客户端的USB设备重定向至服务端。总之，其是在QEMU虚拟机中使用USB设备最灵活的方法。
</p>
<p>我们需要为每个所需的USB重定向插槽添加一个EHCI/UHCI控制器，以及每个插槽添加一个SPICE重定向通道。例如，将下面的选项加入到所使用的QEMU命令中，以SPICE模式启动虚拟机时将会添加三个用于重定向的USB插槽：
</p>
<pre>-device ich9-usb-ehci1,id=usb \
-device ich9-usb-ehci1,id=usb \
-device ich9-usb-uhci1,masterbus=usb.0,firstport=0,multifunction=on \
-device ich9-usb-uhci2,masterbus=usb.0,firstport=2 \
-device ich9-usb-uhci3,masterbus=usb.0,firstport=4 \
-chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 \
-chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 \
-chardev spicevmc,name=usbredir,id=usbredirchardev3 -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3</pre>
<p>参阅 <a rel="nofollow" class="external text" href="https://www.spice-space.org/usbredir.html">SPICE/usbredir</a> 获取更多信息。
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=spice-gtk">spice-gtk</a></span>中的<code>spicy</code>(<i>Input &gt; Select USB Devices for redirection</i>)和<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=virt-viewer">virt-viewer</a></span>中的<code>remote-viewer</code>(<i>File &gt; USB device selection</i>)都支持该特性。请确保你已在客户机上安装必要的SPICE Guest Tools，以使得该功能正常运作（参见<a href="#SPICE">#SPICE</a>节获得更多信息）。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 需要牢记一点，当将USB设备从客户端重定向至服务端时，在客户端所在的操作系统上都无法使用该USB了，除非停止重定向。尤其重要的是千万不要将输入设备重定向（即不要将鼠标和键盘重定向），这么做会使得你难以访问到SPICE客户端的菜单而无法撤销该操作，因为在输入设备被重定向至虚拟机后，客户端无法响应它们的操作。</div>
<h3>
<span id=".E5.BC.80.E5.90.AFKSM"></span><span class="mw-headline" id="开启KSM">开启KSM</span>
</h3>
<p>Kernel Samepage Merging (KSM) 是Linux内核的一个特性，允许应用程序向内核申请同其他申请页归并的进程进行页归并，KSM机制允许客户虚拟机之间进行页共享。当许多客户机运行相似的操作系统时，这个机制可以节省客观的内存。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 尽管KSM可能减小内存占用量，其增加了CPU负担。此外要注意的是使用该机制可能产生一些安全问题，参见<a href="https://en.wikipedia.org/wiki/Kernel_same-page_merging" class="extiw" title="wikipedia:Kernel same-page merging">Wikipedia:Kernel same-page merging</a>。</div>
<p>启用KSM:
</p>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<p>使之常驻，使用<a href="../en/Systemd.html#systemd-tmpfiles_-_temporary_files" title="Systemd">systemd的临时文件</a>
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/tmpfiles.d/ksm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">w /sys/kernel/mm/ksm/run - - - - 1
</pre>
<p>当KSM启用，而正好有准备进行归并的页，（比如，至少有两个相似的VM正在运行），那么<code>/sys/kernel/mm/ksm/pages_shared</code>应会是非零的。参阅https://www.kernel.org/doc/html/latest/admin-guide/mm/ksm.html了解更多信息。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 查看KSM性能的一种简单方法是列出此目录下的所有文件内容：<pre>$ grep . /sys/kernel/mm/ksm/*</pre>
</div>
<h3>
<span id=".E5.A4.9A.E5.B1.8F.E6.94.AF.E6.8C.81"></span><span class="mw-headline" id="多屏支持">多屏支持</span>
</h3>
<p>Linux的QXL驱动支持默认支持四头（虚拟屏幕），可以通过<code>qxl.heads=N</code>这一内核参数进行变更。
</p>
<p>QXL设备的默认VGA内存大小为16M（VRAM大小为64M），在想使用两块1920x1200显示器时（需要2 × 1920 × 4 (色深) × 1200 = 17.6 MiB VGA内存）是不够用的。用<code>-vga none -device qxl-vga,vgamem_mb=32</code>选项代替<code>-vga qxl</code>可以对该属性进行变更。如果你将vgamem_mb增大至64M以上，则还需要增大<code>vram_size_mb</code>选项的值。
</p>
<h3>
<span id=".E5.A4.8D.E5.88.B6.E5.92.8C.E7.B2.98.E8.B4.B4"></span><span class="mw-headline" id="复制和粘贴">复制和粘贴</span>
</h3>
<p>在宿主机和客户机之间共享剪贴板的方法之一是使用SPICE远程桌面协议，通过SPICE客户端访问客户机，你需要遵照<a href="#SPICE">#SPICE</a>节中描述的步骤，通过该方式运行的客户机将支持与宿主机进行复制粘贴的操作。
</p>
<h3>
<span id="Windows.E4.B8.93.E7.94.A8.E8.AF.B4.E6.98.8E"></span><span class="mw-headline" id="Windows专用说明">Windows专用说明</span>
</h3>
<p>QEMU可以运行从Windows 95至Windows 10的任何版本Windows。
</p>
<p>在QEMU中也可以运行<a href="../en/Windows_PE.html" title="Windows PE">Windows PE</a>。
</p>
<h4>
<span id=".E5.BF.AB.E9.80.9F.E5.90.AF.E5.8A.A8.E8.AE.BE.E7.BD.AE"></span><span class="mw-headline" id="快速启动设置">快速启动设置</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 改变电源设置需要一个Administrtor账户</div>
<p>根据此<a rel="nofollow" class="external text" href="https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html">论坛帖子</a>所解释的那样，对于Windows8及之后的客户机最好在Control Panel的Power Options中禁用"Turn on fast startup (recommended)"，该设置导致客户机在每次启动时卡死。
</p>
<p>为了正确应用对<code>-smp</code>选项进行的更改，可能也需要禁用快速启动。
</p>
<h4>
<span id=".E8.BF.9C.E7.A8.8B.E6.A1.8C.E9.9D.A2.E5.8D.8F.E8.AE.AE"></span><span class="mw-headline" id="远程桌面协议">远程桌面协议</span>
</h4>
<p>如果你使用一个MS Windows客户机，可能会想使用RDP连接到客户机VM。若你正使用VLAN或与客户机处于同一个网络中，先使用：
</p>
<pre>$ qemu-system-x86_64 -nographic -net user,hostfwd=tcp::5555-:3389
</pre>
<p>接着通过<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=rdesktop">rdesktop</a></span>或<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=freerdp">freerdp</a></span>连接到客户机。例如：
</p>
<pre>$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan
</pre>
<h3>
<span id=".E5.9C.A8.E7.89.A9.E7.90.86.E8.AE.BE.E5.A4.87.E4.B8.8A.E5.85.8B.E9.9A.86.E4.B8.80.E4.B8.AA.E5.B7.B2.E5.AE.89.E8.A3.85.E7.9A.84Linux.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="在物理设备上克隆一个已安装的Linux系统">在物理设备上克隆一个已安装的Linux系统</span>
</h3>
<p>安装在物理设备上的Linux系统可以克隆至QEMU VM中运行，参阅<a rel="nofollow" class="external text" href="https://coffeebirthday.wordpress.com/2018/09/14/clone-linux-system-for-qemu-virtual-machine/">Clone Linux system from hardware for QEMU virtual machine</a>
</p>
<h3>
<span id=".E4.BB.8Ex86_64.E7.8E.AF.E5.A2.83.E4.B8.ADChroot.E8.87.B3arm.2Farm64.E7.8E.AF.E5.A2.83"></span><span class="mw-headline" id="从x86_64环境中Chroot至arm/arm64环境">从x86_64环境中Chroot至arm/arm64环境</span>
</h3>
<p>有时候相比于在基于ARM架构的设备上工作，在磁盘镜像上进行工作更容易。可以通过挂载一个<i>root</i>分区的SD卡/存储设备，然后chroot到该设备实现该目的。
</p>
<p>另一个使用ARM chroot的场景是在x86_64机器上构建ARM包 - <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/armutils-git/">armutils-git</a></span><sup><small>AUR</small></sup>可以完成该工作。其中，chroot环境是通过<a rel="nofollow" class="external text" href="https://archlinuxarm.org">Arch Linux ARM</a>的一个镜像tarball文件创建的 - 参阅<a rel="nofollow" class="external autonumber" href="https://nerdstuff.org/posts/2020/2020-003_simplest_way_to_create_an_arm_chroot/">[2]</a>了解此种方法的细节描述。
</p>
<p>无论哪种方式，都应该可以从chroot运行pacman并安装更多软件包，编译大型库等。由于可执行文件是针对ARM体系结构的，因此需要<a href="../en/QEMU.html" title="QEMU">QEMU</a>转换为x86。 。
</p>
<p>在x86_64宿主机上从<a href="../en/Arch_User_Repository.html" class="mw-redirect" title="AUR">AUR</a>安装<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/binfmt-qemu-static/">binfmt-qemu-static</a></span><sup><small>AUR</small></sup>和<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-user-static/">qemu-user-static</a></span><sup><small>AUR</small></sup>。<i>binfmt-qemu-static</i> 将会负责qemu二进制文件注册至binfmt服务的部分。
</p>
<p><a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">Restart</a> <code>systemd-binfmt.service</code>
</p>
<p>需要{{AUR|qemu-user-static}执行其他架构上的程序，这个包与<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=qemu-arch-extra">qemu-arch-extra</a></span>提供的程序很相似，只是对于chroot来说必须使用"static"变种。比如：
</p>
<pre>qemu-arm-static path_to_sdcard/usr/bin/ls
qemu-aarch64-static path_to_sdcard/usr/bin/ls
</pre>
<p>这两个命令分别用于执行32位ARM和64ARM的<code>ls</code>命令。注意如果没有chroot，这些都不会生效，因为那样的话它们将会试图寻找不存在宿主机系统上的一些二进制文件。
</p>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemu-user-static/">qemu-user-static</a></span><sup><small>AUR</small></sup> 允许自动地用为ARM可执行文件添加<code>qemu-arm-static</code>或<code>qemu-aarch64-static</code>前缀。
</p>
<p>检查一下ARM可执行的支持被开启了：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ ls /proc/sys/fs/binfmt_misc</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">qemu-aarch64  qemu-arm	  qemu-cris  qemu-microblaze  qemu-mipsel  qemu-ppc64	    qemu-riscv64  qemu-sh4    qemu-sparc	qemu-sparc64  status
qemu-alpha    qemu-armeb  qemu-m68k  qemu-mips	      qemu-ppc	   qemu-ppc64abi32  qemu-s390x	  qemu-sh4eb  qemu-sparc32plus	register
</pre>
<p>每种可执行的文件都须在此处列出。
</p>
<p>如果未开启，请<a href="../en/Pacman.html#Installing_packages" class="mw-redirect" title="Reinstall">reinstall</a><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/binfmt-qemu-static/">binfmt-qemu-static</a></span><sup><small>AUR</small></sup>并<a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">restart</a><code>systemd-binfmt.service</code>。
</p>
<p>将SD卡挂载至<code>/mnt/sdcard</code>（设备名可能不同）：
</p>
<pre># mkdir -p /mnt/sdcard
# mount /dev/mmcblk0p2 /mnt/sdcard
</pre>
<p>如有需要，挂载启动分区（同样，使用合适的设备名）
</p>
<pre># mount /dev/mmcblk0p1 /mnt/sdcard/boot
</pre>
<p>最后如<a href="../en/Chroot.html#Using_chroot" class="mw-redirect" title="Change root">Change root#Using chroot</a>所描述的那样，<i>chroot</i>到SD卡的root中：
</p>
<pre># chroot /mnt/sdcard /bin/bash
</pre>
<p>此外，可以使用<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=arch-install-scripts">arch-install-scripts</a></span>提供的<i>arch-chroot</i>替代chroot，可以很容易地获取网络。
</p>
<pre># arch-chroot /mnt/sdcard /bin/bash
</pre>
<p>还可以用<i>systemd-nspawn</i>chroot到ARM环境中：
</p>
<pre># systemd-nspawn -D /mnt/sdcard -M myARMMachine --bind-ro=/etc/resolv.conf
</pre>
<p><code>--bind-ro=/etc/resolv.conf</code> 是可选的，其在chroot中提供了一个可用的网络DNS。
</p>
<h2>
<span id=".E5.A4.84.E7.90.86.E5.B8.B8.E8.A7.81.E9.97.AE.E9.A2.98"></span><span class="mw-headline" id="处理常见问题">处理常见问题</span>
</h2>
<h3>
<span id=".E9.BC.A0.E6.A0.87.E6.8C.87.E9.92.88.E6.8A.96.E5.8A.A8.E6.88.96.E8.80.85.E4.B8.8D.E7.A8.B3.E5.AE.9A"></span><span class="mw-headline" id="鼠标指针抖动或者不稳定">鼠标指针抖动或者不稳定</span>
</h3>
<p>如果QEMU中鼠标指针不受控制地跳来跳去，那么启动QEMU之前在命令进行如下设置或许能解决该问题：
</p>
<pre>$ export SDL_VIDEO_X11_DGAMOUSE=0
</pre>
<p>如果成功了，可以把这条命令加入到你的 <code>~/.bashrc</code> 文件中
</p>
<h3>
<span id=".E7.9C.8B.E4.B8.8D.E8.A7.81.E9.BC.A0.E6.A0.87.E6.8C.87.E9.92.88"></span><span class="mw-headline" id="看不见鼠标指针">看不见鼠标指针</span>
</h3>
<p>使用<code>-show-cursor</code>选项启动QEMU以显示指针。
</p>
<p>如果这么做不起作用的话，请确保你的显示设备被正确设置了。例如： <code>-vga qxl</code>。
</p>
<p>还可尝试 <a href="#Mouse_integration">#Mouse integration</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup> 中提到的 <code>-usb -device usb-tablet</code>。该选项会覆盖默认采用的PS/2鼠标仿真，将鼠标作为外设在宿主机和客户机之间同步指针位置。
</p>
<h3>
<span id=".E6.9C.89.E4.B8.A4.E4.B8.AA.E4.B8.8D.E5.90.8C.E7.9A.84.E9.BC.A0.E6.A0.87.E6.8C.87.E9.92.88"></span><span class="mw-headline" id="有两个不同的鼠标指针">有两个不同的鼠标指针</span>
</h3>
<p>遵循 <a href="#Mouse_integration">#Mouse integration</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup> 提到的方法。
</p>
<h3>
<span id=".E4.BD.BF.E7.94.A8VNC.E6.97.B6.E9.94.AE.E7.9B.98.E5.87.BA.E7.8E.B0.E9.97.AE.E9.A2.98"></span><span class="mw-headline" id="使用VNC时键盘出现问题">使用VNC时键盘出现问题</span>
</h3>
<p>使用VNC时，您可能会遇到链接中所描述的键盘问题（详细信息）<a rel="nofollow" class="external text" href="https://www.berrange.com/posts/2010/07/04/more-than-you-or-i-ever-wanted-to-know-about-virtual-keyboard-handling/">here</a>。 解决的方法是不使用QEMU的 <code>-k</code> 选项, 并使用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gtk-vnc">gtk-vnc</a></span> 的 <code>gvncviewer</code> 。另请参见在libvirt邮件列表中发布的<a rel="nofollow" class="external text" href="http://www.mail-archive.com/libvir-list@redhat.com/msg13340.html">消息</a>。
</p>
<h3>
<span id=".E9.94.AE.E7.9B.98.E5.83.8F.E5.9D.8F.E4.BA.86.E4.B8.80.E6.A0.B7.E6.88.96.E8.80.85.E6.96.B9.E5.90.91.E9.94.AE.E4.B8.8D.E8.B5.B7.E4.BD.9C.E7.94.A8"></span><span class="mw-headline" id="键盘像坏了一样或者方向键不起作用">键盘像坏了一样或者方向键不起作用</span>
</h3>
<p>如果发现某些键不起作用或按下一个按键，触发的却是其他按键，那么你可能需要指定键盘布局选项。在 <code>/usr/share/qemu/keymaps</code> 中可以找到键盘布局选项。
</p>
<pre>$ qemu-system-x86_64 -k <i>keymap</i> <i>disk_image</i>
</pre>
<h3>
<span id=".E6.97.A0.E6.B3.95.E8.AF.BB.E5.8F.96.E9.94.AE.E7.9B.98.E6.98.A0.E5.B0.84.E6.96.87.E4.BB.B6"></span><span class="mw-headline" id="无法读取键盘映射文件">无法读取键盘映射文件</span>
</h3>
<pre>qemu-system-x86_64: -display vnc=0.0.0.0:0: could not read keymap file: 'en'
</pre>
<p>这类问题产生的原因是将非法的键盘映射名作为<code>-k</code>的参数传递给qemu。例如，<code>en</code>是错误的键盘映射名称，<code>en-us</code>才是正确的。相关信息参见<code>/usr/share/qemu/keymaps</code>。
</p>
<h3>
<span id=".E5.AE.A2.E6.88.B7.E6.9C.BA.E5.9C.A8.E8.B0.83.E6.95.B4.E7.AA.97.E5.8F.A3.E5.A4.A7.E5.B0.8F.E6.97.B6.E4.B8.80.E8.B5.B7.E8.A2.AB.E6.8B.89.E4.BC.B8.E4.BA.86"></span><span class="mw-headline" id="客户机在调整窗口大小时一起被拉伸了">客户机在调整窗口大小时一起被拉伸了</span>
</h3>
<p>按下 <code>Ctrl+Alt+u</code> 可以恢复到原来的大小。
</p>
<h3>
<span id="ioctl.28KVM_CREATE_VM.29_failed:_16_Device_or_resource_busy"></span><span class="mw-headline" id="ioctl(KVM_CREATE_VM)_failed:_16_Device_or_resource_busy">ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy</span>
</h3>
<p>如果在以 <code>-enable-kvm</code> 选项启动QEMU时显示了这样一条错误信息：
</p>
<pre>ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy
failed to initialize KVM: Device or resource busy
</pre>
<p>这意味着还有另一个 <a href="../en/Category:Hypervisors.html" class="mw-redirect" title="Hypervisor">hypervisor</a> 处于运行状态， 不推荐同时运行多个hypervisor。
</p>
<h3>
<span id="libgfapi_.E7.9A.84.E9.94.99.E8.AF.AF.E4.BF.A1.E6.81.AF"></span><span class="mw-headline" id="libgfapi_的错误信息">libgfapi 的错误信息</span>
</h3>
<p>启动时若显示如下错误信息:
</p>
<pre>Failed to open module: libgfapi.so.0: cannot open shared object file: No such file or directory
</pre>
<p><a href="../zh-CN/Help:Reading.html#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85" class="mw-redirect" title="安装">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=glusterfs">glusterfs</a></span> 或者直接忽略这个错误信息， GlusterFS只是一个可选的依赖。
</p>
<h3>
<span id="LIVE-environments_.E4.B8.8A.E5.8F.91.E7.94.9F.E5.86.85.E6.A0.B8.E9.94.99.E8.AF.AF"></span><span class="mw-headline" id="LIVE-environments_上发生内核错误">LIVE-environments 上发生内核错误</span>
</h3>
<p>如果你启动一个live-environment（或者启动一个系统）， 可能会遭遇如下错误：
</p>
<pre>[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown block(0,0)
</pre>
<p>或者其他阻碍启动过程的东西（比如无法解包initramfs， 无法启动foo服务之类的）， 试试启动VM的时候用 <code>-m VALUE</code> 分配合适的RAM大小， 如果内存太小是很有可能遭遇上述的问题的。
</p>
<h3>
<span id="Windows_7_.E5.AE.A2.E6.88.B7.E6.9C.BA.E7.9A.84.E9.9F.B3.E9.A2.91.E8.B4.A8.E9.87.8F.E5.B7.AE"></span><span class="mw-headline" id="Windows_7_客户机的音频质量差">Windows 7 客户机的音频质量差</span>
</h3>
<p>为Windows7使用 <code>hda</code> 音频驱动可能造成音频质量降低， 通过QEMU的 <code>-soundhw ac97</code> 参数选择 <code>ac97</code> 作为音频驱动， 并从<a rel="nofollow" class="external text" href="https://www.realtek.com/en/component/zoo/category/pc-audio-codecs-ac-97-audio-codecs-software">Realtek AC'97 Audio Codecs</a>下载AC97驱动，然后在客户机中安装该驱动可能会解决这个问题。参见<a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=1176761#c16">Red Hat Bugzilla – Bug 1176761</a>以获取更多信息。
</p>
<h3><span class="mw-headline" id="Could_not_access_KVM_kernel_module:_Permission_denied">Could not access KVM kernel module: Permission denied</span></h3>
<p>如果遇见了如下的错误信息:
</p>
<pre>libvirtError: internal error: process exited while connecting to monitor: Could not access KVM kernel module: Permission denied failed to initialize KVM: Permission denied
</pre>
<p>这是因为 Systemd 234 为 <code>kvm</code> 组注册了一个动态ID （参见<a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/54943">FS#54943</a>）。可以编辑 <code>/etc/libvirt/qemu.conf</code> 将 <code>group = "78"</code> 改为 <code>group = "kvm"</code> 避免产生这个错误。
</p>
<h3>
<span id=".E5.90.AF.E5.8A.A8Windows_VM.E6.97.B6.E4.BA.A7.E7.94.9F_.22System_Thread_Exception_Not_Handled.22"></span><span class="mw-headline" id='启动Windows_VM时产生_"System_Thread_Exception_Not_Handled"'>启动Windows VM时产生 "System Thread Exception Not Handled"</span>
</h3>
<p>Windows 8或Windows 10 guest虚拟机在启动时可能会引发通用兼容性异常，即“System Thread Exception Not Handled”，这通常是由实体机上旧版驱动程序的异常行为引起的。在KVM机器上，通常可以通过将CPU模型设置为<code> core2duo</code>来解决此问题。
</p>
<h3>
<span id=".E6.9F.90.E4.BA.9BWindows.E6.B8.B8.E6.88.8F.2F.E7.A8.8B.E5.BA.8F.E5.AF.BC.E8.87.B4.E8.93.9D.E5.B1.8F.E5.87.BA.E7.8E.B0"></span><span class="mw-headline" id="某些Windows游戏/程序导致蓝屏出现">某些Windows游戏/程序导致蓝屏出现</span>
</h3>
<p>有时，一些能在物理机上正常运行的程序在虚拟机中会意外地崩溃。如果在运行<code> dmesg -wH</code>时发现有<code> MSR</code>相关的错误，则导致这些崩溃的原因是KVM注入了GPF（<a href="https://en.wikipedia.org/wiki/General_protection_fault" class="extiw" title="wikipedia:General protection fault">General protection fault</a>），当客户机尝试访问不受支持的寄存器（MSR， <a href="https://en.wikipedia.org/wiki/Model-specific_register" class="extiw" title="wikipedia:Model-specific register">Model-specific registers</a>）时会导致客户机上的应用程序崩溃。将<code>ignore_msrs=1</code>传给KVM模块可以使其忽略不支持的MSR， 从而解决大部分的同类问题。
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/modprobe.d/kvm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">...
options kvm ignore_msrs=1
...</pre>
<p>一些添加该选项可能会起作用的场景：
</p>
<ul>
<li>GeForce Experience 反映没有可支持的CPU。</li>
<li>星际争霸2和黑色洛城使用 <code>KMODE_EXCEPTION_NOT_HANDLED</code> 对Windows 10的蓝屏做了一些处理，蓝屏信息中将无法识别驱动。</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 虽然通常这么做是安全的，对于某些应用程序也可能不起作用，但默默忽略未知的MSR仍可能破坏VM或其他VM中的其他软件。</div>
<h3>
<span id="VM.E4.B8.AD.E7.9A.84.E5.BA.94.E7.94.A8.E7.A8.8B.E5.BA.8F.E6.9C.89.E5.BE.88.E9.AB.98.E7.9A.84.E5.BB.B6.E8.BF.9F.EF.BC.8C.E6.88.96.E6.98.AF.E9.9C.80.E8.A6.81.E7.AD.89.E5.BE.85.E5.BE.88.E9.95.BF.E7.9A.84.E6.97.B6.E9.97.B4.E6.89.8D.E4.BC.9A.E5.90.AF.E5.8A.A8"></span><span class="mw-headline" id="VM中的应用程序有很高的延迟，或是需要等待很长的时间才会启动">VM中的应用程序有很高的延迟，或是需要等待很长的时间才会启动</span>
</h3>
<p>这可能是由于VM中的可用熵不足所致。考虑通过将<a rel="nofollow" class="external text" href="https://wiki.qemu.org/Features/VirtIORNG">VirtIO RNG设备</a>添加到VM，或安装诸如<a href="../en/Haveged.html" title="Haveged">Haveged</a>之类的熵生成守护程序，来允许来宾访问主机的熵池。有趣的是，OpenSSH需要一段时间才能在熵不足的情况下开始接受连接，而其日志却不会显示原因。
</p>
<h3>
<span id=".E4.B8.AD.E6.96.AD.E6.97.B6.E9.97.B4.E8.BF.87.E9.95.BF.E4.BB.A5.E5.8F.8A.E8.BF.90.E8.A1.8C.E4.B8.8D.E6.B5.81.E7.95.85"></span><span class="mw-headline" id="中断时间过长以及运行不流畅">中断时间过长以及运行不流畅</span>
</h3>
<p>此问题表现为小停顿（断断续续），在图形密集型应用程序（例如游戏）中尤其明显。
</p>
<ul>
<li>原因之一是CPU的节能功能，该功能由<a href="../en/CPU_frequency_scaling.html" title="CPU frequency scaling">CPU frequency scaling</a>控制。请对所有处理器核心进行修改，将其更改为<code>performance</code>。</li>
<li>另一个可能的原因是PS/2输入。从PS/2切换到Virtio输入，请参阅<a href="../en/PCI_passthrough_via_OVMF.html#Passing_keyboard/mouse_via_Evdev" title="PCI passthrough via OVMF">PCI passthrough via OVMF#Passing keyboard/mouse via Evdev</a>。</li>
</ul>
<h3>
<span id="QXL.E5.AF.BC.E8.87.B4.E8.A7.86.E9.A2.91.E5.88.86.E8.BE.A8.E7.8E.87.E9.99.8D.E4.BD.8E"></span><span class="mw-headline" id="QXL导致视频分辨率降低">QXL导致视频分辨率降低</span>
</h3>
<p>QEMU 4.1.0版本带来了一个回退问题，当使用SPICE时，会将QXL视频降到低分辨率。 <a rel="nofollow" class="external autonumber" href="https://bugs.launchpad.net/qemu/+bug/1843151">[3]</a>例如，当KMS启动时，文本分辨率可能会低至4x10个字符。尝试提高GUI分辨率时，它可能会达到最低的支持分辨率。
</p>
<p>解决方法是，以这种形式创建设备：
</p>
<pre>-device qxl-vga,max_outputs=1...
</pre>
<h3>
<span id=".E5.9C.A8_VM_initramfs_.E6.97.B6.E6.8C.82.E8.B5.B7"></span><span class="mw-headline" id="在_VM_initramfs_时挂起">在 VM initramfs 时挂起</span>
</h3>
<p>Linux 5.2.11带来了KVM回退的问题。某些情况下，在加载或运行initramfs的早期引导阶段，VM可能会永久挂起。 <a rel="nofollow" class="external autonumber" href="https://www.spinics.net/lists/kvm/msg195171.html">[4]</a> Linux 5.3修复了该问题。主机会显示QEMU使用了100％CPU * 虚拟CPU数量。报告反馈的情况是主机使用了超线程，且给虚拟机分配了超过主机上 <code>nproc</code>/2 个虚拟CPU。尚不清楚究竟是什么情况触发某个线程删除了内存区域而导致此情况。解决方法是：
</p>
<ul>
<li>Upgrade to Linux 5.3.</li>
<li>Downgrade to Linux 5.2.10</li>
<li>修复之前, 不要给虚拟机分配超过 <code>nproc</code>/2 个虚拟CPU。</li>
<li>自定义Linux进行编译， 回退到commit 2ad350fb4c之前 (注意，这个操作会将一个移除内存插槽时触发的回退Bug再次引入)。</li>
</ul>
<h3>
<span id=".E4.BD.BF.E7.94.A8.E5.90.AF.E7.94.A8.E4.BA.86.E5.AE.89.E5.85.A8.E5.90.AF.E5.8A.A8.E7.9A.84OVMF.E6.97.B6.EF.BC.8CVM.E6.97.A0.E6.B3.95.E5.90.AF.E5.8A.A8"></span><span class="mw-headline" id="使用启用了安全启动的OVMF时，VM无法启动">使用启用了安全启动的OVMF时，VM无法启动</span>
</h3>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=edk2-ovmf">edk2-ovmf</a></span>中的<code> /usr/share/edk2-ovmf/x64/OVMF_CODE.secboot.fd</code>是在<a href="/index.php?title=Wikipedia%EF%BC%9ASystem_Management_Mode&amp;action=edit&amp;redlink=1" class="new" title="Wikipedia：System Management Mode (page does not exist)">SMM</a>的支持下完成构建的，如果未在VM中禁用S3支持，则VM可能根本无法启动。
</p>
<p>在QEMU命令中添加 <code>-global ICH9-LPC.disable_s3=1</code>以解决该问题。
</p>
<p>参见 <a rel="nofollow" class="external text" href="https://bugs.archlinux.org/task/59465">FS#59465</a> 以及 <a rel="nofollow" class="external free" href="https://github.com/tianocore/edk2/blob/master/OvmfPkg/README">https://github.com/tianocore/edk2/blob/master/OvmfPkg/README</a> 获取QEMU使用Secure Boot所需要的更多选项。
</p>
<h3>
<span id=".E5.AE.A2.E6.88.B7.E6.9C.BA.E4.B8.8A.E7.9A.84.E4.B8.AD.E6.96.AD.E6.B2.A1.E6.9C.89.E8.A2.AB.E8.A7.A6.E5.8F.91"></span><span class="mw-headline" id="客户机上的中断没有被触发">客户机上的中断没有被触发</span>
</h3>
<p>如果你是按照<a rel="nofollow" class="external text" href="https://wiki.osdev.org/">OSDev Wiki</a>来编写自己的操作系统，或者只是使用QEMU的<code>gdb</code>接口和<code>-s</code>标志，您需要知道的是，很多仿真器（包括QEMU）通常会实现一些CPU中断，同时还有许多硬件中断没有被实现。了解代码是否触发中断的一种方法是使用：
</p>
<pre>-d int
</pre>
<p>可以在输出中查看 interrupts/exceptions。
</p>
<p>如要查看QEMU还提供了什么客户机调试功能，使用如下命令：
</p>
<pre>qemu-system-x86_64 -d help
</pre>
<p>或者将 <code>x86_64</code> 替换为你选择的其他架构
</p>
<h2>
<span id=".E5.8F.82.E9.98.85"></span><span class="mw-headline" id="参阅">参阅</span>
</h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://qemu.org">Official QEMU website</a></li>
<li><a rel="nofollow" class="external text" href="http://www.linux-kvm.org">Official KVM website</a></li>
<li><a rel="nofollow" class="external text" href="http://qemu.weilnetz.de/qemu-doc.html">QEMU Emulator User Documentation</a></li>
<li><a href="https://en.wikibooks.org/wiki/QEMU" class="extiw" title="wikibooks:QEMU">QEMU Wikibook</a></li>
<li>
<a rel="nofollow" class="external text" href="http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu">Hardware virtualization with QEMU</a> by AlienBOB (last updated in 2008)</li>
<li>
<a rel="nofollow" class="external text" href="http://blog.falconindy.com/articles/build-a-virtual-army.html">Building a Virtual Army</a> by Falconindy</li>
<li><a rel="nofollow" class="external text" href="http://git.qemu.org/?p=qemu.git;a=tree;f=docs">Lastest docs</a></li>
<li><a rel="nofollow" class="external text" href="http://qemu.weilnetz.de/">QEMU on Windows</a></li>
<li><a href="https://en.wikipedia.org/wiki/Qemu" class="extiw" title="wikipedia:Qemu">Wikipedia</a></li>
<li><a href="https://wiki.debian.org/QEMU" class="extiw" title="debian:QEMU">Debian Wiki - QEMU</a></li>
<li><a rel="nofollow" class="external text" href="https://people.gnome.org/~markmc/qemu-networking.html">QEMU Networking on gnome.org</a></li>
<li><a rel="nofollow" class="external text" href="http://bsdwiki.reedmedia.net/wiki/networking_qemu_virtual_bsd_systems.html">Networking QEMU Virtual BSD Systems</a></li>
<li><a rel="nofollow" class="external text" href="https://www.gnu.org/software/hurd/hurd/running/qemu.html">QEMU on gnu.org</a></li>
<li><a rel="nofollow" class="external text" href="https://wiki.freebsd.org/qemu">QEMU on FreeBSD as host</a></li>
<li><a rel="nofollow" class="external text" href="https://wiki.mikejung.biz/KVM_/_Xen">KVM/QEMU Virtio Tuning and SSD VM Optimization Guide</a></li>
<li><a rel="nofollow" class="external text" href="https://doc.opensuse.org/documentation/leap/virtualization/html/book-virt/part-virt-qemu.html">Managing Virtual Machines with QEMU - openSUSE documentation</a></li>
<li><a rel="nofollow" class="external text" href="https://www.ibm.com/support/knowledgecenter/en/linuxonibm/liaat/liaatkvm.htm">KVM on IBM Knowledge Center</a></li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../zh-CN/Category:Emulation.html" title="Category:Emulation (简体中文)">Emulation (简体中文)</a></li>
<li><a href="../zh-CN/Category:Hypervisors.html" title="Category:Hypervisors (简体中文)">Hypervisors (简体中文)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Merge.html" title="Category:Pages or sections flagged with Template:Merge">Pages or sections flagged with Template:Merge</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=649101">https://wiki.archlinux.org/index.php?title=QEMU_(简体中文)&amp;oldid=649101</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 17 January 2021, at 02:51.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
