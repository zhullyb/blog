<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>OpenSSH (简体中文) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-OpenSSH_简体中文 rootpage-OpenSSH_简体中文 skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">OpenSSH (简体中文)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>相关文章</p>
<ul>
<li><a href="../zh-CN/SSH_keys.html" title="SSH keys (简体中文)">SSH keys (简体中文)</a></li>
<li><a href="../en/Pam_abl.html" title="Pam abl">Pam abl</a></li>
<li><a href="../en/Fail2ban.html" title="Fail2ban">fail2ban</a></li>
<li><a href="../en/Sshguard.html" title="Sshguard">sshguard</a></li>
<li><a href="../zh-CN/SSHFS.html" title="SSHFS (简体中文)">SSHFS (简体中文)</a></li>
<li><a href="../en/Syslog-ng.html" title="Syslog-ng">Syslog-ng</a></li>
<li><a href="../en/SFTP_chroot.html" title="SFTP chroot">SFTP chroot</a></li>
<li><a href="../en/SCP_and_SFTP.html" title="SCP and SFTP">SCP and SFTP</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>翻译状态：</strong>本文是 <a href="../en/Secure_Shell.html" title="Secure Shell">Secure Shell</a> 的<a href="../zh-CN/ArchWiki:Translation_Team.html" title="ArchWiki:Translation Team (简体中文)">翻译</a>。上次翻译日期：2018-05-04。如果英文版本有所<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Secure_Shell&amp;diff=0&amp;oldid=518925">更改</a>，则您可以帮助同步翻译。</div>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a><b>本文或本节需要<a href="../zh-CN/ArchWiki:Contributing.html#%E7%BF%BB%E8%AF%91" title="ArchWiki:Contributing (简体中文)">翻译</a>。要贡献翻译，请访问<a href="../zh-CN/ArchWiki:Translation_Team.html" class="mw-redirect" title="ArchWiki Translation Team (简体中文)">简体中文翻译团队</a>。</b><a href="../File:Tango-preferences-desktop-locale.png" class="image"><img alt="Tango-preferences-desktop-locale.png" src="../File:Tango-preferences-desktop-locale.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>附注：</b> 内容已经脱节（在 <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a> 中讨论）</div>
</div>
<p><b>Secure Shell</b> (<b>SSH</b>) 是一个允许两台电脑之间通过安全的连接进行数据交换的网络协议。加密保证了数据的保密性和完整性。SSH采用公钥加密技术来验证远程主机，以及(必要时)允许远程主机验证用户。
</p>
<p>SSH 通常用于远程访问和执行命令，但是它也支持隧道，转发任意 TCP 端口以及 X11 连接；它还能够用 SFTP 或 SCP 协议来传输文件。
</p>
<p>一个 SSH 服务器默认情况下，在 TCP 端口 22 进行监听。一个 SSH 客户端程序通常被用来建立一个远程连接到 <b>sshd</b> 守护进程。这两者都被广泛地存在于现代操作系统中，包括 Mac OS X，GNU/Linux，Solaris 和 OpenVMS 等。以专有软件、自由软件以及开源版本的形式和不同的复杂性和完整性存在。
</p>
<p>(来源：<a href="https://en.wikipedia.org/wiki/Secure_Shell" class="extiw" title="wikipedia:Secure Shell">维基百科 Secure Shell</a>)
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#OpenSSH"><span class="tocnumber">1</span> <span class="toctext">OpenSSH</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#%E5%AE%89%E8%A3%85OpenSSH"><span class="tocnumber">1.1</span> <span class="toctext">安装OpenSSH</span></a></li>
<li class="toclevel-2 tocsection-3">
<a href="#SSH_%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="tocnumber">1.2</span> <span class="toctext">SSH 客户端</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#%E9%85%8D%E7%BD%AE"><span class="tocnumber">1.2.1</span> <span class="toctext">配置</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5">
<a href="#SSH_%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="tocnumber">1.3</span> <span class="toctext">SSH 服务端</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#%E9%85%8D%E7%BD%AE_2"><span class="tocnumber">1.3.1</span> <span class="toctext">配置</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#%E7%AE%A1%E7%90%86_sshd_%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="tocnumber">1.3.2</span> <span class="toctext">管理 sshd 守护进程</span></a></li>
<li class="toclevel-3 tocsection-8">
<a href="#%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4"><span class="tocnumber">1.3.3</span> <span class="toctext">安全防护</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="#%E5%BC%BA%E5%88%B6%E5%85%AC%E9%92%A5%E9%AA%8C%E8%AF%81"><span class="tocnumber">1.3.3.1</span> <span class="toctext">强制公钥验证</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="#%E5%8F%8C%E5%9B%A0%E7%B4%A0%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%85%AC%E9%92%A5"><span class="tocnumber">1.3.3.2</span> <span class="toctext">双因素验证与公钥</span></a></li>
<li class="toclevel-4 tocsection-11">
<a href="#%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3"><span class="tocnumber">1.3.3.3</span> <span class="toctext">防止暴力破解</span></a>
<ul>
<li class="toclevel-5 tocsection-12"><a href="#%E4%BD%BF%E7%94%A8_ufw"><span class="tocnumber">1.3.3.3.1</span> <span class="toctext">使用 ufw</span></a></li>
<li class="toclevel-5 tocsection-13"><a href="#%E4%BD%BF%E7%94%A8_iptables"><span class="tocnumber">1.3.3.3.2</span> <span class="toctext">使用 iptables</span></a></li>
<li class="toclevel-5 tocsection-14"><a href="#%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="tocnumber">1.3.3.3.3</span> <span class="toctext">防止暴力破解的工具</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-15">
<a href="#%E7%A6%81%E7%94%A8%E6%88%96%E9%99%90%E5%88%B6_root_%E8%B4%A6%E6%88%B7%E7%99%BB%E5%BD%95"><span class="tocnumber">1.3.3.4</span> <span class="toctext">禁用或限制 root 账户登录</span></a>
<ul>
<li class="toclevel-5 tocsection-16"><a href="#%E7%A6%81%E7%94%A8_root_%E7%99%BB%E5%BD%95"><span class="tocnumber">1.3.3.4.1</span> <span class="toctext">禁用 root 登录</span></a></li>
<li class="toclevel-5 tocsection-17"><a href="#%E9%99%90%E5%88%B6_root_%E7%99%BB%E5%BD%95"><span class="tocnumber">1.3.3.4.2</span> <span class="toctext">限制 root 登录</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-18"><a href="#%E4%BF%9D%E6%8A%A4_authorized_keys_%E6%96%87%E4%BB%B6"><span class="tocnumber">1.3.3.5</span> <span class="toctext">保护 authorized_keys 文件</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-19">
<a href="#%E5%85%B6%E4%BB%96_SSH_%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="tocnumber">2</span> <span class="toctext">其他 SSH 客户端与服务端</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Dropbear"><span class="tocnumber">2.1</span> <span class="toctext">Dropbear</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Mosh"><span class="tocnumber">2.2</span> <span class="toctext">Mosh</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22">
<a href="#%E6%8F%90%E7%A4%BA%E4%B8%8E%E6%8A%80%E5%B7%A7"><span class="tocnumber">3</span> <span class="toctext">提示与技巧</span></a>
<ul>
<li class="toclevel-2 tocsection-23">
<a href="#%E5%8A%A0%E5%AF%86_Socks_%E9%80%9A%E9%81%93"><span class="tocnumber">3.1</span> <span class="toctext">加密 Socks 通道</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%BC%80%E5%A7%8B%E8%BF%9E%E6%8E%A5"><span class="tocnumber">3.1.1</span> <span class="toctext">第一步：开始连接</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8(%E6%88%96%E5%85%B6%E5%AE%83%E7%A8%8B%E5%BA%8F)"><span class="tocnumber">3.1.2</span> <span class="toctext">第二步：配置你的浏览器(或其它程序)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26">
<a href="#X11_%E8%BD%AC%E5%8F%91"><span class="tocnumber">3.2</span> <span class="toctext">X11 转发</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="#%E9%85%8D%E7%BD%AE_3"><span class="tocnumber">3.2.1</span> <span class="toctext">配置</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="tocnumber">3.2.2</span> <span class="toctext">使用方法</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="#%E8%BD%AC%E5%8F%91%E5%85%B6%E4%BB%96%E7%AB%AF%E5%8F%A3"><span class="tocnumber">3.3</span> <span class="toctext">转发其他端口</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#%E8%B7%B3%E6%9D%BF%E6%9C%BA"><span class="tocnumber">3.4</span> <span class="toctext">跳板机</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#%E9%80%9A%E8%BF%87%E4%B8%AD%E7%BB%A7%E5%8F%8D%E5%90%91_SSH_%E8%BF%9E%E6%8E%A5"><span class="tocnumber">3.5</span> <span class="toctext">通过中继反向 SSH 连接</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="tocnumber">3.6</span> <span class="toctext">端口复用</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#%E5%8A%A0%E9%80%9F_SSH"><span class="tocnumber">3.7</span> <span class="toctext">加速 SSH</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#%E7%94%A8_SSHFS_%E6%8C%82%E8%BD%BD%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="tocnumber">3.8</span> <span class="toctext">用 SSHFS 挂载远程文件系统</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#%E4%BF%9D%E6%8C%81%E5%9C%A8%E7%BA%BF"><span class="tocnumber">3.9</span> <span class="toctext">保持在线</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#%E5%88%A9%E7%94%A8_systemd_%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF_SSH_%E9%9A%A7%E9%81%93"><span class="tocnumber">3.10</span> <span class="toctext">利用 systemd 自动重启 SSH 隧道</span></a></li>
<li class="toclevel-2 tocsection-37">
<a href="#Autossh_-_%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF_SSH_%E4%BC%9A%E8%AF%9D%E5%92%8C%E9%9A%A7%E9%81%93%E8%BF%9E%E6%8E%A5"><span class="tocnumber">3.11</span> <span class="toctext">Autossh - 自动重启 SSH 会话和隧道连接</span></a>
<ul>
<li class="toclevel-3 tocsection-38"><a href="#%E5%88%A9%E7%94%A8_systemd_%E5%9C%A8%E5%BC%95%E5%AF%BC%E5%90%8E%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C_autossh"><span class="tocnumber">3.11.1</span> <span class="toctext">利用 systemd 在引导后自动运行 autossh</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39"><a href="#%E5%BD%93_SSH_%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%87%BA%E9%94%99%E6%97%B6%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="tocnumber">3.12</span> <span class="toctext">当 SSH 守护进程出错时的其他选择</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40">
<a href="#%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94"><span class="tocnumber">4</span> <span class="toctext">疑难解答</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95"><span class="tocnumber">4.1</span> <span class="toctext">自检清单</span></a></li>
<li class="toclevel-2 tocsection-42">
<a href="#%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5%E6%88%96%E8%80%85%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="tocnumber">4.2</span> <span class="toctext">拒绝连接或者超时问题</span></a>
<ul>
<li class="toclevel-3 tocsection-43"><a href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="tocnumber">4.2.1</span> <span class="toctext">端口转发</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="#SSH%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E5%B9%B6%E4%B8%94%E6%AD%A3%E5%9C%A8%E7%9B%91%E5%90%AC%EF%BC%9F"><span class="tocnumber">4.2.2</span> <span class="toctext">SSH服务是否开启并且正在监听？</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#%E6%98%AF%E5%90%A6%E6%98%AF%E9%98%B2%E7%81%AB%E5%A2%99%E9%98%BB%E6%AD%A2%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="tocnumber">4.2.3</span> <span class="toctext">是否是防火墙阻止了连接？</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="#%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E5%92%8C%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="tocnumber">4.2.4</span> <span class="toctext">你的电脑和目的主机之间是否连接？</span></a></li>
<li class="toclevel-3 tocsection-47">
<a href="#%E4%BD%A0%E7%9A%84_ISP_%E6%88%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B1%8F%E8%94%BD%E4%BA%86%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%EF%BC%9F"><span class="tocnumber">4.2.5</span> <span class="toctext">你的 ISP 或第三方屏蔽了默认端口？</span></a>
<ul>
<li class="toclevel-4 tocsection-48"><a href="#%E8%AF%8A%E6%96%AD"><span class="tocnumber">4.2.5.1</span> <span class="toctext">诊断</span></a></li>
<li class="toclevel-4 tocsection-49"><a href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="tocnumber">4.2.5.2</span> <span class="toctext">可能的解决方案</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-50"><a href="#%22Read_from_socket_failed:_connection_reset_by_peer%22_%E9%94%99%E8%AF%AF"><span class="tocnumber">4.2.6</span> <span class="toctext">"Read from socket failed: connection reset by peer" 错误</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-51"><a href="#%22%5Byour_shell%5D:_No_such_file_or_directory%22_/_SSH_%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98"><span class="tocnumber">4.3</span> <span class="toctext">"[your shell]: No such file or directory" / SSH 认证问题</span></a></li>
<li class="toclevel-2 tocsection-52">
<a href="#%22Terminal_unknown%22_%E6%88%96_%22Error_opening_terminal%22_%E9%94%99%E8%AF%AF"><span class="tocnumber">4.4</span> <span class="toctext">"Terminal unknown" 或  "Error opening terminal" 错误</span></a>
<ul>
<li class="toclevel-3 tocsection-53"><a href="#TERM_hack"><span class="tocnumber">4.4.1</span> <span class="toctext">TERM hack</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-54"><a href="#%22Connection_closed_by_x.x.x.x_%5Bpreauth%5D%22_%E9%94%99%E8%AF%AF"><span class="tocnumber">4.5</span> <span class="toctext">"Connection closed by x.x.x.x [preauth]" 错误</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="#id_dsa_%E8%A2%AB_OpenSSH_7.0_%E6%8B%92%E7%BB%9D"><span class="tocnumber">4.6</span> <span class="toctext">id_dsa 被 OpenSSH 7.0 拒绝</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#OpenSSH_7.0_%E7%9A%84_%22No_matching_key_exchange_method_found%22_%E9%94%99%E8%AF%AF"><span class="tocnumber">4.7</span> <span class="toctext">OpenSSH 7.0 的 "No matching key exchange method found" 错误</span></a></li>
<li class="toclevel-2 tocsection-57"><a href="#%E6%96%AD%E5%BC%80_SSH_%E8%BF%9E%E6%8E%A5%E6%97%B6_tmux/screen_%E4%BC%9A%E8%AF%9D%E8%A2%AB%E5%85%B3%E9%97%AD"><span class="tocnumber">4.8</span> <span class="toctext">断开 SSH 连接时 tmux/screen 会话被关闭</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#SSH_%E4%BC%9A%E8%AF%9D%E6%97%A0%E5%93%8D%E5%BA%94"><span class="tocnumber">4.9</span> <span class="toctext">SSH 会话无响应</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-59"><a href="#%E5%8F%82%E9%98%85"><span class="tocnumber">5</span> <span class="toctext">参阅</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="OpenSSH">OpenSSH</span></h2>
<p>OpenSSH (OpenBSD Secure Shell) 是一套使用 ssh 协议，通过计算机网络，提供加密通讯会话的计算机程序。它被创建为 SSH Communications Security 公司拥有专利的 Secure Shell 软件套装的一个开源替代。OpenSSH 是由 Theo de Raadt 领导的 OpenBSD 项目的一部分。 
</p>
<p>人们常把 OpenSSH 与相似名字的 OpenSSL 搞混，但是，这两个项目是由不同的团队出于不同的目的开发出来的。相似的名字只是由于相似的目标。
</p>
<h3>
<span id=".E5.AE.89.E8.A3.85OpenSSH"></span><span class="mw-headline" id="安装OpenSSH">安装OpenSSH</span>
</h3>
<p>从<a href="../zh-CN/Official_repositories.html" class="mw-redirect" title="官方源">官方源</a>中<a href="../zh-CN/Help:Reading.html#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85" class="mw-redirect" title="安装">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openssh">openssh</a></span>.
</p>
<p><br>
</p>
<h3>
<span id="SSH_.E5.AE.A2.E6.88.B7.E7.AB.AF"></span><span class="mw-headline" id="SSH_客户端">SSH 客户端</span>
</h3>
<p>连接SSH服务器，运行命令
</p>
<pre>$ ssh -p <i>port</i> <i>user</i>@<i>server-address</i>
</pre>
<p>如果服务器仅允许使用密钥登录，请参考 <a href="../zh-CN/SSH_keys.html" title="SSH keys (简体中文)">SSH Keys</a> 。
</p>
<h4>
<span id=".E9.85.8D.E7.BD.AE"></span><span class="mw-headline" id="配置">配置</span>
</h4>
<p>客户端可以在配置文件中存储常用选项和常用主机，下列选项都可以应用至全局或应用至特定主机。 例如：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">~/.ssh/config</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"># global options
User <i>user</i>

# host-specific options
Host myserver
    HostName <i>server-address</i>
    Port     <i>port</i></pre>
<p>进行了如上的配置后，以下命令是等效的
</p>
<pre>$ ssh -p <i>port</i> <i>user</i>@<i>server-address</i>
$ ssh myserver
</pre>
<p>查看 <span class="plainlinks archwiki-template-man" title="$ man 5 ssh_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh_config.5">ssh_config(5)</a></span> 获取更多信息。
</p>
<p>某些选项没有命令行参数，但是可以使用 <code>-o</code> 在命令行中配置指定选项的参数。
例如 <code>-oKexAlgorithms=+diffie-hellman-group1-sha1</code>.
</p>
<h3>
<span id="SSH_.E6.9C.8D.E5.8A.A1.E7.AB.AF"></span><span class="mw-headline" id="SSH_服务端">SSH 服务端</span>
</h3>
<h4>
<span id=".E9.85.8D.E7.BD.AE_2"></span><span class="mw-headline" id="配置_2">配置</span>
</h4>
<p>SSH 守护进程的配置文件是<code>/etc/ssh/ssh<b>d</b>_config</code>。
</p>
<p>只允许某些用户访问的话，加入这一行：
</p>
<pre>AllowUsers    <i>user1 user2</i>
</pre>
<p>只允许一些组访问：
</p>
<pre>AllowGroups   <i>group1 group2</i>
</pre>
<p>你也可以运行以下命令关联文件(如<code>/etc/issue</code>文件)到登录欢迎信息：
</p>
<pre> Banner /etc/issue
</pre>
<p>公钥和私钥在 <i>sshd</i> <a href="#%E7%AE%A1%E7%90%86_sshd_%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">service 文件</a> 安装的时候就自动生成在 <code>/etc/ssh</code> 里面了，四个秘钥对分别由四种算法生成： <a href="../en/SSH_keys.html#Choosing_the_authentication_key_type" title="SSH keys">dsa、rsa、ecdsa 和 ed25519</a>。要让 sshd 使用一组特定的密钥，请指定以下选项：
</p>
<pre> HostKey /etc/ssh/ssh_host_rsa_key
</pre>
<p>如果此服务器在公网中，建议运行以下命令以更改sshd服务监听端口：
</p>
<pre> Port 39901
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Tip:</strong> 
<ul>
<li>参考 <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" class="extiw" title="wikipedia:List of TCP and UDP port numbers">TCP 和 UDP 端口号列表</a> 和本地的 <code>/etc/services</code> 文件来选择一个未被常用服务占用的端口。把端口从默认的 22 改成别的可以减少由于端口扫描器尝试自动登录造成的登录日志条目，更多信息请参考 <a href="../en/Port_knocking.html" title="Port knocking">Port knocking</a>。</li>
<li>完全取消密码登录方式可以极大的增强安全性，请查看<a href="#%E5%BC%BA%E5%88%B6%E5%85%AC%E9%92%A5%E9%AA%8C%E8%AF%81">#强制公钥验证</a>。查看<a href="#%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4">#安全防护</a>了解更多增强安全性的手段。</li>
<li>OpenSSH 可以监听多个端口，只需在配置文件中加入多行<code>Port <i>port_number</i></code>即可。</li>
</ul>
</div>
<h4>
<span id=".E7.AE.A1.E7.90.86_sshd_.E5.AE.88.E6.8A.A4.E8.BF.9B.E7.A8.8B"></span><span class="mw-headline" id="管理_sshd_守护进程">管理 sshd 守护进程</span>
</h4>
<p><span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=openssh">openssh</a></span> 包括了两种 <a href="../en/Systemd.html" title="Systemd">systemd</a> 服务:
</p>
<ol>
<li>
<code>sshd.service</code>,使 SSH 守护进程始终运行，并为每个入站连接创建子进程。<a rel="nofollow" class="external autonumber" href="https://github.com/archlinux/svntogit-packages/blob/packages/openssh/trunk/sshd.service#L16">[1]</a> 适用于有大量 SSH 流量的系统。<a rel="nofollow" class="external autonumber" href="https://github.com/archlinux/svntogit-packages/blob/4cadf5dff444e4b7265f8918652f4e6dff733812/trunk/sshd.service#L15">[2]</a>
</li>
<li>
<code>sshd.socket</code> + <code>sshd@.service</code>, 为每个连接生成 SSH 守护进程的实例。它意味着让 <i>systemd</i> 监听 SSH socket，并且只有在有连接传入时启动守护进程。几乎所有情况下都推荐使用<code>sshd</code>。 <a rel="nofollow" class="external autonumber" href="https://github.com/archlinux/svntogit-packages/blob/4cadf5dff444e4b7265f8918652f4e6dff733812/trunk/sshd.service#L18">[3]</a><a rel="nofollow" class="external autonumber" href="https://lists.freedesktop.org/archives/systemd-devel/2011-January/001107.html">[4]</a><a rel="nofollow" class="external autonumber" href="http://0pointer.de/blog/projects/inetd.html">[5]</a>
</li>
</ol>
<p><a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Start">start</a> 并 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">enable</a>  <code>sshd.service</code> <b>或</b> <code>sshd.socket</code> 中的任何一个都可以启动守护进程。
</p>
<p>如果选择了 sshd.socket，并且不在默认的 22 端口监听，你需要<a href="../en/Systemd.html#Editing_provided_units" class="mw-redirect" title="Edit">编辑</a> ststemd 单元文件：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># systemctl edit sshd.socket</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Socket]
ListenStream=
ListenStream=12345
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 使用 <code>sshd.socket</code> 会使 <code>ListenAddress</code> 设置无效，这将允许来自任何地址的连接。为了达到与 <code>ListenAddress</code> 一样设置 IP 的效果， 你必须在 <code>ListenStream</code> 中指定端口<i>和</i> IP (例如：<code>ListenStream=192.168.1.100:22</code>)。你还需要在 <code>[Socket]</code> 下面增加 <code>FreeBind=true</code>，否则设置 IP 与设置 <code>ListenAddress</code> 有着相同的缺陷：如果网络未及时启动，socket 将无法启动。</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 打开 <code>sshd.service</code> 时将为每个连接启动一个 <code>sshd@.service</code> 的临时实例（实例名称不同）。因此，<code>sshd.socket</code> 和常规 <code>sshd.service</code> 都不允许监视日志中的连接尝试。使用 <code>journalctl -u "sshd@*"</code> 或 <code>journalctl /usr/bin/sshd</code> 可以看到 socket 激活的 SSH 实例的日志。</div>
<h4>
<span id=".E5.AE.89.E5.85.A8.E9.98.B2.E6.8A.A4"></span><span class="mw-headline" id="安全防护">安全防护</span>
</h4>
<p>允许通过SSH进行远程登录对管理服务器很有用，但也会对服务器构成安全威胁。SSH 通常是暴力攻击的目标，因此 SSH 访问需要适当限制，以防止第三方访问您的服务器。
</p>
<p>下列是有关该主题的优秀指南：
</p>
<ul>
<li><a rel="nofollow" class="external text" href="https://wiki.mozilla.org/Security/Guidelines/OpenSSH">Article by Mozilla Infosec Team</a></li>
<li><a rel="nofollow" class="external text" href="https://stribika.github.io/2015/01/04/secure-secure-shell.html">Secure sshd</a></li>
</ul>
<h5>
<span id=".E5.BC.BA.E5.88.B6.E5.85.AC.E9.92.A5.E9.AA.8C.E8.AF.81"></span><span class="mw-headline" id="强制公钥验证">强制公钥验证</span>
</h5>
<p>如果客户端无法通过公钥进行身份验证，则默认情况下，SSH服务器将使用密码来验证，从而允许恶意用户通过<a href="#%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3">暴力破解</a>密码获取访问权限。一种防止此类攻击的有效方法是完全禁用密码登录，并强制使用<a href="../en/SSH_keys.html" title="SSH keys">SSH keys</a>。可以在 <code>sshd_config</code> 中禁用以下选项：
</p>
<pre>PasswordAuthentication no
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 在将上述选项添加到你的配置之前，请确保所有需要 SSH 访问的帐户都在相应的 <code>authorized_keys</code> 文件中设置了公钥验证。请参阅 <a href="../en/SSH_keys.html#Copying_the_public_key_to_the_remote_server" title="SSH keys">SSH keys#Copying the public key to the remote server</a> 以获取更多信息。</div>
<h5>
<span id=".E5.8F.8C.E5.9B.A0.E7.B4.A0.E9.AA.8C.E8.AF.81.E4.B8.8E.E5.85.AC.E9.92.A5"></span><span class="mw-headline" id="双因素验证与公钥">双因素验证与公钥</span>
</h5>
<p>SSH 可以设置为采用多种方式进行身份验证，你可以使用 <code>AuthenticationMethods</code> 选项来指明在登录时需要哪些身份验证方式。这使你可以用公钥与双因素验证结合来登录。
</p>
<p>参阅 <a href="../zh-CN/Google_Authenticator.html" title="Google Authenticator (简体中文)">Google Authenticator (简体中文)</a> 来设置 Google Authenticator。
</p>
<p>为了使 <a href="../zh-CN/PAM.html" title="PAM (简体中文)">PAM (简体中文)</a> 与 OpenSSH 协同工作， 编辑下列文件：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/ssh/sshd_config</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ChallengeResponseAuthentication yes
AuthenticationMethods publickey keyboard-interactive:pam
</pre>
<p>然后，你可以使用公钥<b>或</b> PAM 中设置的用户验证信息两者之一登录。
</p>
<p>另外，如果你想登录时同时验证公钥<b>和</b> PAM，请使用逗号而不是空格来分隔 AuthenticationMethods：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/ssh/sshd_config</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">ChallengeResponseAuthentication yes
AuthenticationMethods publickey<b>,</b>keyboard-interactive:pam
</pre>
<p>通过要求提供公钥<b>和</b> PAM 认证，你可能希望禁用密码登录：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/pam.d/sshd</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">auth      required  pam_securetty.so     #disable remote root
#Require google authenticator
auth      required  pam_google_authenticator.so
#But not password
#auth      include   system-remote-login
account   include   system-remote-login
password  include   system-remote-login
session   include   system-remote-login
</pre>
<h5>
<span id=".E9.98.B2.E6.AD.A2.E6.9A.B4.E5.8A.9B.E7.A0.B4.E8.A7.A3"></span><span class="mw-headline" id="防止暴力破解">防止暴力破解</span>
</h5>
<p>暴力破解的概念很简单，即某人不断尝试用大量随机产生的用户名和密码对来登录网页或服务器的某个服务（比如 SSH）。
</p>
<h6>
<span id=".E4.BD.BF.E7.94.A8_ufw"></span><span class="mw-headline" id="使用_ufw">使用 ufw</span>
</h6>
<p>请参阅 <a href="../en/Uncomplicated_Firewall.html#Rate_limiting_with_ufw" class="mw-redirect" title="Ufw">ufw#Rate limiting with ufw</a>.
</p>
<h6>
<span id=".E4.BD.BF.E7.94.A8_iptables"></span><span class="mw-headline" id="使用_iptables">使用 iptables</span>
</h6>
<div class="noprint archwiki-template-message">
<p><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a><b>This article or section is a candidate for merging with <a href="../en/Simple_stateful_firewall.html#Bruteforce_attacks" title="Simple stateful firewall">Simple_stateful_firewall#Bruteforce_attacks</a>.</b><a href="../File:Merge-arrows-2.png" class="image"><img alt="Merge-arrows-2.png" src="../File:Merge-arrows-2.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Notes:</b> Out of scope, same technique as already described in the SSF. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<p>如果你已经在用 iptables，可以配置以下规则来保护 SSH 免受暴破。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 此示例中 SSH 所用的 TCP 端口已经改为了 42660。</div>
<p>在应用后面的规则之前，我们先新建一条规则链来记录并拒绝过多的连接请求：
</p>
<pre># iptables -N LOG_AND_DROP
</pre>
<p>第一条规则将应用于预示 TCP 42660 端口有新连接的数据包：
</p>
<pre># iptables -A INPUT -p tcp -m tcp --dport 42660 -m state --state NEW -m recent --set --name DEFAULT --rsource
</pre>
<p>下一条规则告诉 iptables 查找匹配前一条规则的数据包，这些数据包也来自已添加到监视列表中的主机。
</p>
<pre># iptables -A INPUT -p tcp -m tcp --dport 42660 -m state --state NEW -m recent --update --seconds 90 --hitcount 4 --name DEFAULT --rsource -j LOG_AND_DROP
</pre>
<p>现在，让 iptables 决定如何处理 TCP 42660 端口的通信中不符合上述规则的数据包。
</p>
<pre># iptables -A INPUT -p tcp -m tcp --dport 42660 -j ACCEPT
</pre>
<p>我们向 LOG_AND_DROP 表增加如下规则，并使用 -j (jump) 参数将数据包的信息传递给日志记录工具。
</p>
<pre># iptables -A LOG_AND_DROP -j LOG --log-prefix "iptables deny: " --log-level 7
</pre>
<p>在按照第一条规则进行记录后，所有数据包将被丢弃。
</p>
<pre># iptables -A LOG_AND_DROP -j DROP
</pre>
<h6>
<span id=".E9.98.B2.E6.AD.A2.E6.9A.B4.E5.8A.9B.E7.A0.B4.E8.A7.A3.E7.9A.84.E5.B7.A5.E5.85.B7"></span><span class="mw-headline" id="防止暴力破解的工具">防止暴力破解的工具</span>
</h6>
<p>你可以用类似 <a href="../en/Fail2ban.html" title="Fail2ban">fail2ban</a> 或 <a href="../en/Sshguard.html" title="Sshguard">sshguard</a> 的自动防暴破的脚本来阻挡攻击者。
</p>
<ul>
<li>仅允许来自受信任位置的 SSH 入站连接。</li>
<li>使用 <a href="../en/Fail2ban.html" title="Fail2ban">fail2ban</a> 或 <a href="../en/Sshguard.html" title="Sshguard">sshguard</a> 自动阻止多次密码验证失败的 IP 地址。</li>
<li>使用 <a rel="nofollow" class="external text" href="https://github.com/jtniehof/pam_shield">pam_shield</a> 来阻止在一定时间内执行过多登录尝试的 IP 地址。与 <a href="../en/Fail2ban.html" title="Fail2ban">fail2ban</a> 或 <a href="../en/Sshguard.html" title="Sshguard">sshguard</a>不同，该程序不考虑登录成功或失败。</li>
</ul>
<h5>
<span id=".E7.A6.81.E7.94.A8.E6.88.96.E9.99.90.E5.88.B6_root_.E8.B4.A6.E6.88.B7.E7.99.BB.E5.BD.95"></span><span class="mw-headline" id="禁用或限制_root_账户登录">禁用或限制 root 账户登录</span>
</h5>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a><b>This article or section is out of date.</b><a href="../File:Tango-view-refresh-red.png" class="image"><img alt="Tango-view-refresh-red.png" src="../File:Tango-view-refresh-red.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> 最新版本默认已禁用 root 账户登录。暂不清楚本节的哪些部分是多余的。 (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<p>允许 root 账户随意通过 SSH 登录通常是不安全的，有两种方法可以限制 root 账户通过 SSH 登录，从而提高安全性。
</p>
<h6>
<span id=".E7.A6.81.E7.94.A8_root_.E7.99.BB.E5.BD.95"></span><span class="mw-headline" id="禁用_root_登录">禁用 root 登录</span>
</h6>
<p>Sudo 可以有选择地为需要 root 权限的操作提供相应的权限，且不需要登录 root 账户。这样即可关闭 root 登录，并且可以看做一种防范暴力攻击的安全措施，因为现在攻击者除了要猜测密码外还要猜测帐户名称。
</p>
<p>通过编辑 <code>/etc/ssh/sshd_config</code> 中的 "Authentication" 一节可以使 SSH 屏蔽 root 用户登录，只要将 <code>#PermitRootLogin prohibit-password</code> 改成 <code>no</code> 并取消该行注释即可：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/ssh/sshd_config</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">PermitRootLogin no
...
</pre>
<p>然后 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">重启</a> SSH 守护进程。
</p>
<p>现在你将无法通过 root 账户登录，但仍可以用普通账户登录并使用 <a href="../en/Su.html" title="Su">su</a> 或者 <a href="../en/Sudo.html" title="Sudo">sudo</a> 来完成系统维护工作。
</p>
<h6>
<span id=".E9.99.90.E5.88.B6_root_.E7.99.BB.E5.BD.95"></span><span class="mw-headline" id="限制_root_登录">限制 root 登录</span>
</h6>
<p>一些自动化的维护任务（比如远程备份整个系统）需要完整的 root 权限。要以安全的方式允许 root 登录而不是禁用它，可以只允许远程登录的 root 用户执行指定的命令，在 <code>~root/.ssh/authorized_keys</code> 头部加上指定的密钥即可，例如：
</p>
<pre>command="/usr/lib/rsync/rrsync -ro /" ssh-rsa …
</pre>
<p>这样，任何用户持有该秘钥即可执行引号之间的命令。
</p>
<p>为了弥补因 root 用户名称暴露而导致受攻击的可能性增加，可以将以下命令加入 <code>sshd_config</code>：
</p>
<pre>PermitRootLogin forced-commands-only
</pre>
<p>该设置不仅会限制 root 用户通过 SSH 执行的命令，还会禁用密码登录方式，强制 root 帐户使用公钥登录。
</p>
<p>如果不想限制 root 用户可执行的命令，可以仅关闭密码验证来强制使用公钥验证：
</p>
<pre>PermitRootLogin prohibit-password
</pre>
<h5>
<span id=".E4.BF.9D.E6.8A.A4_authorized_keys_.E6.96.87.E4.BB.B6"></span><span class="mw-headline" id="保护_authorized_keys_文件">保护 authorized_keys 文件</span>
</h5>
<p>你可以阻止其他用户向该文件加入新公钥且通过新的公钥连接。
</p>
<p>把 <code>authorized_keys</code> 文件的权限全部去掉，只保留读权限：
</p>
<pre>$ chmod 400 ~/.ssh/authorized_keys
</pre>
<p>为防止用户把权限改回来，可以对 <code>authorized_keys</code> 文件采取 <a href="../en/File_permissions_and_attributes.html#chattr_and_lsattr" title="File permissions and attributes">set the immutable bit（设为不可变）</a> 操作。尽管如此，用户仍然可以重命名 <code>~/.ssh</code> 并新建一个 <code>~/.ssh</code> 目录和  <code>authorized_keys</code> 文件。所以 <code>~/.ssh</code> 目录也要设置 immutable bit。
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 如果你自己需要新增一个公钥，你需要先移除 <code>authorized_keys</code> 文件的 immutable bit，并增加写权限，最后按上述步骤重新加密。</div>
<h2>
<span id=".E5.85.B6.E4.BB.96_SSH_.E5.AE.A2.E6.88.B7.E7.AB.AF.E4.B8.8E.E6.9C.8D.E5.8A.A1.E7.AB.AF"></span><span class="mw-headline" id="其他_SSH_客户端与服务端">其他 SSH 客户端与服务端</span>
</h2>
<p>除了 OpenSSH，还有很多可用的 SSH <a href="https://en.wikipedia.org/wiki/Comparison_of_SSH_clients" class="extiw" title="wikipedia:Comparison of SSH clients">客户端</a> 和 <a href="https://en.wikipedia.org/wiki/Comparison_of_SSH_servers" class="extiw" title="wikipedia:Comparison of SSH servers">服务端</a>。
</p>
<h3><span class="mw-headline" id="Dropbear">Dropbear</span></h3>
<p><a href="https://en.wikipedia.org/wiki/Dropbear_(software)" class="extiw" title="wikipedia:Dropbear (software)">Dropbear</a> 是一个 SSH-2 客户端与服务端。 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dropbear">dropbear</a></span> 可以从 <a href="../en/Official_repositories.html" title="Official repositories">官方仓库</a> 下载。
</p>
<p>它的命令行版客户端叫 dbclient。
</p>
<h3><span class="mw-headline" id="Mosh">Mosh</span></h3>
<p>来自 Mosh <a rel="nofollow" class="external text" href="http://mosh.mit.edu/">网站</a>：
</p>
<dl>
<dd>Remote terminal application that allows roaming, supports intermittent connectivity, and provides intelligent local echo and line editing of user keystrokes. Mosh is a replacement for SSH. It is more robust and responsive, especially over slow connections such as Wi-Fi, cellular, and long-distance.</dd>
<dd>翻译：允许“漫游”的远程终端，支持间歇性的连接，并提供对于用户按键的智能本地回馈和行编辑回馈。Mosh 是 SSH 的替代品。它更加强大而快速，特别针对诸如 Wi-Fi，移动网络和超远距离等慢速连接环境。</dd>
</dl>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">安装</a>  <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=mosh">mosh</a></span> 这个包， 或安装最新版：<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mosh-git/">mosh-git</a></span><sup><small>AUR</small></sup>。
</p>
<p>Mosh 有一个未写入文档的命令行选项：<code>--predict=experimental</code>，它可以产生更有力的本地按键响应。对降低键盘输入视觉上的延迟确认感兴趣的用户可能更喜欢这个预测模式。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> Mosh 从设计上就不允许你访问会话的历史记录，请考虑安装终端复用工具，如 <a href="../en/Tmux.html" title="Tmux">tmux</a> 或 <a href="../en/GNU_Screen.html" title="GNU Screen">GNU Screen</a> 。</div>
<h2>
<span id=".E6.8F.90.E7.A4.BA.E4.B8.8E.E6.8A.80.E5.B7.A7"></span><span class="mw-headline" id="提示与技巧">提示与技巧</span>
</h2>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a><b>The factual accuracy of this article or section is disputed.</b><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> 根据目前本文的布局，这部分看起来应该是通用的，但实际上大部分提供的技巧只能在 <i>openssh</i> 中使用。比如 <i>dropbear</i> (在 <a href="#Other_SSH_clients_and_servers">#Other SSH clients and servers</a> 列表中) 不支持 SOCKS 协议。<a href="https://en.wikipedia.org/wiki/Comparison_of_SSH_clients#Technical" class="extiw" title="wikipedia:Comparison of SSH clients">wikipedia:Comparison_of_SSH_clients#Technical</a> (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<h3>
<span id=".E5.8A.A0.E5.AF.86_Socks_.E9.80.9A.E9.81.93"></span><span class="mw-headline" id="加密_Socks_通道">加密 Socks 通道</span>
</h3>
<p>对于连接到各种不安全的无线网络上的笔记本电脑用户来说,这个是特别有用的！唯一所需要的就是一个一定程度上处于安全的地点的 SSH 服务器，比如在家里或办公室。用动态的 DNS 服务 <a rel="nofollow" class="external text" href="http://www.dyndns.org/">DynDNS</a> 也可能是很有用的，这样你就不必记住你的 IP 了。
</p>
<h4>
<span id=".E7.AC.AC.E4.B8.80.E6.AD.A5.EF.BC.9A.E5.BC.80.E5.A7.8B.E8.BF.9E.E6.8E.A5"></span><span class="mw-headline" id="第一步：开始连接">第一步：开始连接</span>
</h4>
<p>你只要执行这一个命令就能开始你的连接：
</p>
<pre>$ ssh -TND 4711 <i>user</i>@<i>host</i>
</pre>
<p>这里的 <code><i>user</i></code> 是你在 <code><i>host</i></code> 这台 SSH 服务器上的用户名。它会让你输入密码，然后你就能连上了。 <code>N</code> 表示不采用交互提示，而 <code>D</code> 表示指定监听的本地端口（你可以使用任何你喜欢的数字），<code>T</code> 表示禁用伪 tty 分配。
</p>
<p>加了 <code>-v</code> (verbose) 标志以后的输出可以让你能够验证到底连了哪个端口。
</p>
<h4>
<span id=".E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E9.85.8D.E7.BD.AE.E4.BD.A0.E7.9A.84.E6.B5.8F.E8.A7.88.E5.99.A8.28.E6.88.96.E5.85.B6.E5.AE.83.E7.A8.8B.E5.BA.8F.29"></span><span class="mw-headline" id="第二步：配置你的浏览器(或其它程序)">第二步：配置你的浏览器(或其它程序)</span>
</h4>
<p>如果你没有配置你的浏览器（或其他程序）使用这个新创建的 socks 隧道，上述步骤是无效的。由于当前版本的 SSH 支持 SOCKS4 和 SOCKS5，因此您可以使用其中任何一种。
</p>
<ul><li>对于 Firefox: <i>Edit &gt; Preferences &gt; Advanced &gt; Network &gt; Connection &gt; Setting</i>: <br> 选中 <i>Manual proxy configuration</i> 单选框, 然后在 <i>SOCKS host</i> 里输入 <code>localhost</code>， 然后在后面那个框中输入你的端口号（本例中为 <code>4711</code>）。</li></ul>
<p>Firefox 不会自动通过 socks 隧道发送 DNS 请求，这一潜在的隐私问题可以通过以下步骤来解决：
</p>
<ol>
<li>在 Firefox 地址栏中输入：about:config 。</li>
<li>搜索：network.proxy.socks_remote_dns</li>
<li>将该值设为 true。</li>
<li>重启浏览器。</li>
</ol>
<ul><li>对于 Chromium: 你可以将 SOCKS 设置设置为环境变量或命令行选项。我建议将下列函数之一加入到你的 <code>.bashrc</code>：</li></ul>
<pre>function secure_chromium {
    port=4711
    export SOCKS_SERVER=localhost:$port
    export SOCKS_VERSION=5
    chromium &amp;
    exit
}
</pre>
<p>或者
</p>
<pre>function secure_chromium {
    port=4711
    chromium --proxy-server="socks://localhost:$port" &amp;
    exit
}
</pre>
<p>现在打开终端然后输入：
</p>
<pre>$ secure_chromium
</pre>
<p>享受你的安全隧道吧！
</p>
<h3>
<span id="X11_.E8.BD.AC.E5.8F.91"></span><span class="mw-headline" id="X11_转发">X11 转发</span>
</h3>
<p>为了通过 SSH 运行图形程序你必须使用 X11 转发 (forwarding)。这不要求对端安装了完整的 X11，但是至少要装好 <i>xauth</i>。<i>xauth</i> 是一个用来管理 <code>Xauthority</code> 配置的工具，该配置用于服务器与客户端之间的 X11 会话认证(<a rel="nofollow" class="external text" href="http://xmodulo.com/2012/11/how-to-enable-x11-forwarding-using-ssh.html">source</a><sup title="最后检查状态：domain name not resolved">[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">失效链接</a> 2020-08-04 ⓘ]</sup>)。
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> X11 转发有着重要的安全问题需要考虑，至少应先阅读 <span class="plainlinks archwiki-template-man" title="$ man 1 ssh"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh.1">ssh(1)</a></span>、<span class="plainlinks archwiki-template-man" title="$ man 5 sshd_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/sshd_config.5">sshd_config(5)</a></span> 和 <span class="plainlinks archwiki-template-man" title="$ man 5 ssh_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh_config.5">ssh_config(5)</a></span> 手册页。也可以参考 <a rel="nofollow" class="external text" href="https://security.stackexchange.com/questions/14815/security-concerns-with-x11-forwarding">这个 StackExchange 帖</a>。</div>
<h4>
<span id=".E9.85.8D.E7.BD.AE_3"></span><span class="mw-headline" id="配置_3">配置</span>
</h4>
<p>在远程主机上：
</p>
<ul>
<li>
<a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xauth">xorg-xauth</a></span> 和 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xhost">xorg-xhost</a></span> 这两个包</li>
<li>在 <code>/etc/ssh/ssh<b>d</b>_config</code> 上:
<ul>
<li>确保 <code>AllowTcpForwarding</code> 和 <code>X11UseLocalhost</code> 已经设置为 <i>yes</i>，并且 <code>X11DisplayOffset</code> 设置为 <i>10</i> （这些是默认设置，参考 <span class="plainlinks archwiki-template-man" title="$ man 5 sshd_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/sshd_config.5">sshd_config(5)</a></span>）</li>
<li>将 <code>X11Forwarding</code> 设置为 <i>yes</i>
</li>
</ul>
</li>
<li>最后 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">重启</a>  <a href="#Daemon_management"><i>sshd</i> 守护进程</a><sup>[<a href="../en/ArchWiki:Requests.html#Broken_section_links" class="mw-redirect" title="ArchWiki:Requests">断开的链接</a>：无效的部分]</sup>.</li>
</ul>
<p>在客户端上，通过在命令行设置 <code>-X</code> 参数启用 <code>ForwardX11</code>，或者在<a href="#%E9%85%8D%E7%BD%AE">客户端配置文件</a>中将 <code>ForwardX11</code> 设置为 <i>yes</i>。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 如果 GUI 绘制不正常或者有错误提示，你可以启用 <code>ForwardX11Trusted</code> 选项（或在命令行中加上 <code>-Y</code> 参数），这将使 X11 转发脱离 <a rel="nofollow" class="external text" href="http://www.x.org/wiki/Development/Documentation/Security/">X11 SECURITY extension</a> 的控制，如果你这样做，请确保已经读过本节开头的<a href="#X11_%E8%BD%AC%E5%8F%91">警告</a>。</div>
<h4>
<span id=".E4.BD.BF.E7.94.A8.E6.96.B9.E6.B3.95"></span><span class="mw-headline" id="使用方法">使用方法</span>
</h4>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a><b>The factual accuracy of this article or section is disputed.</b><a href="../File:Tango-inaccurate.png" class="image"><img alt="Tango-inaccurate.png" src="../File:Tango-inaccurate.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> <code>xhost</code> <a rel="nofollow" class="external text" href="https://unix.stackexchange.com/questions/12755/how-to-forward-x-over-ssh-from-ubuntu-machine#comment-17148">通常不是必须的</a> (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<p>正常登录远程主机，如果客户端的配置文件中没有启用 <i>ForwardX11</i> 那就加上 <code>-X</code> 参数：
</p>
<pre>$ ssh -X <i>user@host</i>
</pre>
<p>如果在运行图形程序的时候碰到错误，尝试用 <i>ForwardX11Trusted</i> 代替 <i>ForwardX11</i> ：
</p>
<pre>$ ssh -Y <i>user@host</i>
</pre>
<p>现在你应该可以运行服务器上的任何 X 图形程序，任何输出都会重定向至你当前的会话：
</p>
<pre>$ xclock
</pre>
<p>如果碰到 "Cannot open display" 的错误，请尝试用非管理员账户运行下列命令：
</p>
<pre>$ xhost +
</pre>
<p>上述命令将允许任何人转发 X11 应用程序，这个命令可以限制特定的主机类型：
</p>
<pre>$ xhost +hostname
</pre>
<p>其中 hostname 是要转发到的特定主机的名称。更多信息可以查看 <span class="plainlinks archwiki-template-man" title="$ man 1 xhost"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/xhost.1">xhost(1)</a></span>。
</p>
<p>请注意某些应用程序，它们会检查本地计算机上正在运行的实例。<a href="../en/Firefox.html" title="Firefox">Firefox</a> 就是其中之一：你可以关掉本机上的 Firefox 或者使用以下启动参数来启动远程实例：
</p>
<pre>$ firefox --no-remote
</pre>
<p>当你连接时收到 "X11 forwarding request failed on channel 0" 错误（或者服务器上的 <code>/var/log/errors.log</code> 文件显示 "Failed to allocate internet-domain X11 display socket" 错误），请确保已经安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xauth">xorg-xauth</a></span>，如果装完了仍然不起作用，尝试以下方法之一：
</p>
<ul>
<li>在<i>服务器</i>的 <code>ssh<b>d</b>_config</code> 中启用 <code>AddressFamily any</code> 选项，或者</li>
<li>将<i>服务器</i>的 <code>ssh<b>d</b>_config</code> 中的 <code>AddressFamily</code> 选项设为 inet。</li>
</ul>
<p>将其设置为 inet 可能会修复 IPv4 上的 Ubuntu 客户端的问题。
</p>
<p>要以其他用户身份运行 SSH 服务器上的 X 应用程序，你需要先用已知用户登录，取出 <code>xauth list</code> 中的身份认证行，然后 <code>xauth add</code> 它。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> <a rel="nofollow" class="external text" href="https://unix.stackexchange.com/a/12772">这里</a> 是 <a rel="nofollow" class="external text" href="https://unix.stackexchange.com/a/46748">一些</a> 用来诊断 <code>X11 Forwarding</code> 问题有用的 <a rel="nofollow" class="external text" href="https://superuser.com/a/805060">链接</a>。</div>
<h3>
<span id=".E8.BD.AC.E5.8F.91.E5.85.B6.E4.BB.96.E7.AB.AF.E5.8F.A3"></span><span class="mw-headline" id="转发其他端口">转发其他端口</span>
</h3>
<p>除了 SSH 内建的对 X11 的支持之外，它也能通过本地转发和远程转发，来为任何的TCP连接建立隧道。
</p>
<p>本地转发时，会在本机打开一个端口，连接将被转发到一个远程主机，并给定一个目的地。很多时候，转发目的地和远程主机会相同，因此也提供了一条SSH命令来建立一个安全的VNC连接。本地转发可以通过 <code>-L</code> 来设置，后面可以指定一个地址及端口 <code>&lt;tunnel port&gt;:&lt;destination address&gt;:&lt;destination port&gt;</code>。
</p>
<p>如下：
</p>
<pre>$ ssh -L 1000:mail.google.com:25 192.168.0.100
</pre>
<p>以上指令将会通过 SSH 得到一个在 <code>192.168.0.100</code> 的 shell，同时也会创建一个从本机 TCP 1000 端口到 mail.google.com 上的 25 端口的隧道。建立之后，通过 <code>localhost:1000</code> 的连接可以直接连接到 Gmail 的 SMTP 端口。对 Google 而言，任何这样的连接都是来自 <code>192.168.0.100</code> 的（即使这些连接中没有数据传输），并且，在本机和 192.168.0.100 之间的数据传递是安全的，但 <code>192.168.0.100</code> 和 Google 之间是不安全的，除非还采取了别的手段保障数据安全。
</p>
<p>同样：
</p>
<pre>$ ssh -L 2000:192.168.0.100:6001 192.168.0.100
</pre>
<p>以上指令会将到 <code>localhost:2000</code> 的连接直接转发到远程主机 192.168.0.100 的 6001 端口。对于使用 VNC 服务器（tightvns包的一部分）建立的 VNC 连接来说，以上的例子尽管很有效，但是安全性有待商榷。
</p>
<p>远程转发允许任何远程主机通过 SSH 隧道连接到本机，提供了和本地转发相反的功能，突破了防火墙的限制。通过 <code>-R</code> 参数，以及 <code>&lt;tunnel port&gt;:&lt;destination address&gt;:&lt;destination port&gt;</code> 能够实现远程转发。
</p>
<p>如下:
</p>
<pre>$ ssh -R 3000:irc.freenode.net:6667 192.168.0.200
</pre>
<p>将会在 <code>192.168.0.200</code> 上得到一个 shell，同时，来自 <code>192.168.0.200</code> 的 3000 端口（远程主机的 <code>localhost:3000</code>）的数据将会通过隧道转发至本机，然后转发至 irc.freenode.net 上的 6667 端口。因此，在这个例子中，在远程主机上能够使用 IRC 程序，即使端口 6667 被阻止。
</p>
<p>本地转发和远程转发都可以提供一个安全的“网关”，允许其他计算机无需运行 SSH 或者 SSH daemon 来使用 SSH 隧道，即在隧道起点提供绑定的地址，作为转发规则。例如 <code>&lt;tunnel address&gt;:&lt;tunnel port&gt;:&lt;destination address&gt;:&lt;destination port&gt;</code>。<code>&lt;tunnel address&gt;</code> 可以是作为隧道起点的机器上的任何地址，地址 <code>localhost</code> 允许来自本地回环的连接，空地址 <code>*</code> 允许来自任意网卡的连接。默认情况下，转发仅限于连接至位于隧道“起点”的主机，即 <code>&lt;tunnel address&gt;</code> 被设置为 <code>localhost</code>。本地转发不需要额外的设置，而远程转发受限于对端的 SSH daemon 设置。更多关于远程转发和本地转发的信息可分别参阅 <span class="plainlinks archwiki-template-man" title="$ man 5 sshd_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/sshd_config.5">sshd_config(5)</a></span> 中的 <code>GatewayPorts</code> 选项和 <span class="plainlinks archwiki-template-man" title="$ man 1 ssh"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh.1">ssh(1)</a></span> 中的 <code>-L address</code> 选项。
</p>
<h3>
<span id=".E8.B7.B3.E6.9D.BF.E6.9C.BA"></span><span class="mw-headline" id="跳板机">跳板机</span>
</h3>
<p>在某些情况下，你与目标主机之间可能无法直接连接，此时就要用到跳板机。因此，我们尝试将两个或更多 SSH 隧道连接在一起，并假设您的本地密钥已针对链中的每个服务器授权。这可以通过使用SSH代理转发 (<code>-A</code>) 和伪终端分配 (<code>-t</code>) 来实现，它使用以下语法转发本地密钥：
</p>
<pre>$ ssh -A -t -l user1 bastion1 \
  ssh -A -t -l user2 intermediate2 \
  ssh -A -t -l user3 target
</pre>
<p>一个更简单的方法是使用 <code>-J</code> 选项：
</p>
<pre>$ ssh -J user1@bastion1,user2@intermediate2 user3@target
</pre>
<p><br>
<code>-J</code> 指令中的多个主机可以用逗号隔开，它们将按照列出的顺序连接。<code>user...@</code> 部分不是必需的，但可以使用。定义 <code>-J</code> 选项里的不同的主机规格可以使用 ssh 配置文件，因此如果需要，可以在那里设置特定的每个主机选项。
</p>
<h3>
<span id=".E9.80.9A.E8.BF.87.E4.B8.AD.E7.BB.A7.E5.8F.8D.E5.90.91_SSH_.E8.BF.9E.E6.8E.A5"></span><span class="mw-headline" id="通过中继反向_SSH_连接">通过中继反向 SSH 连接</span>
</h3>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> SSH 隧道的设想是很经典的，所以添加一些参考资料的详细解释会更好。比如 <a rel="nofollow" class="external autonumber" href="https://unix.stackexchange.com/questions/46235/how-does-reverse-ssh-tunneling-work/118650#118650">[6]</a> 涵盖了一些其他情况。 (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<p>这个想法是客户端通过一个中继连接到服务器，而服务器使用反向 SSH 隧道连接到同一个中继。例如，当服务器位于 NAT 后面时，这是很有用的，而此处的中继是一个可公开访问的 SSH 服务器，用作用户有权访问的代理服务器。前提是客户端的密钥同时对中继和服务器都已经授权，服务器需要授权中继用于反向 SSH 连接。
</p>
<p>以下配置假设 user1 是客户端使用的账户，user2 是中继的，user3 是服务器的。首先服务器要先建立反向隧道：
</p>
<pre>ssh -R 2222:localhost:22 -N user2@relay
</pre>
<p>这可以利用启动脚本、systemd service 或者 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=autossh">autossh</a></span> 来自动完成。
</p>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a><b>This article or section needs expansion.</b><a href="../File:Tango-view-fullscreen.png" class="image"><img alt="Tango-view-fullscreen.png" src="../File:Tango-view-fullscreen.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b> 需要解释为何光有 <code>ssh user3@relay -p 2222</code> 是不够的。 (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Talk:OpenSSH (简体中文)#</a>)</div>
</div>
<p>在客户端使用以下命令建立连接：
</p>
<pre>ssh user2@relay ssh user3@localhost -p 2222
</pre>
<p>可以在中继的 <code>~/.ssh/authorized_keys</code> 中定义 <code>command</code> 字段来建立反向隧道：
</p>
<pre>command="ssh user3@localhost -p 2222" ssh-rsa KEY2 user1@client
</pre>
<p>在这种情况下用下列命令建立连接：
</p>
<pre>ssh user2@relay
</pre>
<p>注意，客户端内 scp 的自动完成功能失效，甚至在某些配置下 scp 本身也无法工作。
</p>
<h3>
<span id=".E7.AB.AF.E5.8F.A3.E5.A4.8D.E7.94.A8"></span><span class="mw-headline" id="端口复用">端口复用</span>
</h3>
<p>SSH 守护进程通常监听 22 端口，但是许多公共热点会屏蔽非常规 HTTP/S 端口（分别是 80 和 443 端口）的流量，这样就屏蔽了 SSH 连接。最快的解决方法是让 <code>sshd</code> 额外监听白名单上的端口：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/ssh/sshd_config</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Port 22
Port 443
</pre>
<p>但是443端口很有可能已经被 HTTPS 服务占用，在这种情况下可以使用端口复用工具，比如 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=sslh">sslh</a></span>，它可以监听在一个被复用的端口上并转发相应的数据包给对应的服务。
</p>
<h3>
<span id=".E5.8A.A0.E9.80.9F_SSH"></span><span class="mw-headline" id="加速_SSH">加速 SSH</span>
</h3>
<p>此处列出一些可以加速全部连接或针对某台主机加速的 <a href="#%E9%85%8D%E7%BD%AE">客户端配置</a> 选项。要了解这些选项的完整概述，请参阅 <span class="plainlinks archwiki-template-man" title="$ man 5 ssh_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh_config.5">ssh_config(5)</a></span>。
</p>
<ul><li>使用以下参数来使到某一台主机的所有回话 (sessions) 共享同一个连接： <pre>ControlMaster auto
ControlPersist yes
ControlPath ~/.ssh/sockets/socket-%r@%h:%p
</pre>
</li></ul>
<dl><dd>其中 <code>~/.ssh/sockets</code> 可以是一个其他用户不可写入的任意目录。</dd></dl>
<ul><li>
<code>ControlPersist</code> 指定在初始客户端连接关闭后，主服务器在后台等待新客户端的时间。可能的值是：
<ul>
<li>
<code>no</code> 指定在最后一个客户端断开后立即关闭连接，</li>
<li>一个用秒数表示的时间，</li>
<li>
<code>yes</code> 连接不会自动关闭，而是始终处于等待。</li>
</ul>
</li></ul>
<ul><li>另一种加速的方法是通过 <code>Compression yes</code> 选项或者 <code>-C</code> 参数来启用压缩。</li></ul>
<dl><dd><div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> <span class="plainlinks archwiki-template-man" title="$ man 1 ssh"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh.1">ssh(1)</a></span> 指出：“在调制解调器线路或其他慢速线路上启用压缩是可取的，但在网速快的情况下只会降低速度。”这条提示可能会适得其反，具体取决于你的网络配置。</div></dd></dl>
<ul><li>通过使用 <code>AddressFamily inet</code> 选项或者 <code>-4</code> 参数来跳过 IPv6 查找，可以缩短登录时间。</li></ul>
<ul><li>最后，如果你想用 SFTP 或 SCP，<a rel="nofollow" class="external text" href="https://www.psc.edu/index.php/hpn-ssh">High Performance SSH/SCP</a> 可以通过动态提高 SSH 缓冲区大小来显著提高吞吐量。安装 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/openssh-hpn-git/">openssh-hpn-git</a></span><sup><small>AUR</small></sup> 这个包来使用打过这一增强补丁的 OpenSSH 版本。</li></ul>
<h3>
<span id=".E7.94.A8_SSHFS_.E6.8C.82.E8.BD.BD.E8.BF.9C.E7.A8.8B.E6.96.87.E4.BB.B6.E7.B3.BB.E7.BB.9F"></span><span class="mw-headline" id="用_SSHFS_挂载远程文件系统">用 SSHFS 挂载远程文件系统</span>
</h3>
<p>请参阅 <a href="../en/SSHFS.html" title="SSHFS">SSHFS</a> 来将一个 SSH 可访问的远程文件系统挂载至一个本地目录，然后你就能在挂载好的文件上执行常规操作（复制，重命名，用 vim 编辑等等）。<i>sshfs</i> 比 <i>shfs</i> 更好，因为后者自 2004 年起就没再更新。
</p>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 软件包 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/autosshfs-git/">autosshfs-git</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">断开的链接</a>：package not found]</sup> 可以用于在登录时自动运行 autosshfs。</div>
<h3>
<span id=".E4.BF.9D.E6.8C.81.E5.9C.A8.E7.BA.BF"></span><span class="mw-headline" id="保持在线">保持在线</span>
</h3>
<p>默认情况下，如果你的会话空闲了某个时间之后，它会自动登出。为了保持会话，在长时间没有数据传输时客户端可以向服务器发送一个激活信号。与之对应，服务器也可以在一段时间没有收到消息时定期发送一个信号。
</p>
<ul>
<li>在 <b>服务器</b>，<code>ClientAliveInterval</code> 是没有从客户端收到消息后的超时时间，超时后 <i>sshd</i> 将会发送一个请求来等待回应。默认是 0，指不会发出请求。比如要求每隔 60 秒向客户端发送响应请求，在你的 <a href="#%E9%85%8D%E7%BD%AE_2">服务器配置</a> 里设置 <code>ClientAliveInterval 60</code> 即可。<code>ClientAliveCountMax</code> 和 <code>TCPKeepAlive</code> 选项也可以参考一下。</li>
<li>在 <b>客户端</b>，<code>ServerAliveInterval</code> 控制着从客户端发往服务器的响应请求的时间间隔。比如要求服务器每隔 120 秒响应一次，在你的 <a href="#%E9%85%8D%E7%BD%AE">客户端配置</a> 里加入 <code>ServerAliveInterval 120</code> 即可。<code>ServerAliveCountMax</code> 和 <code>TCPKeepAlive</code> 选项也可以参考一下。</li>
</ul>
 <div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong>  为确保会话保持活动状态，客户端或服务器中只有一个需要发送保持活动请求。如果用户同时控制服务器和客户端，那么合理的选择是使用 <code>ServerAliveInterval</code> 选项配置需要保持会话的客户端，并保留其他客户端和服务器的默认配置。</div>
<h3>
<span id=".E5.88.A9.E7.94.A8_systemd_.E8.87.AA.E5.8A.A8.E9.87.8D.E5.90.AF_SSH_.E9.9A.A7.E9.81.93"></span><span class="mw-headline" id="利用_systemd_自动重启_SSH_隧道">利用 systemd 自动重启 SSH 隧道</span>
</h3>
<p><a href="../en/Systemd.html" title="Systemd">systemd</a> 可以在开机/登录时自动启动 SSH，<i>还可以</i> 在 SSH 连接断开时自动重连。这使它成为管理 SSH 隧道的有力工具。
</p>
<p>下面的 service 可以使用 <a href="#%E9%85%8D%E7%BD%AE">ssh 配置</a> 里面的配置在你登录系统的时候自动开启一个 SSH 隧道。如果连接因为某种原因断开，它将会每隔10秒重启一下：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">~/.config/systemd/user/tunnel.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=SSH tunnel to myserver

[Service]
Type=simple
Restart=always
RestartSec=10
ExecStart=/usr/bin/ssh -F %h/.ssh/config -N myserver
</pre>
<p>然后 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">enable</a> 并且 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Start">start</a> 这个 user service。欲知如何防止连接超时，请参阅 <a href="#%E4%BF%9D%E6%8C%81%E5%9C%A8%E7%BA%BF">#保持在线</a>。如果你想在系统引导后就打开这个连接，你需要将这个 unit 重写为 system service。
</p>
<h3>
<span id="Autossh_-_.E8.87.AA.E5.8A.A8.E9.87.8D.E5.90.AF_SSH_.E4.BC.9A.E8.AF.9D.E5.92.8C.E9.9A.A7.E9.81.93.E8.BF.9E.E6.8E.A5"></span><span class="mw-headline" id="Autossh_-_自动重启_SSH_会话和隧道连接">Autossh - 自动重启 SSH 会话和隧道连接</span>
</h3>
<p>当一个 SSH 会话或隧道无法保持连接（比如网络环境差导致客户端断线），可以使用 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=autossh">autossh</a></span> 来自动重启它们。
</p>
<p>使用范例：
</p>
<pre>$ autossh -M 0 -o "ServerAliveInterval 45" -o "ServerAliveCountMax 2" username@example.com
</pre>
<p>结合 <a href="../en/SSHFS.html" title="SSHFS">SSHFS</a>：
</p>
<pre>$ sshfs -o reconnect,compression=yes,transform_symlinks,ServerAliveInterval=45,ServerAliveCountMax=2,ssh_command='autossh -M 0' username@example.com: /mnt/example 
</pre>
<p>通过一个由 <a href="../en/Proxy_server.html" class="mw-redirect" title="Proxy settings">Proxy settings</a> 设置好的 SOCKS 代理来连接：
</p>
<pre>$ autossh -M 0 -o "ServerAliveInterval 45" -o "ServerAliveCountMax 2" -NCD 8080 username@example.com 
</pre>
<p>使用 <code>-f</code> 选项以后可以使 autossh 作为后台进程运行，然而以这种方式运行意味着不能交互输入密码。
</p>
<p>当你在会话中打出 <code>exit</code> 即可结束会话，或者 autossh 收到了 SIGTERM, SIGINT of SIGKILL 信号。
</p>
<h4>
<span id=".E5.88.A9.E7.94.A8_systemd_.E5.9C.A8.E5.BC.95.E5.AF.BC.E5.90.8E.E8.87.AA.E5.8A.A8.E8.BF.90.E8.A1.8C_autossh"></span><span class="mw-headline" id="利用_systemd_在引导后自动运行_autossh">利用 systemd 在引导后自动运行 autossh</span>
</h4>
<p>如果你想自动启动 autossh，创建一个 systemd unit 文件：
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/autossh.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
Description=AutoSSH service for port 2222
After=network.target

[Service]
Environment="AUTOSSH_GATETIME=0"
ExecStart=/usr/bin/autossh -M 0 -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com

[Install]
WantedBy=multi-user.target</pre>
<p>其中 <code>AUTOSSH_GATETIME=0</code> 是一个环境变量，它表示 ssh 需要连上多久，autossh 才判定这个连接是成功的。将它设为 0 后 autossh 也会忽略 ssh 的第一次运行失败。这在开机启动 autossh 时可能是有用的。其他环境变量可以在手册页找到。当然，如果需要的话，你可以使这个单元更加复杂（详情请参阅 systemd 文档），显然你可以使用自己的 autossh 选项，但请注意 <code>-f</code> 选项意味着 <code>AUTOSSH_GATETIME=0</code> 无法在 systemd 中起效。
</p>
<p>别忘了 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Start">start</a> 且/或 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">enable</a> 这个 service。
</p>
<p>你可能还会需要关闭 ControlMaster，像这样：
</p>
<pre>ExecStart=/usr/bin/autossh -M 0 -o ControlMaster=no -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com
</pre>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>提示：</strong> 同时管理多个 autossh 进程也是很简单的，要保持多个隧道连接，只需要用不同的文件名创建多个 service 文件。</div>
<h3>
<span id=".E5.BD.93_SSH_.E5.AE.88.E6.8A.A4.E8.BF.9B.E7.A8.8B.E5.87.BA.E9.94.99.E6.97.B6.E7.9A.84.E5.85.B6.E4.BB.96.E9.80.89.E6.8B.A9"></span><span class="mw-headline" id="当_SSH_守护进程出错时的其他选择">当 SSH 守护进程出错时的其他选择</span>
</h3>
<p>对于仅依赖 SSH 的远程或无头服务器，启动 SSH 守护程序失败（例如系统升级后）可能会阻止管理员访问。<a href="../en/Systemd.html" title="Systemd">systemd</a> 通过 <code>OnFailure</code> 选项提供了简便的解决方案。
</p>
<p>假设服务器运行 <code>sshd</code> 并且 <a href="../en/Telnet.html" title="Telnet">telnet</a> 是所选的故障安全替代方案。按如下所示创建一个文件。<b>不要</b> <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Enable">enable</a> telnet.socket！
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/sshd.service.d/override.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">[Unit]
OnFailure=telnet.socket</pre>
<p>这样就行了。当 <code>sshd</code> 正在运行时，Telnet 是不可用的。如果 <code>sshd</code> 无法启动，可以打开一个 telnet 会话进行恢复。
</p>
<h2>
<span id=".E7.96.91.E9.9A.BE.E8.A7.A3.E7.AD.94"></span><span class="mw-headline" id="疑难解答">疑难解答</span>
</h2>
<h3>
<span id=".E8.87.AA.E6.A3.80.E6.B8.85.E5.8D.95"></span><span class="mw-headline" id="自检清单">自检清单</span>
</h3>
<p>在进一步阅读前，请先仔细检查下面这些常见故障。
</p>
<ol>
<li>配置文件存放目录 <code>~/.ssh</code> 及目录下的文件应该只有你的账户才有访问权限（在客户端和服务器上都检查这一条）： <pre>$ chmod 700 ~/.ssh
$ chmod 600 ~/.ssh/*
$ chown -R $USER ~/.ssh
</pre>
</li>
<li>检查客户端的公钥（比如 <code>id_rsa.pub</code>）在服务器的 <code>~/.ssh/authorized_keys</code> 文件里面。</li>
<li>检查有没有在 <a href="#%E9%85%8D%E7%BD%AE_2">服务器配置</a> 里面设置 <code>AllowUsers</code> 或 <code>AllowGroups</code> 来限制 SSH 访问。</li>
<li>检查用户是否设置了密码。有时还没有登录过服务器的新用户没有密码。</li>
<li>把 <code>LogLevel DEBUG</code> 加到 <code>/etc/ssh/sshd_config</code> 文件尾部。</li>
<li>使用 <code>journalctl -xe</code> 查看可能的错误信息。</li>
<li>在客户端和服务器上 <a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">重启</a> <code>sshd</code> 然后注销/重新登录。</li>
</ol>
<h3>
<span id=".E6.8B.92.E7.BB.9D.E8.BF.9E.E6.8E.A5.E6.88.96.E8.80.85.E8.B6.85.E6.97.B6.E9.97.AE.E9.A2.98"></span><span class="mw-headline" id="拒绝连接或者超时问题">拒绝连接或者超时问题</span>
</h3>
<h4>
<span id=".E7.AB.AF.E5.8F.A3.E8.BD.AC.E5.8F.91"></span><span class="mw-headline" id="端口转发">端口转发</span>
</h4>
<p>如果您位于 NAT 模式/路由器之后（除非您位于 VPS 或可公开寻址的主机上），请确保您的路由器可以将传入的 ssh 连接转发到您的计算机。使用 <code>$ ip addr</code> 查找服务器的内网 IP 地址，并将您的路由器设置为将 SSH 端口上的 TCP 数据包转发到该 IP。<a rel="nofollow" class="external text" href="http://portforward.com">portforward.com</a> 可以提供帮助。
</p>
<h4>
<span id="SSH.E6.9C.8D.E5.8A.A1.E6.98.AF.E5.90.A6.E5.BC.80.E5.90.AF.E5.B9.B6.E4.B8.94.E6.AD.A3.E5.9C.A8.E7.9B.91.E5.90.AC.EF.BC.9F"></span><span class="mw-headline" id="SSH服务是否开启并且正在监听？">SSH服务是否开启并且正在监听？</span>
</h4>
<pre>$ ss -tnlp
</pre>
<p>如果以上的命令没有显示 SSH 端口是打开的，那么说明 SSH 服务没有启动。查看 <code>/var/log/messages</code> 来寻找错误信息。
</p>
<h4>
<span id=".E6.98.AF.E5.90.A6.E6.98.AF.E9.98.B2.E7.81.AB.E5.A2.99.E9.98.BB.E6.AD.A2.E4.BA.86.E8.BF.9E.E6.8E.A5.EF.BC.9F"></span><span class="mw-headline" id="是否是防火墙阻止了连接？">是否是防火墙阻止了连接？</span>
</h4>
<p><a href="../en/Iptables.html" title="Iptables">Iptables</a> 可能会阻止 <code>22</code> 端口的连接。使用 </p>
<pre># iptables -nvL</pre>
<p> 来检查可能会在 <code>INPUT</code> 链上导致丢包的规则。必要情况下可以用以下命令来解锁端口：
</p>
<pre># iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT
</pre>
<p>更多配置防火墙的信息，请参阅 <a href="../en/Category:Firewalls.html" class="mw-redirect" title="Firewalls">firewalls</a>.
</p>
<h4>
<span id=".E4.BD.A0.E7.9A.84.E7.94.B5.E8.84.91.E5.92.8C.E7.9B.AE.E7.9A.84.E4.B8.BB.E6.9C.BA.E4.B9.8B.E9.97.B4.E6.98.AF.E5.90.A6.E8.BF.9E.E6.8E.A5.EF.BC.9F"></span><span class="mw-headline" id="你的电脑和目的主机之间是否连接？">你的电脑和目的主机之间是否连接？</span>
</h4>
<p>测试你的电脑和目的主机的连接情况：
</p>
<pre># tcpdump -lnn -i any port ssh and tcp-syn
</pre>
<p>它会显示一些基本信息，然后等待数据交换。现在尝试你的连接。如果没有输出，就可能是你的电脑网络阻塞了。（也许是防火墙问题，也许是 NAT 路由的问题）
</p>
<h4>
<span id=".E4.BD.A0.E7.9A.84_ISP_.E6.88.96.E7.AC.AC.E4.B8.89.E6.96.B9.E5.B1.8F.E8.94.BD.E4.BA.86.E9.BB.98.E8.AE.A4.E7.AB.AF.E5.8F.A3.EF.BC.9F"></span><span class="mw-headline" id="你的_ISP_或第三方屏蔽了默认端口？">你的 ISP 或第三方屏蔽了默认端口？</span>
</h4>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>注意：</strong> 只有在你<b>确保</b>你没有运行任何防火墙，你已经在路由器上配置了 DMZ 主机或已经将端口映射到你的计算机，而这些都没有用的情况下才尝试以下步骤。可以在此找到诊断步骤或可能的解决方案。</div>
<p>某些情况下，你的运营商会屏蔽默认端口（22 端口），无论怎么尝试（尝试开启端口、强化堆栈、防范洪水攻击）都无济于事。要确认确实存在屏蔽，只要创建一个接受任何来源（0.0.0.0）的服务器并远程连接它。
</p>
<p>如果你收到与此类似的错误消息：
</p>
<pre>ssh: connect to host www.inet.hr port 22: Connection refused
</pre>
<p>就表示你的 ISP <b>没有</b>屏蔽端口，但是服务器没有在该端口上运行 SSH 服务（请参阅 <a href="https://en.wikipedia.org/wiki/Security_through_obscurity" class="extiw" title="wikipedia:Security through obscurity">security through obscurity</a>）。
</p>
<p>但是，如果你收到与这条类似的错误消息：
</p>
<pre>ssh: connect to host 111.222.333.444 port 22: Operation timed out 
</pre>
<p>这就表示有人阻止了 22 端口的 TCP 连接，基本上是通过防火墙或第三方干预（如 ISP 阻止和/或拒绝端口 22 上的传入通信），使得端口不可用。如果你的计算机上没有运行任何防火墙，并且在你的路由器和交换机中没有这方面的流量，那么你的 ISP 屏蔽了通讯。
</p>
<p>为了再次检查确认，可以在服务器上运行 Wireshark 并让它监听在 22 端口。由于 Wireshark 是一个二层数据包嗅探工具，而 TCP/UDP 工作在第三层及以上（参阅 <a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" class="extiw" title="wikipedia:Internet protocol suite">IP Network stack</a>），如果在连接时未收到任何内容，则第三方很可能阻止了该端口上到服务器的流量。
</p>
<h5>
<span id=".E8.AF.8A.E6.96.AD"></span><span class="mw-headline" id="诊断">诊断</span>
</h5>
<p><a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">安装</a> <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=tcpdump">tcpdump</a></span> 或 Wireshark (<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=wireshark-cli">wireshark-cli</a></span>)。
</p>
<p>用于 tcpdump:
</p>
<pre># tcpdump -ni <i>interface</i> "port 22"
</pre>
<p>用于 Wireshark:
</p>
<pre>$ tshark -f "tcp port 22" -i <i>interface</i>
</pre>
<p>其中 <code><i>interface</i></code> 是用于连接 WAN 的网络适配器（用 <code>ip a</code> 来查找）。如果在尝试远程连接时没有收到任何数据包，则可以确信你的 ISP 屏蔽了 22 端口上的传入连接。
</p>
<h5>
<span id=".E5.8F.AF.E8.83.BD.E7.9A.84.E8.A7.A3.E5.86.B3.E6.96.B9.E6.A1.88"></span><span class="mw-headline" id="可能的解决方案">可能的解决方案</span>
</h5>
<p>此方案是换一个 ISP 没有屏蔽的端口。编辑 <code>/etc/ssh/sshd_config</code> 文件来使用不同的端口。例如，新增这几行：
</p>
<pre>Port 22
Port 1234
</pre>
<p>还要确保文件中的其他“Port”配置行被注释掉。只是注释“Port 22”并加上“Port 1234”不会解决问题，因为那样 sshd 将只监听在 1234 端口上。写入这两行可以在两个端口上运行 SSH 服务器。
</p>
<p><a href="../en/Systemd.html#Using_units" class="mw-redirect" title="Restart">重启</a> 服务器上的 <code>sshd.service</code> 就基本完成了。你还需要配置客户端来使用与默认端口不同的端口，这个问题有很多种解决方案，在这里我们只介绍两种。
</p>
<h4>
<span id=".22Read_from_socket_failed:_connection_reset_by_peer.22_.E9.94.99.E8.AF.AF"></span><span class="mw-headline" id='"Read_from_socket_failed:_connection_reset_by_peer"_错误'>"Read from socket failed: connection reset by peer" 错误</span>
</h4>
<p>使用最近版本的 openssh 连接到较旧的 ssh 服务器时有时会失败，并显示上述错误消息。这可以通过为该主机设置各种 <a href="#%E9%85%8D%E7%BD%AE">客户端选项</a> 来解决。有关下列选项的更多信息，请参阅 <span class="plainlinks archwiki-template-man" title="$ man 5 ssh_config"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/ssh_config.5">ssh_config(5)</a></span>。
</p>
<p>问题可能出在 <code>ecdsa-sha2-nistp*-cert-v01@openssh</code> 椭圆曲线算法上。这些算法可以通过在 <code>HostKeyAlgorithms</code> 里设置可用算法来排除那些算法。
</p>
<p>如果这不起作用，可能是秘钥列表太长了。设置 <code>Ciphers</code> 来减少列表长度（少于 80 个字符应该可以）。同样的，也可以尝试缩短 <code>MACs</code> 列表。
</p>
<p>参阅 openssh bug forum 上的 <a rel="nofollow" class="external text" href="http://www.gossamer-threads.com/lists/openssh/dev/51339">讨论</a>。
</p>
<h3>
<span id=".22.5Byour_shell.5D:_No_such_file_or_directory.22_.2F_SSH_.E8.AE.A4.E8.AF.81.E9.97.AE.E9.A2.98"></span><span class="mw-headline" id='"[your_shell]:_No_such_file_or_directory"_/_SSH_认证问题'>"[your shell]: No such file or directory" / SSH 认证问题</span>
</h3>
<p>对于这个问题，一个可能的原因是需要 SSH 客户端在 <code>$SHELL</code> 中提供绝对路径（例如可以通过 <code>whereis -b [your shell]</code> 得到)，即使你的 shell 在 <code>$PATH</code> 里的某个路径中。
</p>
<h3>
<span id=".22Terminal_unknown.22_.E6.88.96_.22Error_opening_terminal.22_.E9.94.99.E8.AF.AF"></span><span class="mw-headline" id='"Terminal_unknown"_或_"Error_opening_terminal"_错误'>"Terminal unknown" 或  "Error opening terminal" 错误</span>
</h3>
<p>如果你在登录时收到上述错误，这意味着服务器无法识别你的终端。使用 Ncurses 的应用程序（如 nano）可能会失败，并显示“Error opening terminal”。
</p>
<p>正确的解决方案是在服务器上安装客户端终端的 terminfo 文件。这会告诉服务器上的控制台程序如何正确地与终端进行交互。你可以使用 <code>$ infocmp</code> 获得关于当前 terminfo 的信息，然后找出 <a href="../en/Pacman.html#Querying_package_databases" title="Pacman">哪个包包括了它们</a>。
</p>
<p>如果你不能正常<a href="../en/Help:Reading.html#Installation_of_packages" class="mw-redirect" title="Install">安装</a>它，可以把 terminfo 复制到服务器上你的主目录里面：
</p>
<pre>$ ssh myserver mkdir -p  ~/.terminfo/${TERM:0:1}
$ scp /usr/share/terminfo/${TERM:0:1}/$TERM myserver:~/.terminfo/${TERM:0:1}/
</pre>
<p>重新登录、登出服务器后这个问题应该已经解决。
</p>
<h4><span class="mw-headline" id="TERM_hack">TERM hack</span></h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>警告：</strong> 这只能作为最后的手段。</div>
<p>你可以在服务器上的环境（例如 <code>.bash_profile</code>）中简单地设置 <code>TERM=xterm</code> 。这将消除错误并允许 ncurses 应用程序再次运行，但除非你的终端的控制序列与 xterm 完全匹配，否则可能会遇到奇怪的行为和图形界面问题。
</p>
<h3>
<span id=".22Connection_closed_by_x.x.x.x_.5Bpreauth.5D.22_.E9.94.99.E8.AF.AF"></span><span class="mw-headline" id='"Connection_closed_by_x.x.x.x_[preauth]"_错误'>"Connection closed by x.x.x.x [preauth]" 错误</span>
</h3>
<p>如果你在 sshd 的 log 里看到这条错误，请确保你已经设置了可用的 HostKey
</p>
<pre>HostKey /etc/ssh/ssh_host_rsa_key
</pre>
<h3>
<span id="id_dsa_.E8.A2.AB_OpenSSH_7.0_.E6.8B.92.E7.BB.9D"></span><span class="mw-headline" id="id_dsa_被_OpenSSH_7.0_拒绝">id_dsa 被 OpenSSH 7.0 拒绝</span>
</h3>
<p>出于安全原因，OpenSSH 7.0 弃用了 DSA 公钥。如果你必须启用它们，请<a href="#%E9%85%8D%E7%BD%AE">设置</a> <code>PubkeyAcceptedKeyTypes +ssh-dss</code> 选项（<a rel="nofollow" class="external free" href="http://www.openssh.com/legacy.html">http://www.openssh.com/legacy.html</a> 没有提到这一点）。
</p>
<h3>
<span id="OpenSSH_7.0_.E7.9A.84_.22No_matching_key_exchange_method_found.22_.E9.94.99.E8.AF.AF"></span><span class="mw-headline" id='OpenSSH_7.0_的_"No_matching_key_exchange_method_found"_错误'>OpenSSH 7.0 的 "No matching key exchange method found" 错误</span>
</h3>
<p>OpenSSH 7.0 弃用了 diffie-hellman-group1-sha1 密钥算法，因为它很弱并且在所谓 Logjam 攻击的理论范围内（参阅http://www.openssh.com/legacy.html）。如果特定主机需要这个密钥算法，ssh 会产生如下错误消息：
</p>
<pre>Unable to negotiate with 127.0.0.1: no matching key exchange method found.
Their offer: diffie-hellman-group1-sha1
</pre>
<p>这个问题的最佳解决方案是将服务器升级/配置为不使用不推荐的算法。如果做不到这一点，可以配置<a href="#%E9%85%8D%E7%BD%AE">客户端选项</a> <code>KexAlgorithms +diffie-hellman-group1-sha1</code> 强制客户端使用这个算法。
</p>
<h3>
<span id=".E6.96.AD.E5.BC.80_SSH_.E8.BF.9E.E6.8E.A5.E6.97.B6_tmux.2Fscreen_.E4.BC.9A.E8.AF.9D.E8.A2.AB.E5.85.B3.E9.97.AD"></span><span class="mw-headline" id="断开_SSH_连接时_tmux/screen_会话被关闭">断开 SSH 连接时 tmux/screen 会话被关闭</span>
</h3>
<p>如果进程在会话结束时被终止，那么你可能是用 ssh.socket 激活的，<span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=systemd">systemd</a></span> 注意到 SSH 会话进程退出，然后杀掉了 tmux/screen 进程。这种情况有两种解决方案。一种是通过使用 <code>ssh.service</code> 来代替 <code>ssh.socket</code> 来避免使用 socket 激活。另一个是在 <code>ssh@.service</code> 的 Service 部分设置 <code>KillMode=process</code>。
</p>
<p>在常规的 <code>ssh.service</code> 里面 <code>KillMode=process</code> 这个选项也是有用的，它可以在 service 停止或重启时防止 SSH 会话进程或 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=screen">screen</a></span> 或 <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=tmux">tmux</a></span> 进程被 kill 掉。
</p>
<h3>
<span id="SSH_.E4.BC.9A.E8.AF.9D.E6.97.A0.E5.93.8D.E5.BA.94"></span><span class="mw-headline" id="SSH_会话无响应">SSH 会话无响应</span>
</h3>
<p>SSH 响应 <a href="https://en.wikipedia.org/wiki/Software_flow_control" class="extiw" title="wikipedia:Software flow control">流控制命令</a> 中的 <code>XON</code> 和 <code>XOFF</code> 命令。 当你按 <code>Ctrl+s</code> 时，它会冻结/挂起/停止响应。按 <code>Ctrl+q</code> 恢复会话。
</p>
<h2>
<span id=".E5.8F.82.E9.98.85"></span><span class="mw-headline" id="参阅">参阅</span>
</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Secure_Shell" class="extiw" title="wikipedia:Secure Shell">Wikipedia:Secure Shell</a></li>
<li><a rel="nofollow" class="external text" href="http://www.la-samhna.de/library/brutessh.html">Defending against brute force ssh attacks</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.ibm.com/developerworks/library/l-keyc/index.html">OpenSSH key management, Part 1</a> and <a rel="nofollow" class="external text" href="http://www.ibm.com/developerworks/library/l-keyc2">Part 2</a> on IBM developerWorks</li>
<li><a rel="nofollow" class="external text" href="https://stribika.github.io/2015/01/04/secure-secure-shell.html">Secure Secure Shell</a></li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../zh-CN/Category:Secure_Shell.html" title="Category:Secure Shell (简体中文)">Secure Shell (简体中文)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../zh-CN/Category:Pages_or_sections_flagged_with_Template:Translateme.html" title="Category:Pages or sections flagged with Template:Translateme (简体中文)">Pages or sections flagged with Template:Translateme (简体中文)</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Merge.html" title="Category:Pages or sections flagged with Template:Merge">Pages or sections flagged with Template:Merge</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Out_of_date.html" title="Category:Pages or sections flagged with Template:Out of date">Pages or sections flagged with Template:Out of date</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Accuracy.html" title="Category:Pages or sections flagged with Template:Accuracy">Pages or sections flagged with Template:Accuracy</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
<li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Style.html" title="Category:Pages or sections flagged with Template:Style">Pages or sections flagged with Template:Style</a></li>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Expansion.html" title="Category:Pages or sections flagged with Template:Expansion">Pages or sections flagged with Template:Expansion</a></li>
<li><a href="../en/Category:Pages_with_broken_package_links.html" title="Category:Pages with broken package links">Pages with broken package links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=OpenSSH_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&amp;oldid=646976">https://wiki.archlinux.org/index.php?title=OpenSSH_(简体中文)&amp;oldid=646976</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 26 December 2020, at 12:20.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
