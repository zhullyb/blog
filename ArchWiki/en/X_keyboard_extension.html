<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>X keyboard extension - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-X_keyboard_extension rootpage-X_keyboard_extension skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">X keyboard extension</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p>The <a href="https://en.wikipedia.org/wiki/X_keyboard_extension" class="extiw" title="wikipedia:X keyboard extension">X keyboard extension</a>, or XKB, defines the way keyboards codes are handled in X, and provides access to internal translation tables. It is the basic mechanism that allows using multiple keyboard layouts in X.
</p>
<p>This article describes how to modify and create keyboard layouts. If you are looking for how to configure your keyboard, see <a href="../en/Xorg/Keyboard_configuration.html" title="Xorg/Keyboard configuration">Xorg/Keyboard configuration</a>.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Precautions_and_preparations"><span class="tocnumber">1</span> <span class="toctext">Precautions and preparations</span></a></li>
<li class="toclevel-1 tocsection-2">
<a href="#Getting_and_setting_XKB_layout"><span class="tocnumber">2</span> <span class="toctext">Getting and setting XKB layout</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Using_rules"><span class="tocnumber">2.1</span> <span class="toctext">Using rules</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Using_keymap"><span class="tocnumber">2.2</span> <span class="toctext">Using keymap</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5">
<a href="#Basic_information_on_XKB"><span class="tocnumber">3</span> <span class="toctext">Basic information on XKB</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Tools_and_values"><span class="tocnumber">3.1</span> <span class="toctext">Tools and values</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Keycode_translation"><span class="tocnumber">3.2</span> <span class="toctext">Keycode translation</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Keysyms_and_states"><span class="tocnumber">3.3</span> <span class="toctext">Keysyms and states</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Actions"><span class="tocnumber">3.4</span> <span class="toctext">Actions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10">
<a href="#Editing_the_layout"><span class="tocnumber">4</span> <span class="toctext">Editing the layout</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#xkb_keycodes"><span class="tocnumber">4.1</span> <span class="toctext">xkb_keycodes</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#xkb_types"><span class="tocnumber">4.2</span> <span class="toctext">xkb_types</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#xkb_compatibility"><span class="tocnumber">4.3</span> <span class="toctext">xkb_compatibility</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#xkb_symbols"><span class="tocnumber">4.4</span> <span class="toctext">xkb_symbols</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#xkb_geometry"><span class="tocnumber">4.5</span> <span class="toctext">xkb_geometry</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16">
<a href="#Basic_examples"><span class="tocnumber">5</span> <span class="toctext">Basic examples</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Simple_key_assignment"><span class="tocnumber">5.1</span> <span class="toctext">Simple key assignment</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Multiple_layouts"><span class="tocnumber">5.2</span> <span class="toctext">Multiple layouts</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Caps_hjkl_as_vimlike_arrow_keys"><span class="tocnumber">5.3</span> <span class="toctext">Caps hjkl as vimlike arrow keys</span></a></li>
<li class="toclevel-2 tocsection-20">
<a href="#Additional_symbols"><span class="tocnumber">5.4</span> <span class="toctext">Additional symbols</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#Compose_key"><span class="tocnumber">5.4.1</span> <span class="toctext">Compose key</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Level3"><span class="tocnumber">5.4.2</span> <span class="toctext">Level3</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23">
<a href="#Meta,_Super_and_Hyper"><span class="tocnumber">5.5</span> <span class="toctext">Meta, Super and Hyper</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="#Real_modifiers"><span class="tocnumber">5.5.1</span> <span class="toctext">Real modifiers</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Keysym_tracking"><span class="tocnumber">5.5.2</span> <span class="toctext">Keysym tracking</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-26">
<a href="#Preset_configuration"><span class="tocnumber">6</span> <span class="toctext">Preset configuration</span></a>
<ul>
<li class="toclevel-2 tocsection-27"><a href="#xmodmap"><span class="tocnumber">6.1</span> <span class="toctext">xmodmap</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="#Indicators"><span class="tocnumber">7</span> <span class="toctext">Indicators</span></a></li>
<li class="toclevel-1 tocsection-29">
<a href="#Modifiers_and_types"><span class="tocnumber">8</span> <span class="toctext">Modifiers and types</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="#Using_real_modifiers_in_standard_types"><span class="tocnumber">8.1</span> <span class="toctext">Using real modifiers in standard types</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Switching_a_single_modifier_bit"><span class="tocnumber">8.2</span> <span class="toctext">Switching a single modifier bit</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#modifier_map"><span class="tocnumber">8.3</span> <span class="toctext">modifier_map</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="#Multiple_keyboards"><span class="tocnumber">9</span> <span class="toctext">Multiple keyboards</span></a></li>
<li class="toclevel-1 tocsection-34"><a href="#Debugging_XKB"><span class="tocnumber">10</span> <span class="toctext">Debugging XKB</span></a></li>
<li class="toclevel-1 tocsection-35">
<a href="#Virtual_Modifiers"><span class="tocnumber">11</span> <span class="toctext">Virtual Modifiers</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#Defining_virtual_modifiers"><span class="tocnumber">11.1</span> <span class="toctext">Defining virtual modifiers</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#Keysym_interpretation"><span class="tocnumber">11.2</span> <span class="toctext">Keysym interpretation</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#Client_side_notes"><span class="tocnumber">11.3</span> <span class="toctext">Client side notes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-39">
<a href="#XKB_control_bits"><span class="tocnumber">12</span> <span class="toctext">XKB control bits</span></a>
<ul>
<li class="toclevel-2 tocsection-40"><a href="#Mouse_control"><span class="tocnumber">12.1</span> <span class="toctext">Mouse control</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-41"><a href="#Local_XKB_folder"><span class="tocnumber">13</span> <span class="toctext">Local XKB folder</span></a></li>
<li class="toclevel-1 tocsection-42">
<a href="#Troubleshooting"><span class="tocnumber">14</span> <span class="toctext">Troubleshooting</span></a>
<ul>
<li class="toclevel-2 tocsection-43"><a href="#I_have_an_USB_keyboard_and_the_settings_get_lost_upon_unplugging_it"><span class="tocnumber">14.1</span> <span class="toctext">I have an USB keyboard and the settings get lost upon unplugging it</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-44"><a href="#See_also"><span class="tocnumber">15</span> <span class="toctext">See also</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Precautions_and_preparations">Precautions and preparations</span></h2>
<p>It is easy to end up disabling some keys on your keyboard for the current X session while working with XKB. Make sure you have some way to terminate the session without using your keyboard.
</p>
<p>While it is rare, changing XKB configuration can sometimes hang or crash X server. Make sure you can handle it. Having some way to killall X or reboot the host remotely may be a good idea.
</p>
<p>Stop <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xxkb">xxkb</a></span>, or any other layout switching applications. xxkb actively changes XKB state. Debugging both at the same time is not a good idea.
</p>
<h2><span class="mw-headline" id="Getting_and_setting_XKB_layout">Getting and setting XKB layout</span></h2>
<h3><span class="mw-headline" id="Using_rules">Using rules</span></h3>
<p>Look inside <code>/usr/share/X11/xkb/rules/</code> for <code>*.lst</code> files or the <a rel="nofollow" class="external text" href="http://www.x.org/wiki/XKB/">XKB Homepage</a> to get ideas on how to configure rules. Your own configurations can go in <code>/etc/X11/xorg.conf.d/</code>.
</p>
<p>For example one may want to remap their <code>Caps Lock</code> key to <code>Escape</code>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">90-custom-kbd.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Section "InputClass"
    Identifier "keyboard defaults"
    MatchIsKeyboard "on"

    Option "XKbOptions" "caps:escape"
EndSection
</pre>
<h3><span class="mw-headline" id="Using_keymap">Using keymap</span></h3>
<p>Use <span class="plainlinks archwiki-template-man" title="$ man 1 xkbcomp"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/xkbcomp.1">xkbcomp(1)</a></span> (package <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xkbcomp">xorg-xkbcomp</a></span>) to manipulate XKB data. To get current configuration, run
</p>
<pre>   xkbcomp $DISPLAY output.xkb
</pre>
<p>To upload the data back to the server, run
</p>
<pre>   xkbcomp input.xkb $DISPLAY
</pre>
<p>Note that without <code>$DISPLAY</code> argument xkbcomp will try to compile .xkb file into (mostly useless) .xkm file, without uploading anything to the server. It will, however, check the syntax and report errors.
</p>
<p>Once the layout is ready, save it as <code>~/.Xkeymap</code> and make <code>~/.xinitrc</code> load it on startup:
</p>
<pre>   test -f ~/.Xkeymap &amp;&amp; xkbcomp ~/.Xkeymap $DISPLAY
</pre>
<p>The actual file name is irrelevant. Note that unlike standard system-wide configuration via <code>xorg.conf</code>, this is a per-user keymap. Also, there is no problem changing XKB configuration while X is running.
</p>
<h2><span class="mw-headline" id="Basic_information_on_XKB">Basic information on XKB</span></h2>
<p>The core XKB functionality is quite simple, and it's necessary to have a some ideas on how it works before starting working on the keymaps.
</p>
<h3><span class="mw-headline" id="Tools_and_values">Tools and values</span></h3>
<p>Use <a href="../en/Keyboard_input.html#Identifying_keycodes_in_Xorg" class="mw-redirect" title="Xev">xev</a> (package <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xev">xorg-xev</a></span>) to get keycodes and to check how your keymap works. 
</p>
<pre>$ xev -event keyboard
</pre>
<p>Sample output:
</p>
<pre>   KeyPress event, serial 45, synthetic NO, window 0x2200001,
       root 0xad, subw 0x0, time 183176240, (796,109), root:(867,413),
       state 0x1, keycode 21 (keysym 0x2b, plus), same_screen YES,
       XLookupString gives 1 bytes: (2b) "+"
       XmbLookupString gives 1 bytes: (2b) "+"
       XFilterEvent returns: False
</pre>
<p>Note keycode 21, state 0x1 and keysym 0x2b aka plus. Keycode 21 is what input device supplied to X, typically a physical key index of some sort. The state represents modifier keys, 0x01 is Shift. Keycode together with the state value is what X sends to the application in <span class="plainlinks archwiki-template-man" title="$ man 3 XKeyEvent"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/XKeyEvent.3">XKeyEvent(3)</a></span> structure. Keysym and corresponding string is what the client obtained using <span class="plainlinks archwiki-template-man" title="$ man 3 XLookupString"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/XLookupString.3">XLookupString(3)</a></span> and friends.
</p>
<p>The bits in the state field have pre-defined names: <code>Shift</code>, <code>Lock</code>, <code>Control</code>, <code>Mod1</code>, <code>Mod2</code>, <code>Mod3</code>, <code>Mod4</code> and <code>Mod5</code>, lowest to highest. Thus, <code>Ctrl+Shift</code> is 0x05, and so on. Client applications typically only check the bits they need, so an application with normal keyboard input and <code>Ctrl+key</code> shortcuts usually makes no distinction between <code>Control</code> and <code>Control+Mod3</code> states.
</p>
<p>Keysyms are numeric, too. A lot of them have names, declared in <code>/usr/include/X11/keysymdef.h</code> with <code>KP_</code> prefix. However, the number is what clients actually receive. Keysyms are only important when an application expects some particular values; typically that is keys like arrows, Enter, Backspace, F-keys, and various shortcuts. For the rest, the string is used.
</p>
<h3><span class="mw-headline" id="Keycode_translation">Keycode translation</span></h3>
<p>XKB works mostly at the XLookupString stage, transforming incoming keycode into keysym according to its own internal state, which is  group and state values:
</p>
<pre>   (keycode, group, state) → keysym
</pre>
<p>Group typically represents a "layout", as in US-English, French-AZERTY, Russian, Greek etc. There can be at most 4 groups.
</p>
<p>Internally, the translation involves additional steps:
</p>
<pre>   (keycode [, group]) → type
   (state, type) → level
   (keycode, group, level) → S[keycode][group][level]
</pre>
<p>with <code>S</code> being the translation table (actually called <code>xkb_symbols</code>, see below).
</p>
<p>Types are used to tell which modifiers affect which keys; essentially it's a way to reduce the third dimension of <code>S</code>. For example, a typical alphanumeric key is only affected by <code>Shift</code>, so its type is set to <code>TWO_LEVEL</code>, and
</p>
<pre>   (state, TWO_LEVEL) → level = ((state &gt;&gt; 0) &amp; 0x01) = state &amp; 0x01
</pre>
<p>is either 0 or 1. Thus it's <code>S[keycode][0..4][0..1]</code> instead of <code>S[keycode][0..4][0..256]</code>.
</p>
<h3><span class="mw-headline" id="Keysyms_and_states">Keysyms and states</span></h3>
<p>In X terms, <code>a</code> and <code>Ctrl+a</code> means same keysym and different states, but <code>a</code> and <code>A</code> are different keysyms.
</p>
<p>Generally it is XKB task to provide different keysyms, but states are handled later by individual applications.
</p>
<p>Also, states in XKB have somewhat delayed effect, that is, you must have the state set prior to pressing a key.
</p>
<p>Example: <code>Ctrl+h</code> can be configured to act as backspace in <a href="../en/Rxvt-unicode.html" class="mw-redirect" title="Rxvt">rxvt</a> (application setting). This way rxvt will receive <code>h</code> keysym with <code>Control</code> bit set in the state value, and it will be clearly different from <code>Backspace</code> keysym. Alternatively, XKB can be used to make <code>Ctrl+h</code> combination generate <code>Backspace</code> keysym with <code>Control</code> bit set; in this case, rxvt will not see any difference between physical <code>Backspace</code> key and <code>h</code> key as long as <code>Ctrl</code> key is pressed. Making <code>Ctrl+h</code> combination generate <code>Backspace</code> keysym with no <code>Control</code> bit set is an XKB task, too, but it's much more difficult to implement than <code>Control+Backspace</code>.
</p>
<h3><span class="mw-headline" id="Actions">Actions</span></h3>
<p>Keysym obtained from the table above can also trigger some action:
</p>
<pre>   (keysym, state) → action
</pre>
<p>For XKB, setting or locking a modifier bit is an action, and so is any X server interaction like switching consoles, terminating the server, moving pointer etc. Actions do not generally affect keysyms, and generating a keysym is not an action.
</p>
<p>There is only one possible action for each (keysym, state) pair.
</p>
<h2><span class="mw-headline" id="Editing_the_layout">Editing the layout</span></h2>
<p>Start with whatever default configuration your server has. Whenever possible, make the changes gradually and test them.
</p>
<p>The .xkb file produced by xkbcomp is a simple text file. C++ style comments, // till the end of line, are allowed.  Section names, as in xkb_keycodes "name-here", are irrelevant at this point and can be omitted.
</p>
<h3><span class="mw-headline" id="xkb_keycodes">xkb_keycodes</span></h3>
<p>Keycode definition. The rest of the file does not use numeric keycodes, only symbolic keylabels defined in this section.
</p>
<p>It's a good idea to leave only those keys the keyboard in question actually has here.
</p>
<p>The labels themselves are arbitrary. They are only used in xkb_symbols section later.
</p>
<h3><span class="mw-headline" id="xkb_types">xkb_types</span></h3>
<p>This section comes before xkb_symbols, so take a look, but try not to make changes yet. Standard types depend a lot on virtual modifiers, which will be explained later. For now, just find the types you need. Start with the following: ONE_LEVEL, TWO_LEVEL, ALPHABETIC.
</p>
<p>ONE_LEVEL keys are not affected by modifiers; typically it's Enter, Space, Escape, F keys, Shift/Alt/Ctrl keys and so on. TWO_LEVEL and ALPHABETIC keys produce different keysyms depending on Shift state. All alphanumeric keys are of these types. ALPHABETIC additionally respects CapsLock.
</p>
<p>Type description themselves are quite simple. The line
</p>
<pre>   modifiers= Shift+NumLock+LevelThree;
</pre>
<p>means keys of this type are affected by Shift, NumLock and LevelThree bits only. Map lines like
</p>
<pre>   map[Shift+LevelThree]= Level4;
</pre>
<p>define which combination corresponds to which level value. xkbcomp uses "LevelN" when dumping the data, but short and much more convenient "N" can be used as well.
</p>
<p>level_name lines are irrelevant and can be ignored.
</p>
<h3><span class="mw-headline" id="xkb_compatibility">xkb_compatibility</span></h3>
<p>Action definitions (<code>interpret</code>) and keyboard LEDs (<code>indicator</code>) among other things. You can remove stuff you do not have or do not use, like keypad actions, mouse control or extra modifiers.
</p>
<p>Note that <code>key+AnyOfOrNone(all)</code> is equivalent to just <code>key</code>, but <code>key</code> is much easier to read.
</p>
<p>Check groups switching if you need it. <code>LockGroup(group=N)</code> can be useful if you have four groups, otherwise <code>ISO_Next_Group</code>/<code>ISO_Prev_Group</code> are enough. <code>LatchGroup</code> can be useful for unusual setups.
</p>
<h3><span class="mw-headline" id="xkb_symbols">xkb_symbols</span></h3>
<p>The main section that defines what each key does. Syntax:
</p>
<pre>   key &lt;LABL&gt; { [ G1L1, G1L2, G1L3, ... ], [ G2L1, G2L2, G2L3, ... ], ... }
</pre>
<p><code>&lt;LABL&gt;</code> is keylabel from xkb_keycodes section, <code>GiLj</code> is keysym for group i level j. The number of keysyms in each group must match the number of levels defined for this type (<code>xkbcomp</code> will warn you if it does not).
</p>
<p>Check <code>/usr/include/X11/keysymdef.h</code> for the list of possible keysyms. Aside from those listed, you can also use <code>Unnnn</code> for Unicode symbol with hex code nnnn, e.g. <code>U0301</code> for combining acute accent. Note that <code>a</code> and <code>U0061</code> are treated differently (for instance, most applications expect <code>Ctrl+a</code>, not <code>Ctrl+U0061</code> because their numeric values are different.
</p>
<p>Key types are also specified here, either as
</p>
<pre>   key.type = "T1";
   key &lt;...&gt; { ... };
   key &lt;...&gt; { ... };
   key &lt;...&gt; { ... };
   key.type = "T2";
   key &lt;...&gt; { ... };
   key &lt;...&gt; { ... };
</pre>
<p>or individually for each key:
</p>
<pre>   key &lt;...&gt; { type = "T", [ .... ], [ .... ] };
</pre>
<p>Key type may be different in different groups. This is somewhat counter-intuitive, but actually has some useful applications. To set types for each group, use this:
</p>
<pre>   key &lt;...&gt; { type[1] = "T1", type[2] = "T2", [ ... ], [ ... ] };
</pre>
<p>You can set labels for the groups using
</p>
<pre>   name[1] = "EN";     // group 1
   name[2] = "RU";     // group 2
   name[3] = "UA";     // group 3
</pre>
<p>This is what xxkb will show if labels are enabled there.
</p>
<p>The section also contains <code>modifier_map</code> lines. Leave them alone for now, or check Virtual Modifiers below.
</p>
<h3><span class="mw-headline" id="xkb_geometry">xkb_geometry</span></h3>
<p>A completely irrelevant section describing physical keyboard layout. Can be deleted without any consequences.
</p>
<h2><span class="mw-headline" id="Basic_examples">Basic examples</span></h2>
<p>Check your existing layout first, as it likely contains standard definition for many common keys.
</p>
<p>Throughout the text, "xkb_keycodes { text }" means "text" should be added to xkb_keycodes section. Whenever it's clear from context, section names are omitted.
</p>
<h3><span class="mw-headline" id="Simple_key_assignment">Simple key assignment</span></h3>
<p>Enabling additional (aka multimedia) keys:
</p>
<pre>   xkb_keycodes {
       &lt;VOL-&gt; = 122;       // check with xev
       &lt;VOL+&gt; = 123;
   }
   
   xkb_symbols {
       key.type = "ONE_LEVEL";
       key &lt;VOL-&gt; { [ XF86AudioLowerVolume ] };
       key &lt;VOL+&gt; { [ XF86AudioRaiseVolume ] };
   }
</pre>
<p>Escape on CapsLock, for Vim users mostly:
</p>
<pre>   key.type = "ONE_LEVEL";
   key &lt;CAPS&gt; { [ Escape ] };
</pre>
<p>Exchanging Ins and PrintScreen (in case they are reversed — happens on Dell laptop keyboards):
</p>
<pre>   key.type = "ONE_LEVEL";
   key &lt;IN?&gt;  { [    Print ] };
   key &lt;PRSC&gt; { [   Insert ] };
</pre>
<p>On some HP laptop keyboards, the above does not work. Instead, the keycodes themselves must be redefined:
</p>
<pre>   partial xkb_keycodes "insert" {
       alias &lt;I118&gt; = &lt;IN?&gt;;
       &lt;INS&gt;  = 218;
       &lt;I218&gt; = 118;
   };
</pre>
<p>Changing shift to a sticky key version:
</p>
<p>replace
</p>
<pre>   key &lt;LFSH&gt; {         [         Shift_L ] };
</pre>
<p>with
</p>
<pre>   key &lt;LFSH&gt; {         [         ISO_Level2_Latch ] };
</pre>
<p>You might also need to add the following to <code>/usr/share/X11/xkb/compat/basic</code>
</p>
<pre>   interpret ISO_Level2_Latch+AnyOf(all) {
       useModMapMods=level1;
       action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
   };
   interpret ISO_Level2_Latch+AnyOfOrNone(all) {
       action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
   };
</pre>
<h3><span class="mw-headline" id="Multiple_layouts">Multiple layouts</span></h3>
<p>For regular alphanumeric keys, just add a second/third/fourth [ ] section to the key definition:
</p>
<pre>   key.type = "ALPHABETIC";
   key &lt;AD01&gt; { [ q, Q ], [ a, A ] };      // QWERTY-AZERTY
</pre>
<pre>   key &lt;AC02&gt; { [        s,        S ],        // two cyrillic layouts
                [    U044B,    U042B ],
                [    U0456,    U0406 ] };
</pre>
<p>Layout switching is done by triggering action LockGroup:
</p>
<pre>   interpret ISO_Next_Group { action = LockGroup(group=+1); };
   interpret ISO_Prev_Group { action = LockGroup(group=-1); };
</pre>
<p>Typically this means placing ISO_Next_Group and ISO_Prev_Group keysyms in correct group/level positions. Note that groups wrap, so if you have two groups and hit ISO_Next_Group twice, you will return to the group you started with.
</p>
<p>Cyclic switching between two or more layouts with a dedicated key:
</p>
<pre>   key.type = "ONE_LEVEL";
   key &lt;RWIN&gt; { [ ISO_Next_Group ] }
</pre>
<p>If you have more than two layouts and some keys to spare, it may be a better idea to have a dedicated key for each layout. Example for three layouts:
</p>
<pre>   key.type = "ONE_LEVEL";
   key &lt;RCTL&gt; { [ ISO_Next_Group ],    // g1: switch to g2
                [ ISO_Prev_Group ],    // g2: switch back to g1
                [ ISO_Prev_Group ] };  // g3: switch to g2
</pre>
<pre>   key &lt;MENU&gt; { [ ISO_Prev_Group ],    // g1: switch to g3
                [ ISO_Next_Group ],    // g2: switch to g3
                [ ISO_Next_Group ] };  // g3: switch back to g1
</pre>
<p>With four layouts, you will likely have to use ISO_First_Group and ISO_Last_Group.
</p>
<p>The same idea can be implemented with only one key by utilizing TWO_LEVEL type:
</p>
<pre>   key.type = "TWO_LEVEL";
   key &lt;MENU&gt; { [ ISO_Next_Group, ISO_Prev_Group ],   
                [ ISO_Prev_Group, ISO_Next_Group ],   
                [ ISO_Prev_Group, ISO_Next_Group ] }; 
</pre>
<p>This way it's Menu for group 2 and Shift-Menu for group 3. To use Ctrl or Alt instead of Shift, replace TWO_LEVEL with PC_CONTROL_LEVEL2 or PC_ALT_LEVEL2 types respectively.
</p>
<p>Switching using two modifier keys (Shift+Shift, Ctrl+Shift etc) can be done by using something other than ONE_LEVEL for these keys. Shift+Shift example:
</p>
<pre>   key.type = "TWO_LEVEL";
   key &lt;LFSH&gt; { [ Shift_L, ISO_Prev_Group ] };
   key &lt;RTSH&gt; { [ Shift_R, ISO_Next_Group ] };
</pre>
<p>To latch a group (aka toggle; set for the time you hold the key only), use LatchGroup action typically bound to ISO_Group_Latch keysym:
</p>
<pre>   key &lt;RCTL&gt; { [ ISO_Group_Latch ] }
</pre>
<p>Adjust ISO_Group_Latch definition in xkb_compatibility section to use the right group:
</p>
<pre>   interpret ISO_Group_Latch { action = LatchGroup(group=3); };
</pre>
<p>Check /usr/share/X11/xkb/symbols/group for more standard examples.
</p>
<h3><span class="mw-headline" id="Caps_hjkl_as_vimlike_arrow_keys">Caps hjkl as vimlike arrow keys</span></h3>
<div class="noprint archwiki-template-message">
<p><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a><b>This article or section needs language, wiki syntax or style improvements. See <a href="../en/Help:Style.html" title="Help:Style">Help:Style</a> for reference.</b><a href="../File:Tango-edit-clear.png" class="image"><img alt="Tango-edit-clear.png" src="../File:Tango-edit-clear.png" decoding="async" width="48" height="48"></a></p>
<div>
<b>Reason:</b>  The purpose of this section is not clear. (Discuss in <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:X_keyboard_extension">Talk:X keyboard extension#</a>)</div>
</div>
<p>Creating keymappings that clear modifiers from the keypress is necessary if the target key is to be used in keyboard shortcuts. For instance, highlighting text from the main keyboard (<code>Shift+Left</code>), or changing chats in most messengers (<code>Alt+Down</code>) will not work if there is an additional <code>Caps</code> modifier sent. However, an additional modifier must be sent if a user rebinds a letter key by simply putting the keysym in the symbols section. Rebinding as follows permits functionality like AHK's blind command.
</p>
<p>The <code>types</code> section (which defines layer mapping) must contain an entry such that:
</p>
<ul>
<li>When no modifiers are pressed, the first level of keysyms is used (lowercase letters).</li>
<li>When Shift only is pressed, the second level of keysyms is used (capital letters).</li>
<li>When Lock only is pressed, the third level of keysyms is used (the arrow keys)</li>
<li>When Shift and Lock are pressed, the third level of keysyms is also used (shift+arrow keys).</li>
</ul>
<p>Add this to the bottom of your types section:
</p>
<pre> xkb_types "complete" {
   ...
   type "CUST_CAPSLOCK" {
       modifiers= Shift+Lock; 
       map[Shift] = Level2;            //maps shift and no Lock. Shift+Alt goes here, too, because Alt isn't in modifiers.
       map[Lock] = Level3;
       map[Shift+Lock] = Level3;       //maps shift and Lock. Shift+Lock+Alt goes here, too.
       level_name[Level1]= "Base";
       level_name[Level2]= "Shift";
       level_name[Level3]= "Lock";
   };
 };
</pre>
<p>Now change caps from a lock (toggle) to a set (press) by modifying the already existing definition in compatability from LockMods to SetMods:
</p>
<p>(Note that this means you can't use capslock like normal)
</p>
<pre> xkb_compatibility "complete" {
   ...
   interpret Caps_Lock+AnyOfOrNone(all) {
       action= SetMods(modifiers=Lock);
   };
   ...
 };
</pre>
<p>Finally, modify your symbols file as follows.
</p>
<pre> xkb_symbols "pc_us_inet(evdev)" {
   ...
   key &lt;AC06&gt; {
       type= "CUST_CAPSLOCK",
       symbols[Group1]= [               h,               H,               Left],
       actions[Group1]= [      NoAction(),      NoAction(),   RedirectKey(keycode=&lt;LEFT&gt;, clearmods=Lock) ]
  };
</pre>
<h3><span class="mw-headline" id="Additional_symbols">Additional symbols</span></h3>
<p>Typing more with the same keys.
</p>
<h4><span class="mw-headline" id="Compose_key">Compose key</span></h4>
<p>Easy to set up and extremely useful for entering common Unicode characters.
</p>
<pre>   key &lt;RALT&gt; { [ Multi_key ] };
</pre>
<h4><span class="mw-headline" id="Level3">Level3</span></h4>
<p>The idea is similar to Alt or AltGr in their original meaning: alphanumeric keys get additional characters, activated by holding down some modifier key.
</p>
<p>First of all, setting up the modifier.
</p>
<pre>   xkb_symbols { 
       key &lt;LWIN&gt; { [ISO_Level3_Shift ] };
       modifier_map Mod5 { ISO_Level3_Shift };
   }
</pre>
<p>Also, the following should already be defined in the relevant sections, but in case it is not:
</p>
<pre>   xkb_compatibility {
       interpret ISO_Level3_Shift { action= SetMods(modifiers=Mod5); };
   }
   
   xkb_types {
       type "THREE_LEVEL" {
           modifiers= Shift+Mod5;
           map[Shift]= Level2;
           map[Mod5]= Level3;
           map[Shift+Mod5]= Level3;
           level_name[Level1]= "Base";
           level_name[Level2]= "Shift";
           level_name[Level3]= "Level3";
       };
       type "FOUR_LEVEL" {
           modifiers= Shift+LevelThree;
           map[Shift]= Level2;
           map[LevelThree]= Level3;
           map[Shift+LevelThree]= Level4;
           level_name[Level1]= "Base";
           level_name[Level2]= "Shift";
           level_name[Level3]= "Alt Base";
           level_name[Level4]= "Shift Alt";
       };
   }
</pre>
<p>Note standard definitions have LevelThree instead of Mod5 in xkb_compatibility and xkb_types. As long as modifier_map above uses Mod5, there is no practical difference, you will end up using Mod5 bit anyway.
</p>
<p>Now, the keys themselves, vi-style cursors in this case:
</p>
<pre>   key.type = "THREE_LEVEL";
   key &lt;AC06&gt; { [ h, H,  Left ] };
   key &lt;AC07&gt; { [ j, J,  Down ] };
   key &lt;AC08&gt; { [ k, K,    Up ] };
   key &lt;AC09&gt; { [ l, L, Right ] };
</pre>
<p>As you may find out using xev, this produces Mod5+Left instead of just Left. But that is ok as most applications ignore state bits they do not use. For an alternative solution, check Overlays below.
</p>
<h3>
<span id="Meta.2C_Super_and_Hyper"></span><span class="mw-headline" id="Meta,_Super_and_Hyper">Meta, Super and Hyper</span>
</h3>
<h4><span class="mw-headline" id="Real_modifiers">Real modifiers</span></h4>
<p>Some applications (notably Emacs) allow meaningful use of higher state bits. It is usually assumed there are modifier keys called Meta, Super and Hyper on the keyboard beside standard Shift, Ctrl and Alt, which control these bits.
</p>
<p>From XKB point of view this means setting Mod2, Mod3, Mod4 and Mod5 modifier bits. Because all you need is the bits themselves, there is no need to edit types like in the Level3 example above.
</p>
<pre>   xkb_compatibility {
       interpret Super_L { action = SetMods(modifiers=Mod3); };
   }
</pre>
<pre>   xkb_symbols {
       key &lt;LWIN&gt; { [ Super_L ] };
       modifier_map Mod3 { Super_L };
   }
</pre>
<p>Standard definitions use Super modifier instead of Mod3 in <code>xkb_compatibility</code>. You can keep that, just make sure <code>modifier_map</code> line is in place.
</p>
<p>Keep in mind there is no strict correspondence between ModN and named modifiers like Super, Hyper or even Alt. Mod1 is the only one that is widely used; some applications call it Meta, some Alt. For the others, check how particular application treats state bits, and/or check Virtual modifiers below.
</p>
<h4><span class="mw-headline" id="Keysym_tracking">Keysym tracking</span></h4>
<p>At least one application (openbox) is known to track KeyPress/KeyRelease events for Meta_[LR], Super_[LR] and Hyper_[LR] keysyms instead of relying on the state bits. In such case
</p>
<pre>   xkb_symbols {
       key &lt;LWIN&gt; { [ Super_L ] };
   }
</pre>
<p>is enough and you can omit <code>interpret</code> and <code>modifier_map</code> lines.
</p>
<p>Speaking of Openbox, note it actually allows both methods: "S-h" tracks Super_[LR] events while "Mod3-h" checks relevant state bit.
</p>
<h2><span class="mw-headline" id="Preset_configuration">Preset configuration</span></h2>
<p>XKB is often configured by specifying XkbTypes/XkbCompat/XkbSymbols, or XkbModel/XkbLayout (+XkbVariant/XkbOptions), or XkbKeymap, typically in /etc/X11/xorg.conf or /etc/X11/xorg.conf.d/*.conf, like this:
</p>
<pre>   Option  "XkbModel"    "thinkpad60"                                                                                                  
   Option  "XkbLayout"   "us,sk,de"                                                                                                    
   Option  "XkbVariant"  "altgr-intl,qwerty,"                                                                                          
   Option  "XkbOptions"  "grp:menu_toggle,grp_led:caps"        
</pre>
<p>These values define full XKB map (the one that can be dumped by xkbcomp) by combining several files from <code>/usr/share/X11/xkb</code>. In fact, equivalent .xkb file for xkbcomp can be obtained using <code>setxkbmap -print</code>:
</p>
<pre>   setxkbmap -model thinkpad60 -layout us,sk,de -variant altgr-intl,qwerty \
       -option -option grp:menu_toggle -option grp_led:caps -print
</pre>
<p>Note include statements in the output. The files for each section are fetched from relevant subdirectories under <code>/usr/share/X11/xkb</code>, i.e.
</p>
<pre>   xkb_types { include "complete" };
</pre>
<p>means xkbcomp will look for <code>/usr/share/X11/xkb/types/complete</code>. Plus signs mean concatenation, so
</p>
<pre>   xkb_keycodes { include "evdev+aliases(qwerty)" };
</pre>
<p>means 
</p>
<pre>   xkb_keycodes {
       include "evdev";
       include "aliases(qwerty)";
   };
</pre>
<p>Parenthesis select named section from the file. Check <code>/usr/share/X11/xkb/keycodes/aliases</code> and note
</p>
<pre>   xkb_keycodes "qwerty" { ... };
</pre>
<p>this is the part <code>aliases(qwerty)</code> refers to. Finally, colons allow shifting parts of layout to another group.
</p>
<p>Unlike XkbTypes/XkbCompat/XkbSymbols/XkbGeometry values, which define relevant .xkb file sections directly, XkbModel, XkbLayout and XkbRules refer to additional non-xkb files found under <code>/usr/share/X11/xkb/rules/</code> that match model and layout values to specific symbols and geometry. XkbKeymap refers to complete keymaps. Check Ivan Pascal page for detailed description.
</p>
<p>Just like with xkbcomp approach, this kind of configuration can be done on the fly: use setxkbmap without -print option.
</p>
<p>The files from <code>/usr/share/X11/xkb</code> are a good source of examples, especially when it comes to standard keyboard features with nontrivial XKB implementation (e.g. keypad/NumLock handling). Also, these are the files you have to edit to push your changes upstream. Check <a rel="nofollow" class="external text" href="https://www.freedesktop.org/wiki/Software/XKeyboardConfig/Rules">X Keyboard Config Rules</a> before doing it though.
</p>
<h3><span class="mw-headline" id="xmodmap">xmodmap</span></h3>
<p>While sometimes used in conjunction with preset configuration, <a href="../en/Xmodmap.html" title="Xmodmap">xmodmap</a> is not directly related to XKB. This tool uses different (pre-XKB) ideas on how keycodes are processed within X; in particular, xmodmap lacks the notion of groups and types, so trying to set more than one keysym per key is not likely to work.
</p>
<p>Generally it is not recommended to use xmodmap, except maybe for the simplest tasks. XKB-compatible equivalent of xmodmap is xkbcomp; however, xkbcomp lacks -e option, so it is not that simple. Anyway, whenever possible, xkbcomp should be preferred.
</p>
<h2><span class="mw-headline" id="Indicators">Indicators</span></h2>
<p>As in "keyboard LEDs". Indicator names are used to match the to the physical LEDs in xkb_keycodes section. Otherwise, they are irrelevant. Indicators not matched to any LED are called "virtual"; xkbvleds (package <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xkbutils">xorg-xkbutils</a></span>) can be used to check their state. Example:
</p>
<pre>   xkb_keycodes {
       indicator 1 = "LED1";       // first physical LED
   }
</pre>
<p>Indicators always reflect specified part of XKB internal state. Two common modes is showing modifier state:
</p>
<pre>   xkb_compatibility {
       indicator "LED1" { modifiers = Lock; }; // CapsLock indicator
   }
</pre>
<p>or current group:
</p>
<pre>   xkb_compatibility {
       indicator "LED1" { groups = 0x06; };    // "group 2 or group 3 is active"
   }
</pre>
<p>The values are bitmasks. For groups, bit 1 is group 1, bit 2 is group 2 and so on.
</p>
<h2><span class="mw-headline" id="Modifiers_and_types">Modifiers and types</span></h2>
<p>At some point it may become necessary to clean up types section, and/or to introduce unusual types.
</p>
<p>Types and modifiers are tightly connected, so it makes a lot of sense to start with the modifier bits first, before doing anything with the type descriptions.
</p>
<p>Decide which bits you will use. There are only eight of them, and of those, Shift, Control and Mod1 are widely used in applications, and Lock (aka CapsLock) has pre-defined meaning which also may be hard to override. The remaining four, however, are fair play.
</p>
<p>Warning: four standard types, ONE_LEVEL, TWO_LEVEL, ALPHABETIC and KEYPAD, receive special treatment in xkbcomp. They may work differently just because they are named this way. Avoid deleting them. If some changes do not work as expected, try adding a new type instead.
</p>
<h3><span class="mw-headline" id="Using_real_modifiers_in_standard_types">Using real modifiers in standard types</span></h3>
<p>Depending of your base configuration, there may be a lot of unused standard types like EIGHT_LEVEL or PC_RCONTROL_LEVEL2. Remove them to avoid doing unnecessary work.
</p>
<p>Now, some standard types use virtual modifiers. If you decide to use them, check Virtual modifiers below and skip this section. Otherwise, it's a good idea to get rid of them completely. Check the types you need, and either replace them with corresponding real ones, or remove relevant definitions. Example:
</p>
<pre>   type "KEYPAD" {
       modifiers= Shift+NumLock;
       map[Shift]= Level2;
       map[NumLock]= Level2;
       level_name[Level1]= "Base";
       level_name[Level2]= "Number";
   };
</pre>
<p>if you use Mod2 for NumLock, change the type to
</p>
<pre>   type "KEYPAD" {
       modifiers= Shift+Mod2;
       map[Shift]= Level2;
       map[Mod2]= Level2;
       level_name[Level1]= "Base";
       level_name[Level2]= "Number";
   };
</pre>
<p>if you are not going to have NumLock modifier, change it to
</p>
<pre>   type "KEYPAD" {
       modifiers= Shift;
       map[Shift]= Level2;
       level_name[Level1]= "Base";
       level_name[Level2]= "Number";
   };
</pre>
<p>Do the same in xkb_compatibility section too. Once it's done, you should be able to remove all "virtual_modifiers" lines in the file.
</p>
<h3><span class="mw-headline" id="Switching_a_single_modifier_bit">Switching a single modifier bit</span></h3>
<p>Basically all you need is a keysym with a relevant interpretation entry. Example for Mod5 switching with <code>LWIN</code> key, with <code>ISO_Level3_Shift</code> for keysym:
</p>
<pre>   xkb_compatibility {
       interpret ISO_Level3_Shift { action = SetMods(modifiers=Mod5); };
   }
   
   xkb_symbols {
       key &lt;LWIN&gt; { [ISO_Level3_Shift ] };
   }
</pre>
<p>Aside from <code>SetMods</code>, you can also use <code>LockMods</code> or <code>LatchMods</code>. <code>SetMods</code> makes a regular "on while pressed" modifier key. <code>LockMods</code> makes an "on/off" switch like CapsLock or NumLock. <code>LatchMods</code> means "on until next keypress" aka sticky modifier
</p>
<h3><span class="mw-headline" id="modifier_map">modifier_map</span></h3>
<p>Modifier map is a table that maps each of eight modifier bits to at most 4 keys:
</p>
<pre>   modifier_map Mod1 { Alt_L, Alt_R };
</pre>
<p>In the core protocol, without XKB, it means more or less the same thing as
</p>
<pre>   interpret Alt_L { action = SetMods(modifiers=Mod1); };
   interpret Alt_R { action = SetMods(modifiers=Mod1); };
</pre>
<p>XKB does not use modifier map in its original meaning. Within XKB, its only function is to map virtual modifiers (see below).
</p>
<p>However, the table is easily accessible by clients, and there is one counter-intuitive (but well-known) trick involving it: modifier map is used to tell which of ModX bits is Alt. Because of this, it is a good idea to have one modifier mapped to Alt_L or Alt_R as shown above. Unless you have very good reasons to do otherwise, it should be Mod1.
</p>
<h2><span class="mw-headline" id="Multiple_keyboards">Multiple keyboards</span></h2>
<p>XKB allows setting keymap for a single connected physical keyboard only. This feature can be extremely useful for multi-keyboard setups when keyboards in question are different; consider a laptop with a full-size USB keyboard attached.
</p>
<p>First of all, use xinput (package <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=xorg-xinput">xorg-xinput</a></span>) to get device IDs:
</p>
<pre>   AT Translated Set 2 keyboard                id=11   [slave  keyboard (3)]
</pre>
<p>Now,
</p>
<pre>   xkbcomp -i 11 file.xkb $DISPLAY
</pre>
<p>or
</p>
<pre>   setxkbmap -device 11 ...
</pre>
<p>will set keymap for specified keyboard only. Dumping XKB configuration works too:
</p>
<pre>   xkbcomp -i 11 $DISPLAY file.xkb
</pre>
<p>Note <code>xkbcomp -i11</code> will not work and will not give a clear error message either. Make sure you have space after <code>-i</code>.
</p>
<h2><span class="mw-headline" id="Debugging_XKB">Debugging XKB</span></h2>
<p>When keys do not work as expected, the first thing to check is XKB internal state: modifiers, effective group and control bits. All three can be used to drive LEDs; use xkbvleds to check them
</p>
<pre>   indicator "LED1" { modifiers = Lock; };
   indicator "LED2" { groups = 2; };
   indicator "LED3" { controls = audiblebell; };
   
</pre>
<p>Additionally, xkbwatch shows all (real) modifiers together with their lock/latch status. Modifiers are also reported by xev. Xxkb can be used to monitor effective group, but make sure two_state mode is off.
</p>
<p>In case interpretations section does not work well, make sure to check for duplicated "interpret" blocks. Better yet, try commenting out anything related to specific keysym. See section 9.2 for explanation.
</p>
<p>It also makes sense to check what exactly the server got by downloading the keymap back with
</p>
<pre>   xkbcomp $DISPLAY out.xkb
</pre>
<p>The results tend to be different from the input file. There is no known work-around for this.
</p>
<h2><span class="mw-headline" id="Virtual_Modifiers">Virtual Modifiers</span></h2>
<p>One of the most troublesome parts of XKB, virtual modifiers appear prominently in all standard keymaps, despite being a relatively minor and mostly useless feature. The term itself is grossly misleading, and most of the docs do not help much either.
</p>
<p>So, first of all: virtual modifiers are not modifiers in the same way real modifiers are. If anything, it is a way to name some of the real modifiers. They are not 16 more bits that can be used in level definitions. They are 16 possible names, each referring to one (or some, or none) of the 8 modifier bits.
</p>
<p>Real modifier bits are called Shift, Lock, Control and Mod1-Mod5. There are no Alt among them. Virtual modifiers were introduced to allow saying something like
</p>
<pre>   #define Alt Mod1
</pre>
<p>to applications willing to use this information.
</p>
<p>It is possible to make a usable layout without defining virtual modifiers at all. Among standard modifiers, only Alt/Meta actually need such treatment, because Shift and Control are real modifiers anyway and NumLock is not normally used as a modifier.
</p>
<p>Also, unlike most of the keymap-related things that affect any application using basic Xlib functions, virtual modifiers must be queried explicitly using XKBlib calls. Not all applications actually do that.
</p>
<h3><span class="mw-headline" id="Defining_virtual_modifiers">Defining virtual modifiers</span></h3>
<p>The mapping between virtual and real modifiers is defined in a rather weird way using keysyms as a medium. Refer to XKBproto for some reasons behind this. Real modifiers M are assigned to a key using
</p>
<pre>   modifier_map M { &lt;keysym&gt; };
</pre>
<p>Virtual modifiers V can be assigned to a key using
</p>
<pre>   interpret &lt;keysym&gt; { virtualMod = V; };
</pre>
<p>If a virtual modifier V shares at least one keysym with a real modifier M, it is bound to M.
</p>
<p>Note that virtual modifier names are not pre-defined and must be declared in  xkb_compatibility and xkb_types sections before using them:
</p>
<pre>   xkb_compatibility "complete" {
       virtual_modifiers LevelThree,NumLock,Alt;
   }
</pre>
<h3><span class="mw-headline" id="Keysym_interpretation">Keysym interpretation</span></h3>
<p>Virtual modifiers can be used in interpret &lt;keysym&gt; blocks as if they were defined to the respective real modifiers. For a virtual modifier V not bound to any real modifier, this means
</p>
<pre>   #define V
</pre>
<p>type declaration, and 
</p>
<pre>   interpret &lt;key&gt; { }
   interpret &lt;key&gt;+V { }
</pre>
<p>blocks will be treated as duplicates. Only one of them, the last one in the file, will work. xkbcomp usually gives a warning in cases like this.
</p>
<h3><span class="mw-headline" id="Client_side_notes">Client side notes</span></h3>
<p>Handling XKB virtual modifiers on the client side requires some non-trivial server interaction. Most applications just do not bother, sticking with 8 real modifiers supplied in XKeyEvent.state.
</p>
<p>However, it is possible for an application to obtain virtual modifiers associated with a key press. Gtk, for instance, has <a rel="nofollow" class="external text" href="http://www.gtk.org/api/2.6/gdk/gdk-Keyboard-Handling.html#gdk-keymap-translate-keyboard-state">gdk-keymap-translate-keyboard-state()</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2020-02-26]</sup> which may or may not be used in particular application.
</p>
<p>Some others may implement something that looks like virtual modifier support, but actually is not. Check Openbox example in section 5.3.3.2. Regarding Alt handling, check section 8.3.
</p>
<h2><span class="mw-headline" id="XKB_control_bits">XKB control bits</span></h2>
<p>A bunch of bit flags affecting various aspects of XKB functionality. To control them, use {Set,Latch,Lock}Controls actions.
</p>
<h3><span class="mw-headline" id="Mouse_control">Mouse control</span></h3>
<p>XKB allows controlling mouse pointer from keyboard. When set up properly, it can be extremely useful. However, its usability depends a lot on particular physical keyboard layout and on user's individual preferences.
</p>
<p>From XKB point of view it is relatively simple to implement, one should just trigger relevant actions. Fairly complete implementation can be found in <code>/usr/share/X11/xkb/compat/mousekeys</code>.
</p>
<p>Note that the actions will not work unless <code>MouseKeys</code> control bit is set:
</p>
<pre>   interpret Pointer_EnableKeys { action= LockControls(controls=MouseKeys); };
</pre>
<p>Because most keyboards do not have dedicated mouse control keys,  combining <code>MouseKeys</code> and one of the <code>Overlay</code> flags may be a good idea:
</p>
<pre>   interpret Pointer_EnableKeys { action= LockControls(controls=MouseKeys+Overlay1); };
</pre>
<p>This allows moving pointer control keys to appropriate overlay block:
</p>
<pre>   xkb_keycodes {
       &lt;MUP&gt; = 218;
       &lt;MDWN&gt; = 212;
       &lt;MLFT&gt; = 214;
       &lt;MRHT&gt; = 216;
   }

   xkb_symbols {
       key   &lt;UP&gt; { [    Up ], overlay1 = &lt;MUP&gt; };
       key &lt;LEFT&gt; { [  Left ], overlay1 = &lt;MLFT&gt; };
       key &lt;RGHT&gt; { [ Right ], overlay1 = &lt;MRHT&gt; };
       key &lt;DOWN&gt; { [  Down ], overlay1 = &lt;MDWN&gt; };

       key &lt;MUP&gt;  { [ Pointer_Up ] };
       key &lt;MDWN&gt; { [ Pointer_Down ] };
       key &lt;MLFT&gt; { [ Pointer_Left ] };
       key &lt;MRHT&gt; { [ Pointer_Right ] };
   }
</pre>
<p>This way it is possible to assign non-mouse actions to the keys used to control mouse, and thus, for example, use modifier keys to generate mouse buttons events.
</p>
<h2><span class="mw-headline" id="Local_XKB_folder">Local XKB folder</span></h2>
<p>You can set an X keymap from a local file using the following command:
</p>
<pre>$ xkbcomp keymap.xkb $DISPLAY
</pre>
<p>where <code>keymap.xkb</code> must have a structure like
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">keymap.xkb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">xkb_keymap {
    xkb_keycodes  { ... };
    xkb_types     { ... };
    xkb_compat    { ... };
    xkb_symbols   { ... };

    // Geometry is completely optional.
    // xkb_geometry  { include "pc(pc104)" };
};
</pre>
<p>You can use <i>includes</i> from this file, where the inclusion refer to a local folder instead of <code>/usr/share/X11/xkb</code>. You need to use the <code>-I/path/</code> parameter of xkbcomp for that. Full example:
</p>
<pre>$ xkbcomp -I$HOME/.xkb $HOME/.keymap.xkb $DISPLAY
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$HOME/.keymap.xkb</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">xkb_keymap {
    xkb_keycodes  { include "evdev+aliases(qwerty)" };
    xkb_types     { include "complete" };
    xkb_compat    { include "complete" };
    xkb_symbols   { include "pc+custom+inet(evdev)" };
};
</pre>
<p>The symbol file must have the same name as specified in the <code>xkb_symbols</code> right above.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$HOME/.xkb/symbols/custom</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">partial alphanumeric_keys xkb_symbols "custom" { ... };
</pre>
<h2><span class="mw-headline" id="Troubleshooting">Troubleshooting</span></h2>
<h3><span class="mw-headline" id="I_have_an_USB_keyboard_and_the_settings_get_lost_upon_unplugging_it">I have an USB keyboard and the settings get lost upon unplugging it</span></h3>
<p>Using <a href="#Using_rules">rules</a> instead of static keymap configuration will give you a more flexible and permanent key mapping that doesn't need to be reloaded manually (or by a script).
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="https://www.x.org/releases/current/doc/xorg-docs/input/XKB-Config.html">The XKB Configuration Guide</a></li>
<li><a rel="nofollow" class="external free" href="http://www.x.org/wiki/XKB">http://www.x.org/wiki/XKB</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.charvolant.org/doug/xkb/html/index.html">An Unreliable Guide To XKB Configuration</a>.</li>
<li>
<a rel="nofollow" class="external text" href="http://pascal.tsu.ru/en/xkb/">Ivan Pascal XKB docs</a>. One of the oldest and most well-known guides. Focuses a lot on details, and explains some of exotic XKB features.</li>
<li>
<a rel="nofollow" class="external text" href="http://www.x.org/releases/current/doc/kbproto/xkbproto.pdf">XKB protocol specification</a>. Comprehensive description of all XKB features. Extremely useful for understating how XKB works, includes a good description of virtual modifiers among other things. Some practice with xkbcomp is strongly recommended though, because the features are described on protocol level.</li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../en/Category:X_server.html" title="Category:X server">X server</a></li>
<li><a href="../en/Category:Keyboard_configuration.html" title="Category:Keyboard configuration">Keyboard configuration</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul>
<li><a href="../en/Category:Pages_or_sections_flagged_with_Template:Style.html" title="Category:Pages or sections flagged with Template:Style">Pages or sections flagged with Template:Style</a></li>
<li><a href="../en/Category:Pages_with_dead_links.html" title="Category:Pages with dead links">Pages with dead links</a></li>
</ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=X_keyboard_extension&amp;oldid=636787">https://wiki.archlinux.org/index.php?title=X_keyboard_extension&amp;oldid=636787</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 30 September 2020, at 04:39.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
