<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Unified Extensible Firmware Interface (Italiano) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Unified_Extensible_Firmware_Interface_Italiano rootpage-Unified_Extensible_Firmware_Interface_Italiano skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Unified Extensible Firmware Interface (Italiano)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<p>L'<b>Unified Extensible Firmware Interface</b> (UEFI in breve) è un nuovo firmware inizialmente progettato da Intel (con il nome EFI) per i sistemi basati su processori Itanium. Esso introduce un nuovo metodo di avvio del SO che si distingue dal tradizionale "codice di avvio MBR" utilizzato dal BIOS. La versione di EFI 1.x fu presentata da Intel e successivamente un gruppo di aziende chiamato "the UEFI forum" si assunse il ruolo di svilupparlo e, per questo, a partire dalla versione 2.0 venne chiamato Unified EFI. Dal 23 Maggio 2012, la versione più recente è la 2.3.1
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  Salvo specificare esplicitamente EFI 1.x i termini EFI e UEFI sono attualmente usati entrambi per indicare il firmware UEFI 2.0. Le istruzioni contenute in questa guida sono generali e non specifiche per Mac, se non specificato esplicitamente. Molti passaggi potrebbero essere differenti su un Mac, in quanto l'implementazione Apple di EFI è un mix tra EFI 1.x e UEFI 2.0. SI tratta quindi di un firmware non conferme agli standard UEFI.</div>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Avviare_un_SO_usando_il_BIOS"><span class="tocnumber">1</span> <span class="toctext">Avviare un SO usando il BIOS</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Avvio_multiplo_con_BIOS"><span class="tocnumber">1.1</span> <span class="toctext">Avvio multiplo con BIOS</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3">
<a href="#Avviare_un_SO_usando_UEFI"><span class="tocnumber">2</span> <span class="toctext">Avviare un SO usando UEFI</span></a>
<ul>
<li class="toclevel-2 tocsection-4">
<a href="#Avvio_multiplo_con_UEFI"><span class="tocnumber">2.1</span> <span class="toctext">Avvio multiplo con UEFI</span></a>
<ul>
<li class="toclevel-3 tocsection-5"><a href="#Linux_Windows_x86_64_UEFI-GPT_Multiboot"><span class="tocnumber">2.1.1</span> <span class="toctext">Linux Windows x86_64 UEFI-GPT Multiboot</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Processo_di_boot_con_UEFI"><span class="tocnumber">3</span> <span class="toctext">Processo di boot con UEFI</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Identificare_l'architettura_del_firmware_UEFI"><span class="tocnumber">4</span> <span class="toctext">Identificare l'architettura del firmware UEFI</span></a></li>
<li class="toclevel-1 tocsection-8">
<a href="#Supporto_del_Kernel_Linux_per_UEFI"><span class="tocnumber">5</span> <span class="toctext">Supporto del Kernel Linux per UEFI</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Configurazioni_del_Kernel_Linux_per_UEFI"><span class="tocnumber">5.1</span> <span class="toctext">Configurazioni del Kernel Linux per UEFI</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10">
<a href="#Supporto_per_le_variabili_UEFI"><span class="tocnumber">6</span> <span class="toctext">Supporto per le variabili UEFI</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Strumenti_in_ambiente_Userspace"><span class="tocnumber">6.1</span> <span class="toctext">Strumenti in ambiente Userspace</span></a></li>
<li class="toclevel-2 tocsection-12">
<a href="#Sistemi_UEFI_Non-Mac"><span class="tocnumber">6.2</span> <span class="toctext">Sistemi UEFI Non-Mac</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#efibootmgr"><span class="tocnumber">6.2.1</span> <span class="toctext">efibootmgr</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Bootloader_Linux_per_UEFI"><span class="tocnumber">7</span> <span class="toctext">Bootloader Linux per UEFI</span></a></li>
<li class="toclevel-1 tocsection-15">
<a href="#Creare_una_partizione_di_sistema_UEFI_con_Linux"><span class="tocnumber">8</span> <span class="toctext">Creare una partizione di sistema UEFI con Linux</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Per_dischi_partizionati_GPT"><span class="tocnumber">8.1</span> <span class="toctext">Per dischi partizionati GPT</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Per_dischi_partizionati_MBR"><span class="tocnumber">8.2</span> <span class="toctext">Per dischi partizionati MBR</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18">
<a href="#UEFI_Shell"><span class="tocnumber">9</span> <span class="toctext">UEFI Shell</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#Collegamenti_per_il_download_di_UEFI_Shell"><span class="tocnumber">9.1</span> <span class="toctext">Collegamenti per il download di UEFI Shell</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Avviare_UEFI_Shell"><span class="tocnumber">9.2</span> <span class="toctext">Avviare UEFI Shell</span></a></li>
<li class="toclevel-2 tocsection-21">
<a href="#Comandi_importanti_della_Shell_UEFI"><span class="tocnumber">9.3</span> <span class="toctext">Comandi importanti della Shell UEFI</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#bcfg"><span class="tocnumber">9.3.1</span> <span class="toctext">bcfg</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#edit"><span class="tocnumber">9.3.2</span> <span class="toctext">edit</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-24">
<a href="#Creare_un_dispositivo_USB_avviabile_con_UEFI_dalla_ISO"><span class="tocnumber">10</span> <span class="toctext">Creare un dispositivo USB avviabile con UEFI dalla ISO</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Risoluzione_degli_errori"><span class="tocnumber">10.1</span> <span class="toctext">Risoluzione degli errori</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="#Rimuovere_il_supporto_per_il_boot_UEFI_dalla_ISO"><span class="tocnumber">11</span> <span class="toctext">Rimuovere il supporto per il boot UEFI dalla ISO</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#Altre_risorse"><span class="tocnumber">12</span> <span class="toctext">Altre risorse</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Avviare_un_SO_usando_il_BIOS">Avviare un SO usando il BIOS</span></h2>
<p>Il BIOS (Basic Input-Output System) è il primo programma che viene eseguito all'accensione del PC. Quando tutto l'hardware è stato avviato e le operazioni POST sono state completate, il BIOS esegue il primo codice di avvio presente sulla prima periferica specificata nella lista di avvio (booting list). 
</p>
<p>Se il primo elemento della lista è un lettore CD/DVD, viene eseguita l'estensione El-Torito(codice di avvio) presente sul CD. Se il primo elemento è un HDD, il BIOS esegue i primi 440 byte cioè il codice di avvio <a href="../it/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Master Boot Record (Italiano)">MBR</a>. Il codice di avvio effettua un chainload oppure il bootstrap di un bootloader più complesso che poi avvia il SO.
</p>
<p>Il BIOS non sa come leggere la tabella delle partizioni o un filesystem, ma si limita ad inizializzare l'hardware ed eseguire il codice d'avvio.
</p>
<h3><span class="mw-headline" id="Avvio_multiplo_con_BIOS">Avvio multiplo con BIOS</span></h3>
<p>Dato che si può ottenere poco da un programma deve occupare solo i primi 440 bytes disponibili, per l'avvio multiplo usando il BIOS è necessario un bootloader che gestisca l'avvio multiplo(si intende l'avvio di più di un sistema operativo, non l'avvio di un Kernel nel formato Multiboot). Per questo motivo il BIOS si limita ad avviare un bootloader come <a href="../it/GRUB.html" class="mw-redirect" title="GRUB2 (Italiano)">GRUB</a>, <a href="../it/Syslinux.html" title="Syslinux (Italiano)">Syslinux</a> oppure <a href="../en/LILO.html" title="LILO">LILO</a> il quale in seguito si occupa di caricare il sistema operativo attraverso un chainload(caricamento di un altro bootloader) oppure direttamente caricando il kernel.
</p>
<h2><span class="mw-headline" id="Avviare_un_SO_usando_UEFI">Avviare un SO usando UEFI</span></h2>
<p>Il firmware UEFI non avvia il sistema con il metodo sopra menzionato (l'unico supportato dal BIOS), difatti UEFI ha la capacità di leggere la tavola delle partizioni e quella di riconoscere i singoli filesystem.
</p>
<p>I firmware UEFI comunemente utilizzati supportano entrambi i sistemi di partizionamento <a href="../it/Partitioning.html#Master_Boot_Record" class="mw-redirect" title="Master Boot Record (Italiano)">MBR</a> e <a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GPT">GPT</a>. L'EFI Apple supporta anche la mappa di partizionamento Apple. La maggior parte dei firmware UEFI supportano i filesystem FAT12 (floppy disks), FAT16 e FAT32 negli HHD inoltre ISO9660(e UDF) nei CD/DVD. Il firmware EFI nei sistemi Apple supporta in aggiunta i filesystem HFS/HFS+.
</p>
<p>UEFI non lancia nessun codice dall'MBR sia che il codice esista o meno. Utilizza invece una speciale partizione chiamata "EFI SYSTEM PARTITION" che contiene i file che verranno avviati dal firmware. Ogni produttore può archiviare i propri file nella cartella &lt;EFI SYSTEM PARTITION&gt;/EFI/&lt;PRODUTTORE&gt;/ e usare il firmware (oppure la propria shell UEFI) per lanciare il programma di avvio. La partizione di sistema EFI ha normalmente come filesystem FAT32.
</p>
<p>In ambiente UEFI, tutti i programmi che siano loader per un Sistema Operativo o altri strumenti (come programmi per il test della memoria) o strumenti di recovery al di fuori del sistema operativo, dovrebbero essere applicazioni UEFI corrispondenti all'architettura del firmware EFI. Molti dei firmware UEFI sul mercato, inclusi i recenti Mac di Apple utilizzano un firmware UEFI x86_64. Solo alcuni vecchi Mac utilizzano un firmware EFI i386 mentre i sistemi UEFI non Apple sono risaputi utilizzare firmware EFI i386.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Alcune vecchie schede Server Intel sono note operare con un firmware Intel EFI 1.10, e richiedono applicazioni EFI i386.</div>
<p>Un firmware EFI x86_64 non include il supporto per il lancio di applicazioni EFI a 32-bit, diversamente dai sistemi Linux o Windows 64-bit che includono questo supporto. Comunque il bootloader dovrà essere compilato per la corretta architettura.
</p>
<h3><span class="mw-headline" id="Avvio_multiplo_con_UEFI">Avvio multiplo con UEFI</span></h3>
<p>Dato che ogni SO o produttore può mantenere i propri file nella partizione del sistema EFI(EFI SYSTEM PARTITION) senza modificarne altri, il multiboot mediante UEFI consiste nel lanciare una differente applicazione UEFI corrispondente al bootloader di un determinato sistema operativo. Questo rende non necessari i meccanismi di chainload dei bootloader per avviare altri sistemi operativi.
</p>
<h4><span class="mw-headline" id="Linux_Windows_x86_64_UEFI-GPT_Multiboot">Linux Windows x86_64 UEFI-GPT Multiboot</span></h4>
<p>Le versioni Windows Vista (SP1+), Windows 7 Professional e Windows 8 x86_64 supportano nativamente il boot da un firmware UEFI. Ma per questo è necessario un partizionamento di tipo <a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GPT">GPT</a> sul disco utilizzato per il boot con UEFI. Le versioni 32-bit di Windows supportano solamente il boot di tipo BIOS-MBR. Seguire le istruzioni fornite nel link del forum nella sezione altre risorse, per informazioni su come procedere. Consultare <a rel="nofollow" class="external free" href="https://support.microsoft.com/default.aspx?scid=kb;EN-US;2581408">https://support.microsoft.com/default.aspx?scid=kb;EN-US;2581408</a> per maggiori informazioni.
</p>
<p>Questa limitazione non esiste per il Kernel Linux ma piuttosto per il bootloader utilizzato. Per il bene dell'avvio di Windows, il bootloader Linux dovrebbe essere installato in modalità UEFI-GPT se si avviano entrambi dal solito disco.
</p>
<h2><span class="mw-headline" id="Processo_di_boot_con_UEFI">Processo di boot con UEFI</span></h2>
<ol>
<li>Accensione del sistema - Power On Self Test, o processo POST.</li>
<li>Viene caricato il firmware UEFI.</li>
<li>Il firmware legge il suo Boot Manager per determinare quale applicazione UEFI avviare e da dove avviare (ad esempio da quale disco e partizione).</li>
<li>Il firmware avvia l'applicazione UEFI dalla partizione UEFISYS formattata FAT32 come definito nella voce di avvio del boot manager del firmware.</li>
<li>L'applicazione UEFI può avviare un'altra applicazione (nel caso di UEFI Shell o un boot manager come rEFInd) oppure il kernel e l'initramfs (nel caso di un bootloader come GRUB) a seconda di come è stata configurata l'applicazione UEFI.</li>
</ol>
<h2>
<span id="Identificare_l.27architettura_del_firmware_UEFI"></span><span class="mw-headline" id="Identificare_l'architettura_del_firmware_UEFI">Identificare l'architettura del firmware UEFI</span>
</h2>
<p>Se si possiede un sistema UEFI non mac, allora si ha un firmware UEFI 2.x x86_64 (detto anche 64-bit).
</p>
<p>Alcuni dei più noti firmware UEFI 2.x x86_64 sono Phoenix SecureCore Tiano, AMI Aptio, Insyde H2O.
</p>
<p>Alcuni dei più noti sistemi che utilizzano questi firmware sono Asus EZ Mode BIOS (schede madri con Sandy Bridge P67 e H67 ), MSI ClickBIOS, HP EliteBooks, Sony Vaio Z series, alcune schede madri Desktop e Server di Intel.
</p>
<p>I Mac prodotti prima del 2008 per lo più hanno firmware i386-efi mentre quelli prodotti dopo hanno firmware x86_64-efi. Tutti i Mac capaci di eseguire il kernel di Mac OS X Snow Leopard 64-bit hanno un firmware x86_64 EFI 1.x.
</p>
<p>Per individuare l'architettura del firmware efi in un Mac, avviare Mac OS X e digitare il seguente comando:
</p>
<pre>ioreg -l -p IODeviceTree | grep firmware-abi
</pre>
<p>Se la risposta del comando è EFI32 allora il firmware sarà i386 EFI 1.x. Se risponde EFI64 allora il firmware sarà x86_64 EFI 1.x. I Mac non hanno un firmware UEFI 2.x perché l'implementazione di Aplle del firmware EFI non soddisfa pienamente le specifiche UEFI.
</p>
<h2><span class="mw-headline" id="Supporto_del_Kernel_Linux_per_UEFI">Supporto del Kernel Linux per UEFI</span></h2>
<h3><span class="mw-headline" id="Configurazioni_del_Kernel_Linux_per_UEFI">Configurazioni del Kernel Linux per UEFI</span></h3>
<p>Le configurazioni del Kernel Linux richieste per utilizzare UEFI sono: 
</p>
<pre>CONFIG_EFI=y
CONFIG_EFI_STUB=y
CONFIG_RELOCATABLE=y
CONFIG_FB_EFI=y
CONFIG_FRAMEBUFFER_CONSOLE=y
</pre>
<p>Supporto per le variabili/servizi di runtime - il modulo del kernel 'efivars'. Questa opzione è importante perché richiesta per accedere e variare le variabili di Runtime UEFI utilizzando strumenti come <b>efibootmgr</b>.
</p>
<pre>CONFIG_EFI_VARS=m
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> In questa opzione è compilato come modulo come nei kernel di Arch reperibili in core/testing.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Per permettere a Linux di accedere ai servizi di runtime UEFI, l'architettura del firmware UEFI e quella del Kernel Linux devono coincidere. Non dipende dal bootloader utilizzato.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se l'architettura del firmware UEFI e quella del Kernel Linux sono diverse, utilizzare il parametro "<b>noefi</b>" nella linea kernel per evitare kernel panic ed avviare correttamente. L'opzione "noefi" comunica al kernel di non accedere ai servizi di runtime UEFI.</div>
<p>Opzione di configurazione per la tavola delle partizioni <a href="../en/Partitioning.html#GUID_Partition_Table" class="mw-redirect" title="GPT">GPT</a>(GUID Partition Table) - obbligatoria per il supporto ad UEFI:
</p>
<pre>CONFIG_EFI_PARTITION=y
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Tutte le opzioni sopra sono richieste per avviare Linux tramite UEFI, e sono abilitate nei kernel presenti nei repository ufficiali di ArchLinux.</div>
<p>Informazioni ottenute da <a rel="nofollow" class="external free" href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob_plain;f=Documentation/x86/x86_64/uefi.txt;hb=HEAD">http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob_plain;f=Documentation/x86/x86_64/uefi.txt;hb=HEAD</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup> .
</p>
<h2><span class="mw-headline" id="Supporto_per_le_variabili_UEFI">Supporto per le variabili UEFI</span></h2>
<p>UEFI definisce delle variabili tramite cui il sistema operativo può interagire con il firmware. Le variabili di boot UEFI sono utilizzate dal boot-loader e dal sistema operativo durante la prima fase di avvio. Le variabili di runtime UEFI permettono al sistema operativo di gestire certe impostazioni del firmware come il Boot Manager UEFI o gestire le chiavi per il Secure Boot Protocol eccetera.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> I seguenti passaggio non funzioneranno se il sistema è stato avviato in modalità BIOS, e non funzioneranno nemmeno se l'architettura del firmware UEFI e quella del Kernel Linux non coincidono, ad esempio firmware UEFI x86_64 + kernel x86 32-bit o viceversa. Questo è vero per il modulo del kernel efivar e per efibootmgr. Gli altri passaggi (ad esempio configurare &lt;UEFISYS&gt;/EFI/arch/refind/{refindx64.efi,refind.conf} ) possono essere effettuati anche se si è avviato in modalità BIOS/Legacy.</div>
<p>L'accesso ai servizi di runtime UEFI è fornito dal modulo del kernel "efivars" che è abilitato dalla configurazione del kernel <code>CONFIG_EFI_VAR=m</code>. Questo modulo una volta caricato garantirà l'accesso alle variabili popolando la cartella <code>/sys/firmware/efi/vars</code>. Un modo per controllare che il sistema sia avviato in modalità UEFI consiste nel caricare in memoria il modulo "efivars" e controllare l'esistenza ed il contenuto della cartella <code>/sys/firmware/efi/vars</code> il cui contenuto sarà simile a questo:
</p>
<pre>Output di esempio (x86_64-UEFI 2.3.1 con kernel x86_64):

# ls -1 /sys/firmware/efi/vars/
Boot0000-8be4df61-93ca-11d2-aa0d-00e098032b8c/
BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c/
BootOptionSupport-8be4df61-93ca-11d2-aa0d-00e098032b8c/
BootOrder-8be4df61-93ca-11d2-aa0d-00e098032b8c/
ConIn-8be4df61-93ca-11d2-aa0d-00e098032b8c/
ConInDev-8be4df61-93ca-11d2-aa0d-00e098032b8c/
ConOut-8be4df61-93ca-11d2-aa0d-00e098032b8c/
ConOutDev-8be4df61-93ca-11d2-aa0d-00e098032b8c/
ErrOutDev-8be4df61-93ca-11d2-aa0d-00e098032b8c/
Lang-8be4df61-93ca-11d2-aa0d-00e098032b8c/
LangCodes-8be4df61-93ca-11d2-aa0d-00e098032b8c/
MTC-eb704011-1402-11d3-8e77-00a0c969723b/
MemoryTypeInformation-4c19049f-4137-4dd3-9c10-8b97a83ffdfa/
PlatformLang-8be4df61-93ca-11d2-aa0d-00e098032b8c/
PlatformLangCodes-8be4df61-93ca-11d2-aa0d-00e098032b8c/
RTC-378d7b65-8da9-4773-b6e4-a47826a833e1/
del_var
new_var
</pre>
<p>Le variabili di runtime UEFI non saranno reperibili se è stato utilizzato il parametro "noefi" nella linea del kernel dal menù del bootloader. Questo parametro comunica al kernel di ignorare i servizi di runtime UEFI.
</p>
<h3><span class="mw-headline" id="Strumenti_in_ambiente_Userspace">Strumenti in ambiente Userspace</span></h3>
<p>Esistono alcuni strumenti che possono accedere/modificare le variabili UEFI, e sono:
</p>
<ol>
<li>efibootmgr - Utilizzato per creare/modificare le voci di avvio del Boot Manager UEFI - <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=efibootmgr">efibootmgr</a></span> oppure <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/efibootmgr-git/">efibootmgr-git</a></span><sup><small>AUR</small></sup><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">broken link</a>: package not found]</sup>
</li>
<li>uefivars - semplicemente accede alle variabili - <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/uefivars-git/">uefivars-git</a></span><sup><small>AUR</small></sup> - utilizza la libreria efibootmgr</li>
<li>Ubuntu's Firmware Test Suite - fwts - <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/fwts-git/">fwts-git</a></span><sup><small>AUR</small></sup> - il comando uefidump - <code>fwts uefidump</code>
</li>
</ol>
<h3><span class="mw-headline" id="Sistemi_UEFI_Non-Mac">Sistemi UEFI Non-Mac</span></h3>
<h4><span class="mw-headline" id="efibootmgr">efibootmgr</span></h4>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Utilizzando <code>efibootmgr</code> su di un Mac Apple verrà danneggiato (briked) il firmware e potrebbe essere necessario flashare nuovamente la ROM della scheda madre. Esistono segnalazioni di bug riguardante l'argomento sul bug tracker di Ubuntu/Lanunchpad. Utilizzare solamente il comando bless in caso si abbia un Mac. Lo strumento sperimentale "bless" per Linux è sviluppato dagli sviluppatori di Fedora - <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/mactel-boot/">mactel-boot</a></span><sup><small>AUR</small></sup>.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Il comando <code>efibootmgr</code> funzionerà soltanto se si è avviato il sistema in modalità UEFI, dato che <b>richiede l'accesso alle variabili di runtime UEFI</b> che sono <b>accessibili solo se si avvia in modalità UEFI</b> (senza l'uso del parametro del kernel "noefi"). Altrimenti verrà visualizzato l'errore <code>Fatal: Couldn't open either sysfs or procfs directories for accessing EFI variables</code>.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  Se risulta impossibile utilizzare <code>efibootmgr</code>, alcuni firmware UEFI permettono agli utenti di gestire direttamente le opzioni di boot uefi dalla configurazione. Ad esempio alcuni firmware ASUS hanno l'opzione "Add New Boot Option" che permette di selezionare una partizione EFI di sistema locale, e di impostare manualmente l'applicazione EFI. (ad esempio '\EFI\refind\refind_x64.efi')</div>
<p>Inizialmente potrebbe dover avviare il boot-loader dal firmware stesso (utilizzando la UEFI Shell) se il boot-loader è stato installato quando il sistema era avviato in modalità BIOS. Successivamente <code>efibootmgr</code> dovrebbe essere eseguito per rendere il boot-loader UEFI la voce di avvio di default nel Boot Manager UEFI.
</p>
<p>Per utilizzare efibootmgr, prima sarà necessario caricare il modulo del kernel 'efivars':
</p>
<pre># modprobe efivars
</pre>
<p>Se con questo comando si ottiene l'errore <b>no such device found</b>, allora significa che il sistema non è stato avviato in modalità UEFI o che per qualche motivo il kernel non riesce ad accedere alle variabili di runtime UEFI(noefi?).
</p>
<p>Verificare l'esistenza dei file nella cartella <i>/sys/firmware/efi/vars/</i>. Questa cartella ed il suo contenuto sono creati dal modulo del kernel "efivars" ed esisteranno soltanto se si è avviato in modalità UEFI, senza il parametro del kernel "noefi".
</p>
<p>Se la cartella <i>/sys/firmware/efi/vars/</i> è vuota o non esiste, allora il comando <code>efibootmgr</code> non funzionerà. Se non si riesce ad avviare la ISO/CD/DVD/USB in modalità UEFI consultare <a href="#Creare_un_dispositivo_USB_avviabile_con_UEFI_dalla_ISO">Creare un dispositivo USB avviabile con UEFI dalla ISO</a> .
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong>  I seguenti comandi utilizzano il boot-loader <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=gummiboot">gummiboot</a></span><sup>[<a href="../en/Help:Procedures.html#Fix_broken_package_links" title="Help:Procedures">broken link</a>: package not found]</sup> come esempio.</div>
<p>Ipotizzando che il file del boot-loader da avviare sia <code>/boot/efi/EFI/gummiboot/gummibootx64.efi</code>. Il percorso <code>/boot/efi/EFI/gummiboot/gummibootx64.efi</code> può essere diviso in due parti <code>/boot/efi</code> and <code>/EFI/gummiboot/gummibootx64.efi</code>, dove <code>/boot/efi</code> è il punto di mount della partizione di sistema UEFI, che si presume essere <code>/dev/sdXY</code> (nell'esempio X e Y sono soltanto simbolici per i reali valori - ad esempio: <code>/dev/sda1</code>. X=a Y=1).
</p>
<p>Per determinare l'attuale percorso per la partizione di sistema UEFI(dovrebbe essre nella forma <code>/dev/sdXY</code>), provare il comando:
</p>
<pre># findmnt /boot/efi
TARGET SOURCE  FSTYPE OPTIONS
/boot/efi /dev/sdXY vfat        rw,flush,tz=UTC
</pre>
<p>Per creare la voce di avvio utilizzando efibootmgr usare il seguente comando:
</p>
<pre># efibootmgr -c -g -d /dev/sdX -p Y -w -L "Gummiboot" -l '\EFI\gummiboot\gummibootx64.efi'
</pre>
<p>Nel comando precedente <code>/boot/efi/EFI/gummiboot/gummibootx64.efi</code>  viene interpretato come <code>/boot/efi</code> e <code>/EFI/gummiboot/gummibootx64.efi</code> che a sua volta si interpreta come disco <code>/dev/sdX</code> -&gt; partizione <code>Y</code> -&gt; file <code>/EFI/gummiboot/gummibootx64.efi</code>.
</p>
<p>UEFI utilizza il backslash (\) come separatore per i percorsi (come nei percorsi Windows).
</p>
<p>L'etichetta è il nome della voce del menù visualizzata nel menù di avvio UEFI. Questo nome è scelta dell'utente e non influisce sull'avvio del sistema. Maggiori informazioni posso esse ottenute da <a rel="nofollow" class="external text" href="http://linux.dell.com/cgi-bin/gitweb/gitweb.cgi?p=efibootmgr.git;a=blob_plain;f=README;hb=HEAD">efibootmgr GIT README</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup> .
</p>
<p>Il filesystem FAT32 non è case-sensitive(non fa distinzione tra maiuscole e minuscole) dato che non utilizza la codifica UTF-8 come default. In questo caso il firmware utilizza lettere maiuscole 'EFI' invece di 'efi', pertanto utilizzare {{ic|\EFI\gummiboot\gummibootx64.efi} o {{ic|\efi\gummiboot\gummibootx64.efi} non fa differenza (cambierebbe invece se la codifica del filesystem fosse UTF-8).
</p>
<h2><span class="mw-headline" id="Bootloader_Linux_per_UEFI">Bootloader Linux per UEFI</span></h2>
<p>Consultare <a href="../en/Arch_boot_process.html#Boot_loader" title="Arch boot process">Arch boot process#Boot loader</a>.
</p>
<h2><span class="mw-headline" id="Creare_una_partizione_di_sistema_UEFI_con_Linux">Creare una partizione di sistema UEFI con Linux</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> La partizione UEFISYS puà essere creata di qualsiasi dimensione supportata dal filesystem FAT32. In accordo con la documentazione di Microsoft, la dimensione minima per il filesystem FAT32 è di 512 MiB. Pertanto è consigliato che la partizione UEFISYS sia grande almeno 512 MiB. Partizioni più grandi vanno bene, specialmente se si utilizzano svariati bootloader, oppure se diversi sistemi operativi sono avviati tramite UEFI, quindi ci sarà abbastanza spazio per contenere tutti i file correlati. Se si utilizza l'avvio EFISTUB, allora assicurarsi che ci sia abbastanza spazio per il kernel e l'initramfs nella partizione UEFISYS.</div>
<h3><span class="mw-headline" id="Per_dischi_partizionati_GPT">Per dischi partizionati GPT</span></h3>
<p>Due scelte:
</p>
<ul>
<li>Usando GNU Parted/GParted: Creare una partizione FAT32. Contrassegnala come "avviabile".</li>
<li>Usando GPT fdisk (chiamato anche gdisk): Creare una partizione con gdisk con codice di tipo partizione "EF00". Successivamente formattare la partizione come FAT32 usando <code>mkfs.vfat -F32 /dev/&lt;PARTIZIONE&gt;</code>
</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Contrassegnando come "avviabile" una partizione in un disco partizionato MBR essa viene marcata come attiva, mentre in una partizione GPT marca la partizione come "UEFI System Partition".</div>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Non utilizzare i comandi di util-linux fdisk, cfdisk o sfdisk per cambiare i tipi partizione in un disco GPT. Ugualmente non usare gptfdisk gdisk, cgdisk o sgdisk su un disco MBR, il disco verrebbe automaticamente convertito in un disco GPT (nessuna perdita di dati, ma il sistema non si avvierebbe).</div>
<h3><span class="mw-headline" id="Per_dischi_partizionati_MBR">Per dischi partizionati MBR</span></h3>
<p>Due scelte:
</p>
<ul>
<li>Usando GNU Parted/GParted: Creare una partizione FAT32. Cambiare il tipo partizione della partizione in 0xEF usando fdisk, cfdisk or sfdisk.</li>
<li>Usando fdisk: Creare una partizione con il tipo partizione 0xEF e formattarla in FAT32 usando <code>mkfs.vfat -F32 /dev/&lt;PARTIZIONE&gt;</code>
</li>
</ul>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> E' raccomandato usare sempre partizioni GPT per il boot UEFI poiché alcuni firmware UEFI non accettano il boot UEFI-MBR.</div>
<h2><span class="mw-headline" id="UEFI_Shell">UEFI Shell</span></h2>
<p>La UEFI Shell è una shell/terminale per il firmware. Essa avvia le applicazioni uefi che includono i boot-loader UEFI. Oltre a questo la shell può anche essere utilizzata per ottenere altre informazioni riguardo al sistema o il firmware come la mappatura della memoria (memmap), modificare le variabili del boot manager (bcfg), eseguire programmi di partizionamento (diskpart), caricare driver uefi, modificare file di testo (edit), hexedit eccetera.
</p>
<h3><span class="mw-headline" id="Collegamenti_per_il_download_di_UEFI_Shell">Collegamenti per il download di UEFI Shell</span></h3>
<p>E' possibile scaricare una UEFI Shell con licenza BSD rilasciata dal progetto di Intel Tianocore UDK/EDK2 Sourceforge.net.
</p>
<ul>
<li>
<a rel="nofollow" class="external text" href="https://edk2.svn.sourceforge.net/svnroot/edk2/trunk/edk2/ShellBinPkg/UefiShell/X64/Shell.efi">x86_64 UEFI Shell 2.0 (Beta)</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://edk2.svn.sourceforge.net/svnroot/edk2/trunk/edk2/EdkShellBinPkg/FullShell/X64/Shell_Full.efi">x86_64 UEFI Shell 1.0 (Old)</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://edk2.svn.sourceforge.net/svnroot/edk2/trunk/edk2/ShellBinPkg/UefiShell/Ia32/Shell.efi">i386 UEFI Shell 2.0 (Beta)</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://edk2.svn.sourceforge.net/svnroot/edk2/trunk/edk2/EdkShellBinPkg/FullShell/Ia32/Shell_Full.efi">i386 UEFI Shell 1.0 (Old)</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
</ul>
<p>La versione 2.0 della Shell funziona solamente con le versioni di firmware UEFI maggiore di 2.3, ed è consigliato al posto della Shell 1.0 in questo tipo di sistemi. La Shell 1.0 dovrebbe funzionare su tutti i sistemi UEFI senza particolare riguardo alla versione del firmware. Maggiori informazioni in <a rel="nofollow" class="external text" href="https://sourceforge.net/apps/mediawiki/tianocore/index.php?title=ShellPkg">ShellPkg</a> ed in <a rel="nofollow" class="external text" href="http://sourceforge.net/mailarchive/message.php?msg_id=28690732">questa mail</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</p>
<h3><span class="mw-headline" id="Avviare_UEFI_Shell">Avviare UEFI Shell</span></h3>
<p>Alcune schede madri Asus ed altre basate su firmware UEFI AMI Aptio x86_64 (a partire dalle schede con Sandy Bridge) forniscono una opzione chiamata <code>"Launch EFI Shell from filesystem device"</code>. Per queste schede madri, scaricare la Shell UEFI e copiarla sulla partizione di sistema UEFI come <code>&lt;UEFI_SYSTEM_PARTITION&gt;/shellx64.efi</code> (comunemente <code>/boot/efi/shellx64.efi</code>).
</p>
<p>I sistemi con un firmware UEFI Phoenix SecureCore Tiano sono noti per avere una Shell UEFI integrata che può essere avviata premendo un tasto come F6, F11 oppure F12.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Se non fosse possibile avviare la Shell UEFI direttamente dal firmware utilizzando uno dei precedenti metodi, creare una pennina USB formattata FAT32 contenente Shell.efi nel percorso (USB)/efi/boot/bootx64.efi La penna USB dovrebbe comparire nel menù di avvio del firmware UEFI. Avviando questa opzione verrà avviata la Shell UEFI.</div>
<h3><span class="mw-headline" id="Comandi_importanti_della_Shell_UEFI">Comandi importanti della Shell UEFI</span></h3>
<p>I comandi della Shell UEFI solitamente supportano l'opzione <code>-b</code> che ferma lo scorrimento dell'output alla fine della pagina. <code>map</code> elenca i filesystem riconosciuti (<code>fs0</code>, ...) ed i dispositivi di archiviazione (<code>blk0</code>, ...). Eseguire <code>help -b</code> per elencare i comandi disponibili.
</p>
<p>Maggiori informazioni su <a rel="nofollow" class="external text" href="http://software.intel.com/en-us/articles/efi-shells-and-scripting/">questo sito</a>.
</p>
<h4><span class="mw-headline" id="bcfg">bcfg</span></h4>
<p>Il comando BCFG viene utilizzato per modificare i valori nella NVRAM UEFI, il che permette all'utente di cambiare le voci di avvio o le opzioni dei driver. Questo comando è descritto in modo dettagliato alla pagina 83(Sezione 5.3) del documento pdf "UEFI Shell Specification 2.0".
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Si raccomanda gli utenti di utilizzare <code>bcfg</code> solamente se <code>efibootmgr</code> fallisce nel creare voci di avvio funzionanti sul proprio sistema.</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> La versione 1.0 della Shell UEFI non supporta il comando <code>bcfg</code>.</div>
<p>Per ottenere una lista delle attuali voci di avvio:
</p>
<pre>Shell&gt; bcfg boot dump -v
</pre>
<p>Per aggiungere la voce di avvio per rEFInd (ad esempio) come quarta (la numerazione comincia da 0) opzione nel menù di boot:
</p>
<pre>Shell&gt; bcfg boot add 3 fs0:\EFI\arch\refind\refindx64.efi "Arch Linux (rEFInd)"
</pre>
<p>dove fs0: è la mappatura corrispondente alla partizione di sistema UEFI System Partition e \EFI\arch\refind\refindx64.efi è il file da avviare.
</p>
<p>Per rimuovere la quarta opzione di boot:
</p>
<pre>Shell&gt; bcfg boot rm 3
</pre>
<p>Per spostare l'opzione numero 3 al posto dell'opzione numero 0 (cioè la prima opzione o l'opzione di default nel menù di avvio UEFI):
</p>
<pre>Shell&gt; bcfg boot mv 3 0
</pre>
<p>Per il testo di aiuto di bcfg
</p>
<pre>Shell&gt; help bcfg -v -b
</pre>
<p>oppure
</p>
<pre>Shell&gt; bcfg -? -v -b
</pre>
<h4><span class="mw-headline" id="edit">edit</span></h4>
<p>Il comando EDIT fornisce un editor di testo semplice con un interfaccia simile all'editor nano, ma leggermente meno funzionale. Esso supporta la codifica UTF-8 e si occupa dei fine riga LF(line feed) contro i CRLF(carriage return + line feed).
</p>
<p>Per modificare, ad esempio il file di rEFInd <code>refind.conf</code> nella partizione di sistema UEFI (fs0: nel firmware):
</p>
<pre>Shell&gt; fs0:
FS0:\&gt; cd \EFI\arch\refind
FS0:\EFI\arch\refind\&gt; edit refind.conf
</pre>
<p>Digitare <code>Ctrl-E</code> per aiuto.
</p>
<h2><span class="mw-headline" id="Creare_un_dispositivo_USB_avviabile_con_UEFI_dalla_ISO">Creare un dispositivo USB avviabile con UEFI dalla ISO</span></h2>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> Il dispositivo USB può utilizzare il partizionamento MBR che GPT (è quindi possibile utilizzare anche un dispositivo USB già partizionato), il filesystem dovebbe essere FAT32(raccomandato), FAT16. FAT12 è stato ideato per i dischi Floppy e quindi non è consigliato per le periferiche USB.</div>
<p>Per prima cosa creare una tavola delle partizioni MBR ed almeno una prtizione sul dispositivo USB. Effettuare il mount della ISO scaricata dalla <a rel="nofollow" class="external text" href="https://archlinux.org/download/">pagina dei download di Arch Linux</a>. 
</p>
<pre># mkdir -p /mnt/{usb,iso}
# mount -o loop archlinux-2012.12.01-dual.iso /mnt/iso
</pre>
<p>Quindi creare un filesystem FAT32 nella partizione del dispositivo USB (effettuarne l'umount prima se necessario) avente la stessa etichetta utilizzata nella configurazione della Archiso. Ottenere l'etichetta dal file <code>/mnt/iso/loader/entries/archiso-x86_64.conf</code>; questo è utilizzato dall'hook <code>archiso</code> nell'initramfs per identificare il percorso udev per il media di installazione. <code>mkfs.vfat</code> è parte del pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=dosfstools">dosfstools</a></span>.
</p>
<pre># awk 'BEGIN {FS="="} /archisolabel/ {print $3}' /mnt/iso/loader/entries/archiso-x86_64.conf | xargs mkfs.vfat -F32 /dev/sdXY -n
</pre>
<p>Effettuare il mount del filesystem FAT32 appena creato, e copiare il contenuto della iso di installazione sull dispositivo USB.
</p>
<pre># mount /dev/sdXY /mnt/usb
# cp -a /mnt/iso/* /mnt/usb
# sync
# umount /mnt/{usb,iso}
</pre>
<h3><span class="mw-headline" id="Risoluzione_degli_errori">Risoluzione degli errori</span></h3>
<p>Se si incorre nell'errore <i>"No loader found. Configuration files in /loader/entries/*.conf are needed."</i> Una possibile soluzione consiste nell'usare un bootloader uefi diverso da quello incluso, gummiboot.
</p>
<p>Scaricare <a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/extra/any/refind-efi/download/">il pacchetto refind-efi</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup> ed estrarre il the file <code>/usr/lib/refind/refind_x64.efi</code> dal pacchetto in  <code>(USB)/EFI/boot/bootx64.efi</code> (sovrascrivere o rinominare ogni file esistente <code>(USB)/EFI/boot/bootx64.efi</code>).
</p>
<p>Quindi copiare questo testo in <code>EFI/boot/refind.conf</code>. Verificare che l'etichetta nella sezione del menu Arch (<code>ARCH_201302</code> in questo esempio) coincida con quella della vostra usb.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">refind.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">timeout 5
textonly

showtools about,reboot,shutdown,exit
# scan_driver_dirs EFI/tools/drivers_x64
scanfor manual,internal,external,optical

scan_delay 1
dont_scan_dirs EFI/boot

max_tags 0
default_selection "Arch Linux Archiso x86_64 UEFI USB"

menuentry "Arch Linux Archiso x86_64 UEFI USB" {
  loader /arch/boot/x86_64/vmlinuz
  initrd /arch/boot/x86_64/archiso.img
  ostype Linux
  graphics off
  options "archisobasedir=arch archisolabel=ARCH_201302 add_efi_memmap"
}

menuentry "UEFI x86_64 Shell v2" {
  loader /EFI/shellx64_v2.efi
  graphics off
}

menuentry "UEFI x86_64 Shell v1" {
  loader /EFI/shellx64_v1.efi
  graphics off
}
</pre>
<p>Dovrebbe essere adesso possibile avviare correttamente, ed avere la possibilità di scegliere quale programma EFI avviare.
</p>
<h2><span class="mw-headline" id="Rimuovere_il_supporto_per_il_boot_UEFI_dalla_ISO">Rimuovere il supporto per il boot UEFI dalla ISO</span></h2>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Attenzione:</strong> Nella condizione in cui i supporti UEFI+isohybrid El Torito/MBR causino realmente problemi, sarà ideale effettuare il boot UEFI utilizzando una pennina USB come spiegato nella sezione precedente.</div>
<p>Molti sistemi Mac con EFI 32-bi ed alcuni Mac con EFI 64-bit rifiutano di avviarsi da un CD/DVD avviabile UEFI(x64)+BIOS. In questo caso la iso dovrebbe essere ricostruita senza il supporto per il boot UEFI, mantenendo solamente il boot da BIOS.
</p>
<p>Effettuare il mount del supporto di installazione ed ottenere il valore di <code>archisolabel</code> come illustrato nella sezione precedente.
</p>
<p>Ricostruire la ISO utilizzando <code>xorriso</code> contenuto nel pacchetto <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=libisoburn">libisoburn</a></span>:
</p>
<pre>$ xorriso -as mkisofs -iso-level 3 \
    -full-iso9660-filenames\
    -volid "ARCH_201212" \
    -appid "Arch Linux CD" \
    -publisher "Arch Linux &lt;https://www.archlinux.org&gt;" \
    -preparer "prepared like a BAWSE" \
    -eltorito-boot isolinux/isolinux.bin \
    -eltorito-catalog isolinux/boot.cat \
    -no-emul-boot -boot-load-size 4 -boot-info-table \
    -isohybrid-mbr "/mnt/iso/isolinux/isohdpfx.bin" \
    -output "~/archiso.iso" "/mnt/iso/"</pre>
<p>Masterizzare <code>~/archiso.iso</code> su un dispositivo ottico e procedere normalmente con l'installazione.
</p>
<h2><span class="mw-headline" id="Altre_risorse">Altre risorse</span></h2>
<ul>
<li>Pagina di Wikipedia(inglese) su <a href="https://en.wikipedia.org/wiki/UEFI" class="extiw" title="wikipedia:UEFI">UEFI</a>
</li>
<li>Pagina di Wikipedia(inglese) su <a href="https://en.wikipedia.org/wiki/EFI_System_partition" class="extiw" title="wikipedia:EFI System partition">UEFI SYSTEM Partition</a>
</li>
<li>
<a rel="nofollow" class="external text" href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob_plain;f=Documentation/x86/x86_64/uefi.txt;hb=HEAD">Linux Kernel UEFI Documentation</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="http://www.uefi.org/home/">UEFI Forum</a> - contiene le <a rel="nofollow" class="external text" href="http://www.uefi.org/specs/">Specifiche UEFI</a> ufficiali - GUID Partition Table è una delle Specifiche UEFI</li>
<li>
<a rel="nofollow" class="external text" href="https://sourceforge.net/apps/mediawiki/tianocore/index.php?title=Welcome_to_TianoCore">Tianocore Project di Intel</a> per i firmware UEFI Open-Source che includono DuetPkg per gli avvii basati sul BIOS e OvmfPkg utilizzato in in QEMU ed Oracle VirtualBox</li>
<li><a rel="nofollow" class="external text" href="http://www.intel.com/technology/efi/">Pagina di Intel su EFI</a></li>
<li><a rel="nofollow" class="external text" href="http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/efi-boot-process.html">FGA: Il processo di avvio EFI</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.microsoft.com/whdc/device/storage/GPT_FAQ.mspx">Microsoft's Windows and GPT FAQ</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup> - Contiene anche informazioni sull'avvio di Windows in modalità UEFI.</li>
<li>
<a rel="nofollow" class="external text" href="https://gitorious.org/tianocore_uefi_duet_builds/pages/Windows_x64_BIOS_to_UEFI">Convertire l'avvio di Windows Vista SP1+ o 7 x86_64 dalla modalità BIOS-MBR alla modalità UEFI-GPT senza reinstallare</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="https://gitorious.org/tianocore_uefi_duet_builds/pages/Linux_Windows_BIOS_UEFI_boot_USB">Creare un drive USB avviabile per Linux BIOS+UEFI e per Windows x64 BIOS+UEFI</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li><a rel="nofollow" class="external text" href="http://rodsbooks.com/bios2uefi/">Rod Smith - Una trasformazione da BIOS a UEFI</a></li>
<li><a rel="nofollow" class="external text" href="https://lkml.org/lkml/2011/6/8/322">Problemi di avvio UEFI su alcune nuove macchine (LKML)</a></li>
<li><a rel="nofollow" class="external text" href="http://software.intel.com/en-us/articles/efi-shells-and-scripting/">EFI Shells e Scripting - Documentazione Intel</a></li>
<li><a rel="nofollow" class="external text" href="http://software.intel.com/en-us/articles/uefi-shell/">UEFI Shell  - Documentazione Intel</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.hpuxtips.es/?q=node/293">UEFI Shell - informazioni sul comando bcfg</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="http://hackthejoggler.freeforums.org/download/file.php?id=28">Alcune applicazioni utili per UEFI Shell 32-bit</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="http://linuxplumbers.ubicast.tv/videos/plumbing-uefi-into-linux/">LPC 2012 Plumbing UEFI into Linux</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="http://linuxplumbers.ubicast.tv/videos/uefi-tutorial-part-1/">LPC 2012 UEFI Tutorial : parte 1</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
<li>
<a rel="nofollow" class="external text" href="http://linuxplumbers.ubicast.tv/videos/uefi-tutorial-part-2/">LPC 2012 UEFI Tutorial : parte 2</a><sup>[<a href="https://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">link interrotto</a> 2020-08-06]</sup>
</li>
</ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="../it/Category:Boot_process.html" title="Category:Boot process (Italiano)">Boot process (Italiano)</a></li></ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="../en/Category:Pages_with_broken_package_links.html" title="Category:Pages with broken package links">Pages with broken package links</a></li></ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Unified_Extensible_Firmware_Interface_(Italiano)&amp;oldid=647076">https://wiki.archlinux.org/index.php?title=Unified_Extensible_Firmware_Interface_(Italiano)&amp;oldid=647076</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 26 December 2020, at 12:28.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
