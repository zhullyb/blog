<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<title>Securely wipe disk (Español) - ArchWiki</title>
<link rel="stylesheet" href="../ArchWikiOffline.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.35.0">
<meta name="robots" content="noindex,follow">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd">
<link rel="license" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom">
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Securely_wipe_disk_Español rootpage-Securely_wipe_disk_Español skin-vector action-view skin-vector-legacy">
<div id="content" class="mw-body" role="main" style="margin: 0">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"></div>
	<div class="mw-indicators mw-body-content">
	</div>
	<h1 id="firstHeading" class="firstHeading" lang="en">Securely wipe disk (Español)</h1>
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="contentSub2"></div>
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#searchInput">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="warningbox">The printable version is no longer supported and may have rendering errors. Please update your browser bookmarks and please use the default browser print function instead.</div>
<div class="mw-parser-output">
<div class="archwiki-template-meta-related-articles-start">
<p>Artículos relacionados</p>
<ul>
<li><a href="../en/Securely_wipe_disk/Tips_and_tricks.html" title="Securely wipe disk/Tips and tricks">Securely wipe disk/Tips and tricks</a></li>
<li><a href="../en/File_recovery.html" title="File recovery">File recovery</a></li>
<li><a href="../en/Benchmarking.html" title="Benchmarking">Benchmarking</a></li>
<li><a href="../en/Frandom.html" title="Frandom">Frandom</a></li>
<li><a href="../es/Data-at-rest_encryption.html#Preparar_el_disco" class="mw-redirect" title="Disk encryption (Español)">Disk encryption (Español)#Preparar el disco</a></li>
<li><a href="../es/Dm-crypt.html" title="Dm-crypt (Español)">dm-crypt (Español)</a></li>
</ul>
</div>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Estado de la traducción:</strong> este artículo es una traducción de <a href="../en/Securely_wipe_disk.html" title="Securely wipe disk">Securely wipe disk</a> revisada por última vez el <b>2019-11-01</b>. Si advierte que la versión inglesa <a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php?title=Securely_wipe_disk&amp;diff=0&amp;oldid=587546">ha cambiado</a> puede actualizar la traducción <a href="../es/ArchWiki:f6ecee2fb17812f6654b3a6ff807d392.html" class="mw-redirect" title="ArchWiki:Translation Team/Contributing (Español)">usted mismo</a> o avisar al <a href="../es/ArchWiki:Translation_Team.html" title="ArchWiki:Translation Team (Español)">equipo de traducción</a>.</div>
<p>La limpieza de un disco se realiza escribiendo nuevos datos sobre cada bit.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> las referencias a «discos» en este artículo también se aplican a los dispositivos <a href="https://en.wikipedia.org/wiki/es:Loopback" class="extiw" title="wikipedia:es:Loopback">loopback</a>.</div>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading">
<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none"><div class="toctitle" lang="en" dir="ltr">
<h2 id="mw-toc-heading">Contents</h2>
<span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span>
</div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Casos_de_uso_comunes"><span class="tocnumber">1</span> <span class="toctext">Casos de uso comunes</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Borrar_todos_los_datos_que_quedan_en_el_dispositivo"><span class="tocnumber">1.1</span> <span class="toctext">Borrar todos los datos que quedan en el dispositivo</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Preparativos_para_el_cifrado_de_dispositivos_de_bloque"><span class="tocnumber">1.2</span> <span class="toctext">Preparativos para el cifrado de dispositivos de bloque</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4">
<a href="#Remanencia_de_datos"><span class="tocnumber">2</span> <span class="toctext">Remanencia de datos</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Sistema_operativo,_programas_y_sistema_de_archivos"><span class="tocnumber">2.1</span> <span class="toctext">Sistema operativo, programas y sistema de archivos</span></a></li>
<li class="toclevel-2 tocsection-6">
<a href="#Problemas_espec%C3%ADficos_de_hardware"><span class="tocnumber">2.2</span> <span class="toctext">Problemas específicos de hardware</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Memoria_flash"><span class="tocnumber">2.2.1</span> <span class="toctext">Memoria flash</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Sectores_defectuosos_marcados"><span class="tocnumber">2.2.2</span> <span class="toctext">Sectores defectuosos marcados</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Magnetismo_residual"><span class="tocnumber">2.2.3</span> <span class="toctext">Magnetismo residual</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Seleccionar_un_objetivo"><span class="tocnumber">3</span> <span class="toctext">Seleccionar un objetivo</span></a></li>
<li class="toclevel-1 tocsection-11">
<a href="#Seleccionar_un_tama%C3%B1o_de_bloque"><span class="tocnumber">4</span> <span class="toctext">Seleccionar un tamaño de bloque</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Calcular_bloques_para_borrar_manualmente"><span class="tocnumber">4.1</span> <span class="toctext">Calcular bloques para borrar manualmente</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13">
<a href="#Seleccionar_una_fuente_de_datos"><span class="tocnumber">5</span> <span class="toctext">Seleccionar una fuente de datos</span></a>
<ul>
<li class="toclevel-2 tocsection-14">
<a href="#Datos_no_aleatorios"><span class="tocnumber">5.1</span> <span class="toctext">Datos no aleatorios</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Prueba_de_escritura_de_patr%C3%B3n"><span class="tocnumber">5.1.1</span> <span class="toctext">Prueba de escritura de patrón</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Datos_aleatorios"><span class="tocnumber">5.2</span> <span class="toctext">Datos aleatorios</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Datos_cifrados"><span class="tocnumber">5.3</span> <span class="toctext">Datos cifrados</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-18">
<a href="#Sobrescribir_el_objetivo"><span class="tocnumber">6</span> <span class="toctext">Sobrescribir el objetivo</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#Redirigir_la_salida"><span class="tocnumber">6.1</span> <span class="toctext">Redirigir la salida</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#dd"><span class="tocnumber">6.2</span> <span class="toctext">dd</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#wipe"><span class="tocnumber">6.3</span> <span class="toctext">wipe</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#shred"><span class="tocnumber">6.4</span> <span class="toctext">shred</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Badblocks"><span class="tocnumber">6.5</span> <span class="toctext">Badblocks</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#hdparm"><span class="tocnumber">6.6</span> <span class="toctext">hdparm</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="#V%C3%A9ase_tambi%C3%A9n"><span class="tocnumber">7</span> <span class="toctext">Véase también</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Casos_de_uso_comunes">Casos de uso comunes</span></h2>
<h3><span class="mw-headline" id="Borrar_todos_los_datos_que_quedan_en_el_dispositivo">Borrar todos los datos que quedan en el dispositivo</span></h3>
<p>El caso de uso más común para limpiar un dispositivo de forma completa e irrevocable será cuando el dispositivo se va a regalar o vender. Es posible que queden datos (sin cifrar) en el dispositivo y que desee protegerlos contra una investigación forense simple que puede ser un juego de niños con, por ejemplo, el software <a href="../en/File_recovery.html" title="File recovery">recuperación de archivos</a>.
</p>
<p>Si desea borrar rápidamente todo del disco, utilidades como <code>/dev/zero</code> o patrones simples, permiten un rendimiento aceptable, en tanto que una aleatoriedad adecuada puede ser ventajosa en algunos casos que deberían tratarse para <a href="#Remanencia_de_datos">#Remanencia de datos</a>.
</p>
<p>Cada bit sobrescrito significa proporcionar un nivel de borrado de datos que no permite la recuperación con funciones normales del sistema (como las órdenes estándar ATA/SCSI) e interfaces de hardware. Cualquier software de recuperación de archivos mencionado anteriormente debería estar especializado con funcionalidades propietarias de hardware de almacenamiento.
</p>
<p>En el caso de un disco HDD, la recreación de datos no será posible sin, al menos, órdenes de disco no documentadas o alterando el controlador o el firmware del dispositivo para que se lean, por ejemplo, sectores reasignados (bloques defectuosos que <a href="../en/S.M.A.R.T..html" title="S.M.A.R.T.">S.M.A.R.T.</a> retiró de su uso).
</p>
<p>Existen diferentes problemas de borrado relacionados con ciertas tecnologías de almacenamiento físico, en particular todos los dispositivos basados ​​en memoria flash y almacenamiento magnético más antiguo (discos duros antiguos, disquetes, cintas).
</p>
<h3><span class="mw-headline" id="Preparativos_para_el_cifrado_de_dispositivos_de_bloque">Preparativos para el cifrado de dispositivos de bloque</span></h3>
<p>Si desea preparar su unidad para configurar de forma segura el <a href="../en/Data-at-rest_encryption.html#Block_device_encryption" class="mw-redirect" title="Disk encryption">cifrado de dispositivo de bloque</a> dentro del área borrada, debe usar <a href="#Datos_aleatorios">#Datos aleatorios</a> generados por una cadena de números aleatorios criptográficamente segura (denominado RNG en este artículo en adelante).
</p>
<p>Véase también <a href="https://en.wikipedia.org/wiki/Random_number_generation" class="extiw" title="wikipedia:Random number generation">Wikipedia:Random number generation</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> si el cifrado del dispositivo de bloque se usa en una partición que contiene algo distinto que datos aleatorios/cifrados, será posible revelar los patrones de uso en la unidad cifrada, lo cual debilita el cifrado al ser comparable con el cifrado a nivel del sistema de archivos. No utilice nunca <code>/dev/zero</code>, patrones simples (badblocks, por ejemplo) u otros datos no aleatorios antes de configurar el cifrado de un dispositivo de bloque, si quiere hacerlo bien.</div>
<h2><span class="mw-headline" id="Remanencia_de_datos">Remanencia de datos</span></h2>
<p>Véase también <a href="https://en.wikipedia.org/wiki/es:Persistencia_de_datos" class="extiw" title="wikipedia:es:Persistencia de datos">Wikipedia:es:Persistencia de datos</a>.
</p>
<p>La representación residual de los datos puede permanecer incluso después de que se hayan hecho intentos para eliminar o borrar los datos.
</p>
<p>Los datos residuales pueden borrarse escribiendo datos (aleatorios) en el disco con una o más <a href="https://en.wikipedia.org/wiki/es:Iteraci%C3%B3n" class="extiw" title="wikipedia:es:Iteración">iteraciones</a>. Sin embargo, más de una iteración puede no disminuir significativamente la posibilidad de reconstruir los datos de las unidades de disco duro. Vea  <a href="#Magnetismo_residual">#Magnetismo residual</a>. 
</p>
<h3>
<span id="Sistema_operativo.2C_programas_y_sistema_de_archivos"></span><span class="mw-headline" id="Sistema_operativo,_programas_y_sistema_de_archivos">Sistema operativo, programas y sistema de archivos</span>
</h3>
<p>El sistema operativo, los programas ejecutados o los <a href="https://en.wikipedia.org/wiki/es:Journaling" class="extiw" title="wikipedia:es:Journaling">sistemas de archivos journaling</a> pueden copiar sus datos no cifrados en todo el dispositivo de bloque. Al escribir en discos planos, esto solo debería ser relevante en conjunción con uno de los anteriores.
</p>
<p>Si los datos pueden ubicarse exactamente en el disco y nunca se copiaron en ningún otro lugar, el borrado con datos aleatorios puede ser exhaustivo e impresionantemente rápido siempre que haya suficiente entropía en el agrupamiento.
</p>
<p>Un buen ejemplo es cryptsetup utilizando <code>/dev/urandom</code> para <a href="../es/ae505413feee1778b509a4dce174fc33.html#Gesti%C3%B3n_de_claves" title="Dm-crypt (Español)/Device encryption (Español)">limpiar los espacios de keyslots de LUKS</a>.
</p>
<h3>
<span id="Problemas_espec.C3.ADficos_de_hardware"></span><span class="mw-headline" id="Problemas_específicos_de_hardware">Problemas específicos de hardware</span>
</h3>
<h4><span class="mw-headline" id="Memoria_flash">Memoria flash</span></h4>
<p>La <a href="https://en.wikipedia.org/wiki/Write_amplification" class="extiw" title="wikipedia:Write amplification">amplificación de la escritura</a> y otras características hacen de la memoria flash (donde se incluye explícitamente SSD) un objetivo obstinado para un borrado confiable. Como hay mucha abstracción transparente entre los datos tal y como se ven en el chip de la controladora del dispositivo y los datos expuestos en el sistema operativo, nunca se sobrescribe la posición y borrar bloques o archivos particulares no es fiable.
</p>
<p>Otras «características» como la compresión transparente (todos los SSD SandForce) pueden comprimir su /dev/zero o patrón de flujo, por lo que si el borrado es rápido más allá de lo razonable, este podría ser el caso.
</p>
<p>Desensamblar dispositivos de memoria flash, desoldar los chips y analizar el contenido de datos sin la controladora de por medio es posible sin dificultad utilizando <a rel="nofollow" class="external text" href="http://www.flash-extractor.com/manual/reader_models/">hardware simple</a>. Las empresas de recuperación de datos lo hacen por poco dinero.
</p>
<p>Para más información, vea:
</p>
<ul>
<li><a href="../en/Solid_state_drive/Memory_cell_clearing.html" title="Solid state drive/Memory cell clearing">Solid state drive/Memory cell clearing</a></li>
<li>
<a rel="nofollow" class="external text" href="http://www.usenix.org/events/fast11/tech/full_papers/Wei.pdf">Borrado fiable de datos de unidades de estado sólido basadas en flash</a>.</li>
<li><a href="#Seleccionar_un_objetivo">#Seleccionar un objetivo</a></li>
</ul>
<h4><span class="mw-headline" id="Sectores_defectuosos_marcados">Sectores defectuosos marcados</span></h4>
<p>Si un disco duro marca un sector como defectuoso, lo acordona y la sección se vuelve imposible de escribir a través del software. Por lo tanto, una sobrescritura completa no lo alcanzaría. Sin embargo, debido al tamaño de los bloques, estas secciones solo equivaldrían a unos pocos KB teóricamente recuperables.
</p>
<h4><span class="mw-headline" id="Magnetismo_residual">Magnetismo residual</span></h4>
<p>Una sola sobrescritura completa con ceros o datos aleatorios no genera datos recuperables en un dispositivo de almacenamiento moderno de alta densidad.<a rel="nofollow" class="external autonumber" href="http://www.howtogeek.com/115573/htg-explains-why-you-only-have-to-wipe-a-disk-once-to-erase-it/">[1]</a> No obstante, las indicaciones se refieren a bits residuales únicos; la reconstrucción de los patrones de bytes generalmente no es factible.<a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20120102004746/http://www.h-online.com/newsticker/news/item/Secure-deletion-a-single-overwrite-will-do-it-739699.html">[2]</a> Consulte también <a rel="nofollow" class="external autonumber" href="https://www.google.com/search?tbs=bks:1&amp;q=isbn:9783540898610">[3]</a>, <a rel="nofollow" class="external autonumber" href="https://security.stackexchange.com/questions/26132/is-data-remanence-a-myth/26134#26134">[4]</a> y <a rel="nofollow" class="external autonumber" href="http://www.nber.org/sys-admin/overwritten-data-guttman.html">[5]</a>.
</p>
<h2><span class="mw-headline" id="Seleccionar_un_objetivo">Seleccionar un objetivo</span></h2>
<p>Utilice <a href="../es/Fdisk.html" title="Fdisk (Español)">fdisk (Español)</a> para localizar todos los dispositivos de lectura/escritura a los que el usuario tiene acceso de lectura.
</p>
<p>Verifique en la salida las líneas que comienzan con dispositivos como <code>/dev/sd"X"</code>.
</p>
<p>Este es un ejemplo para un disco HDD formateado para arrancar un sistema Linux:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Disk /dev/sda: 250.1 GB, 250059350016 bytes, 488397168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00ff784a

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048      206847      102400   83  Linux
/dev/sda2          206848   488397167   244095160   83  Linux
</pre>
<p>O la imagen de instalación de Arch escrita en una memoria USB de 4GB:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;"># fdisk -l</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">Disk /dev/sdb: 4075 MB, 4075290624 bytes, 7959552 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x526e236e

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1   *           0      802815      401408   17  Hidden HPFS/NTFS
</pre>
<p>Si le preocupa causar un daño involuntario a datos importantes del equipo principal, considere usar un entorno aislado como un entorno virtual (VirtualBox, VMWare, QEMU, etc...) con unidades de disco conectadas directamente a él o un único equipo con un solo disco de almacenamiento que necesita limpiar arrancado desde un <a href="../es/Archiso.html" title="Archiso (Español)">soporte Live</a> (USB, CD, PXE, etc.) o utilice un script para <a href="../en/Securely_wipe_disk/Tips_and_tricks.html#Prevent_wiping_mounted_partitions" title="Securely wipe disk/Tips and tricks">evitar limpiar particiones montadas por un error tipográfico</a>.
</p>
<h2>
<span id="Seleccionar_un_tama.C3.B1o_de_bloque"></span><span class="mw-headline" id="Seleccionar_un_tamaño_de_bloque">Seleccionar un tamaño de bloque</span>
</h2>
<p>Vea también <a href="https://en.wikipedia.org/wiki/Dd_(Unix)#Block_size" class="extiw" title="wikipedia:Dd (Unix)">Wikipedia:Dd (Unix)#Block size</a>, <a rel="nofollow" class="external text" href="http://people.redhat.com/msnitzer/docs/io-limits.txt">blocksize io-limits</a>.
</p>
<p>Si tiene un disco duro de <a href="../es/Advanced_Format.html" title="Advanced Format (Español)">formato avanzado</a>, se recomienda que especifique un tamaño de bloque mayor que los 512 bytes predeterminados. Para acelerar el proceso de sobrescritura, elija un tamaño de bloque que coincida con la geometría física de su unidad, agregando la opción de tamaño de bloque a la orden <i>dd</i> (es decir, <code>bs=4096</code> para 4KB).
</p>
<p><i>fdisk</i> muestra el tamaño del sector físico y lógico para cada disco. Alternativamente, sysfs expone información:
</p>
<pre>/sys/block/sdX/size
/sys/block/sdX/queue/physical_block_size
/sys/block/sdX/queue/logical_block_size
/sys/block/sdX/sdXY/alignment_offset
/sys/block/sdX/sdXY/start
/sys/block/sdX/sdXY/size
</pre>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> estos métodos muestran el tamaño de bloque que la unidad informa al kernel. Sin embargo, muchas unidades de formato avanzado subestiman incorrectamente el tamaño del bloque físico dándolo como 512.</div>
<div class="archwiki-template-box archwiki-template-box-tip">
<strong>Sugerencia:</strong> este script, <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/genwipe.sh/">genwipe.sh</a></span><sup><small>AUR</small></sup>, ayuda a calcular los parámetros para borrar un dispositivo/partición con dd, por ejemplo <code>genwipe.sh /dev/sd"XY"</code>.</div>
<h3><span class="mw-headline" id="Calcular_bloques_para_borrar_manualmente">Calcular bloques para borrar manualmente</span></h3>
<p>A continuación, la determinación del área de datos a borrar se realiza en un ejemplo.
</p>
<p>Un dispositivo de almacenamiento de bloque contiene sectores y un tamaño único para cada sector que puede usarse para calcular el tamaño completo del dispositivo en bytes. Puede hacerlo multiplicando el número de sectores con el tamaño del sector.
</p>
<p>Como ejemplo, vamos a usar los parámetros con la orden <i>dd</i> para borrar una partición:
</p>
<pre># dd if=<i>fuente_datos</i> of=/dev/sd"X" bs=<i>tamaño_sector</i> count=<i>número_sector</i> seek=<i>sector_inicio_partición</i> status=progress
</pre>
<p>Aquí verá solo una parte de la salida de la orden <code>fdisk -l /dev/sdX</code> ejecutada con root, que muestra la información de la partición de ejemplo:
</p>
<pre>Device     Boot      Start        End         Sectors     Size  Id Type
/dev/sd"XA"            2048         3839711231  3839709184  1,8T  83 Linux
/dev/sd"XB"            3839711232   3907029167  67317936    32,1G  5 Extended
</pre>
<p>La primera línea de la salida de <i>fdisk</i> muestra el tamaño del disco en bytes y los sectores lógicos:
</p>
<pre>Disk /dev/sd"X": 1,8 TiB, 2000398934016 bytes, 3907029168 sectors
</pre>
<p>Para calcular el tamaño de un solo sector lógico, utilice <code>echo $((2000398934016 / 3907029168))</code> o utilice los datos de la segunda línea de salida de <i>fdisk</i>:
</p>
<pre>Units: sectors of 1 * 512 = 512 bytes
</pre>
<p>Para calcular los sectores físicos que harán que funcione más rápido, podemos usar la tercera línea:
</p>
<pre>Sector size (logical/physical): 512 bytes / 4096 bytes
</pre>
<p>Para obtener el tamaño del disco en sectores físicos, necesitará el tamaño del disco conocido en bytes dividido por el tamaño de un solo sector físico <code>echo $((2000398934016 / 4096))</code>, puede obtener el tamaño del dispositivo de almacenamiento o partición del mismo con la orden <code>blockdev --getsize64 /dev/sd"XY"</code>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> 
<ul>
<li>En los ejemplos siguientes utilizaremos el tamaño del sector lógico.</li>
<li>Puede incluso borrar el espacio en disco no asignado con una orden <code>dd</code> calculando la diferencia entre el final de uno y el inicio de la siguiente partición.</li>
</ul>
</div>
<p>Para borrar la partición <code>/dev/sd"XA"</code>, los parámetros de ejemplo con sectores lógicos se usarían así:
</p>
<pre>Start=2048
End=3839711231
BytesInSector=512</pre>
<p>Para utilizar la dirección de inicio de la partición en el dispositivo para establecerla en la opción <code>seek=</code>:
</p>
<pre># dd if=<i>data_source</i> of=/dev/sd"X" bs=${BytesInSector} count=${End - Start} seek=${Start} status=progress
</pre>
<p>Para utilizar el tamaño de las particiones (en sectores lógicos):
</p>
<pre>LogicalSectors=3839709184
</pre>
<pre># dd if=<i>data_source</i> of=/dev/sd"XA" bs=${BytesInSector} count=${LogicalSectors} status=progress
</pre>
<p>O, para borrar todo el disco utilizando los sectores físicos:
</p>
<pre>AllDiskPhysicalSectors=488378646
PhysicalSectorSizeBytes=4096</pre>
<pre># dd if=<i>data_source</i> of=/dev/sd"X" bs=${PhysicalSectorSizeBytes} count=${AllDiskPhysicalSectors} seek=0 status=progress
</pre>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> la opción <code>count=</code> no es necesaria al limpiar el área física limitada, por ejemplo <code>sd"XY"</code> o <code>sd"X"</code>, desde el principio hasta el final, pero mostrará un error de falta de espacio libre cuando intente escribir fuera de los límites.</div>
<h2><span class="mw-headline" id="Seleccionar_una_fuente_de_datos">Seleccionar una fuente de datos</span></h2>
<p>Como se acaba de decir si desea borrar datos confidenciales, puede usar cualquier opción que se ajuste a sus necesidades. 
</p>
<p>Si desea configurar el cifrado de dispositivos de bloque después, siempre debe borrar, al menos, con un algoritmo de cifrado como fuente o, incluso, con datos pseudoaleatorios.
</p>
<p>Para datos que no son verdaderamente aleatorios, la velocidad de escritura de su disco debería ser el único factor limitante. Si necesita datos aleatorios, el rendimiento del sistema requerido para generarlos puede depender en gran medida de lo que elija como fuente de entropía.
</p>
<h3><span class="mw-headline" id="Datos_no_aleatorios">Datos no aleatorios</span></h3>
<p>La sobrescritura con <code>/dev/zero</code> o patrones simples se considera segura en la mayoría de los recursos. En el caso de los discos duros actuales, debería ser suficiente para limpiar rápidamente los discos.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> una unidad que es anormalmente rápida en la escritura de patrones o puesta a cero podría estar haciendo una compresión transparente. Es obviamente presumible que no todos los bloques se limpiarán de esta manera. Algunos dispositivos de <a href="#Memoria_flash">#Memoria flash</a> tienen dicha «característica».</div>
<h4>
<span id="Prueba_de_escritura_de_patr.C3.B3n"></span><span class="mw-headline" id="Prueba_de_escritura_de_patrón">Prueba de escritura de patrón</span>
</h4>
<p><a href="#Badblocks">#Badblocks</a> puede escribir patrones simples en cada bloque de un dispositivo y luego leerlos y verificarlos buscando áreas dañadas (al igual que memtest86* hace con la memoria).
</p>
<p>Como el patrón se escribe en cada bloque accesible, esto efectivamente borra el dispositivo.
</p>
<h3><span class="mw-headline" id="Datos_aleatorios">Datos aleatorios</span></h3>
<p>Para conocer las diferencias entre los datos aleatorios y pseudoaleatorios como fuente, consulte <a href="../en/Random_number_generation.html" title="Random number generation">Random number generation</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-note">
<strong>Nota:</strong> los datos que son difíciles de comprimir (datos aleatorios) se escribirán más lentamente, si la lógica de la unidad mencionada en la advertencia de <a href="#Datos_no_aleatorios">#Datos no aleatorios</a> intenta comprimirlos. Sin embargo, esto no debería conducir a <a href="#Remanencia_de_datos">#Remanencia de datos</a>. Como la velocidad máxima de escritura no es el cuello de botella en el rendimiento, puede obviarse completamente mientras se limpian discos con datos aleatorios.</div>
<h3><span class="mw-headline" id="Datos_cifrados">Datos cifrados</span></h3>
<p>Al preparar una unidad para el cifrado de disco completo, generalmente no es necesario obtener una entropía de alta calidad. La alternativa es usar un flujo de datos cifrado. Por ejemplo, si va a utilizar AES para su partición encriptada, debe limpiarla con un cifrado de encriptación equivalente antes de crear el sistema de archivos para hacer que el espacio vacío no se distinga del espacio utilizado.
</p>
<h2><span class="mw-headline" id="Sobrescribir_el_objetivo">Sobrescribir el objetivo</span></h2>
<p>La unidad elegida se puede sobrescribir con varias utilidades, haga su elección. Si solo desea borrar un solo archivo, <a href="../en/Securely_wipe_disk/Tips_and_tricks.html#Wipe_a_single_file" title="Securely wipe disk/Tips and tricks">Securely wipe disk/Tips and tricks#Wipe a single file</a> tiene consideraciones adicionales además de las utilidades mencionadas a continuación.
</p>
<h3><span class="mw-headline" id="Redirigir_la_salida">Redirigir la salida</span></h3>
<p>La salida redirigida se puede usar tanto para la creación de los archivos como para reescribir el espacio libre en la partición, borrar todo el dispositivo o una sola partición.
</p>
<p>A continuación se presentan ejemplos que se pueden usar para reescribir la partición o un dispositivo de bloque al redirigir <a rel="nofollow" class="external text" href="https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html">stdout (salida estándar)</a> desde otras utilidades:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ cat /dev/urandom &gt; /dev/sd"XY"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">cat: write error: No space left on device
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ xz -z0 /dev/urandom -c &gt; /dev/sd"XY"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">xz: (stdout): Write error: No space left on device
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ dd if=/dev/urandom &gt; /dev/sd"XY"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">dd: writing to ‘standard output’: No space left on device
20481+0 records in
20480+0 records out
10485760 bytes (10 MB, 10 MiB) copied, 2.29914 s, 4.6 MB/s</pre>
<p>La orden de copia de archivos <code>cp</code> también se puede utilizar para reescribir el dispositivo, ya que ignora el tipo de destino:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">$ cp /dev/urandom /dev/sd"XY"</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;"> cp: error writing ‘/dev/sd"XY"’: No space left on device
 cp: failed to extend ‘/dev/sd"XY"’: No space left on device
</pre>
<p>Para mostrar la velocidad y el tiempo, puede usar <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=pv">pv</a></span>:
</p>
<pre># pv --timer --rate --stop-at-size -s "$(blockdev --getsize64 /dev/sd"XY" )" /dev/zero &gt; /dev/sd"XY"
</pre>
<h3><span class="mw-headline" id="dd">dd</span></h3>
<p>Consulte también <a href="../es/Core_utilities.html#Esenciales" title="Core utilities (Español)">Core utilities (Español)#Esenciales</a>.
</p>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> no hay confirmación con respecto a la ejecución de esta orden, así que <b>verifique repetidamente</b> que la unidad o partición correcta ha sido seleccionada. Asegúrese de que la opción <code>of=...</code> apunta a la unidad de destino y no a un disco del sistema.</div>
<p>Rellene con ceros el disco escribiendo un byte de cero en cada ubicación dirigida al disco utilizando la secuencia <a href="https://en.wikipedia.org/wiki/es:/dev/zero" class="extiw" title="wikipedia:es:/dev/zero">/dev/zero</a>.
</p>
<pre># dd if=/dev/zero of=/dev/sdX bs=4096 status=progress
</pre>
<p>O la secuencia <a href="https://en.wikipedia.org/wiki/es:/dev/random" class="extiw" title="wikipedia:es:/dev/random">/dev/urandom</a>:
</p>
<pre># dd if=/dev/urandom of=/dev/sdX bs=4096 status=progress
</pre>
<p>El proceso finaliza cuando dd informa <code>No space left on device</code> y devuelve el control:
</p>
<pre>dd: writing to ‘/dev/sdb’: No space left on device
7959553+0 records in
7959552+0 records out
4075290624 bytes (4.1 GB, 3.8 GiB) copied, 1247.7 s, 3.3 MB/s
</pre>
<p>Para acelerar la limpieza de una unidad grande, consulte también:
</p>
<ul>
<li>
<a href="../en/Securely_wipe_disk/Tips_and_tricks.html#dd_-_advanced_example" title="Securely wipe disk/Tips and tricks">Securely wipe disk/Tips and tricks#dd - advanced example</a> que utiliza OpenSSL;</li>
<li>
<a href="../en/Securely_wipe_disk/Tips_and_tricks.html#Using_a_template_file" title="Securely wipe disk/Tips and tricks">Securely wipe disk/Tips and tricks#Using a template file</a> que borra datos preestablecidos no aleatorios (por ejemplo, sobrescribe un disco completo con un solo archivo) pero es muy rápido;</li>
<li>
<a href="../en/Dm-crypt/Drive_preparation.html#dm-crypt_specific_methods" title="Dm-crypt/Drive preparation">Dm-crypt/Drive preparation#dm-crypt specific methods</a> que utiliza dm-crypt.</li>
</ul>
<h3><span class="mw-headline" id="wipe">wipe</span></h3>
<p>Especializado en borrar archivos, está disponible como el paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=wipe">wipe</a></span>. Para borrar rápidamente un destino, puede usar algo como:
</p>
<pre>$ wipe -r /path/to/wipe
</pre>
<p>Vea también <span class="plainlinks archwiki-template-man" title="$ man 1 wipe"><a rel="nofollow" class="external text" href="https://man.archlinux.org/man/wipe.1">wipe(1)</a></span>. La herramienta se actualizó por última vez en 2009. Su <a rel="nofollow" class="external text" href="http://wipe.sourceforge.net/">página SourceForge</a> sugiere que está <b>actualmente sin mantenimiento</b>.
</p>
<h3><span class="mw-headline" id="shred">shred</span></h3>
<p><a rel="nofollow" class="external text" href="https://www.gnu.org/software/coreutils/manual/html_node/shred-invocation.html"><i>shred</i></a> (del paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=coreutils">coreutils</a></span>) es una orden de Unix que se puede usar para eliminar de forma segura archivos individuales o dispositivos completos de modo que puedan recuperarse solo con hardware especializado no sin gran dificultad, si es que lo hacen. Por defecto, <i>shred</i> usa tres pasadas, escribiendo <a href="../en/Random_number_generation.html" title="Random number generation">datos pseudoaleatorios</a> en el dispositivo durante cada pasada. Esto se puede reducir o aumentar.
</p>
<p>La siguiente orden invoca shred con su configuración predeterminada y muestra el progreso.
</p>
<pre># shred -v /dev/sd<i>X</i>
</pre>
<p>Alternativamente, se le puede indicar a shred que haga solo una pasada, con entropía de, por ejemplo, <code>/dev/urandom</code>.
</p>
<pre># shred --verbose --random-source=/dev/urandom -n1 /dev/sd<i>X</i>
</pre>
<h3><span class="mw-headline" id="Badblocks">Badblocks</span></h3>
<p>Para permitir que <a href="../en/Badblocks.html" title="Badblocks">badblocks</a> (del paquete <span class="plainlinks archwiki-template-pkg"><a rel="nofollow" class="external text" href="https://archlinux.org/packages/?name=e2fsprogs">e2fsprogs</a></span>) realice una limpieza de disco, se debe realizar una <a href="../en/Badblocks.html#Read-write_test_(warning:destructive)" title="Badblocks">prueba de lectura-escritura</a><sup>[<a href="../en/Help:Procedures.html#Fix_broken_section_links" title="Help:Procedures">broken link</a>: invalid section]</sup> destructiva:
</p>
<pre># badblocks -c &lt;NUMBER_BLOCKS&gt; -wsv /dev/&lt;drive&gt;
</pre>
<h3><span class="mw-headline" id="hdparm">hdparm</span></h3>
<div class="archwiki-template-box archwiki-template-box-warning">
<strong>Advertencia:</strong> no intente emitir una orden Secure Erase ATA en un dispositivo conectado a través de USB; vea <a rel="nofollow" class="external free" href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase</a> y <a rel="nofollow" class="external free" href="http://www.tomshardware.co.uk/answers/id-1984547/secure-erase-external-usb-hard-drive.html">http://www.tomshardware.co.uk/answers/id-1984547/secure-erase-external-usb-hard-drive.html</a> para detalles.</div>
<p><a href="../en/Hdparm.html" title="Hdparm">hdparm</a> admite <a rel="nofollow" class="external text" href="http://tinyapps.org/docs/wipe_drives_hdparm.html">ATA Secure Erase</a>, que es funcionalmente equivalente a llenar un disco con ceros. Sin embargo, es manejado por el firmware del disco duro e incluye «áreas de datos ocultos». Como tal, puede verse como una orden moderna de «formato de bajo nivel». Según los informes, las unidades <a href="../en/Solid_state_drive.html" class="mw-redirect" title="SSD">SSD</a> alcanzan el rendimiento de fábrica después de emitir esta orden, pero es posible que no se borren lo suficiente (consulte <a href="#Memoria_flash">#Memoria flash</a>).
</p>
<p>Algunas unidades admiten <b>Enhanced Secure Erase</b>, que utiliza distintos patrones definidos por el fabricante. Si la salida de <code>hdparm -I</code> para el dispositivo indica una ventaja de tiempo múltiple para el borrado <b>Enhanced</b>, el dispositivo probablemente tenga una función de cifrado por hardware y el borrado se realizará con las claves de dicho cifrado solamente.
</p>
<p>Para obtener instrucciones detalladas sobre el uso de ATA Secure Erase, consulte <a href="../en/Solid_state_drive/Memory_cell_clearing.html" title="Solid state drive/Memory cell clearing">Solid state drive/Memory cell clearing</a> y la <a rel="nofollow" class="external text" href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">Linux ATA wiki</a>.
</p>
<h2>
<span id="V.C3.A9ase_tambi.C3.A9n"></span><span class="mw-headline" id="Véase_también">Véase también</span>
</h2>
<ul><li><a rel="nofollow" class="external text" href="https://superuser.com/questions/19326/how-to-wipe-free-disk-space-in-linux">Limpiar el espacio libre en Linux</a></li></ul>
</div>
</div>
<div id="catlinks" class="catlinks" data-mw="interface">
<div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="../Special:Categories.html" title="Special:Categories">Categories</a>: <ul>
<li><a href="../es/Category:Security.html" title="Category:Security (Español)">Security (Español)</a></li>
<li><a href="../es/Category:File_systems.html" title="Category:File systems (Español)">File systems (Español)</a></li>
</ul>
</div>
<div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="../en/Category:Pages_with_broken_section_links.html" title="Category:Pages with broken section links">Pages with broken section links</a></li></ul>
</div>
</div>
	</div>
</div>

<footer id="footer" class="mw-footer" role="contentinfo" style="margin: 0">
	<ul id="footer-info">
		<li>Retrieved from "<a dir="ltr" href="https://wiki.archlinux.org/index.php?title=Securely_wipe_disk_(Espa%C3%B1ol)&amp;oldid=631491">https://wiki.archlinux.org/index.php?title=Securely_wipe_disk_(Español)&amp;oldid=631491</a>"</li>
		<li id="footer-info-lastmod"> This page was last edited on 12 August 2020, at 08:36.</li>
		<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
	<br>
</ul>
	<ul id="footer-places">
		<li id="footer-places-privacy"><a href="../en/ArchWiki:Privacy_policy.html" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="../en/ArchWiki:About.html" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="footer-places-disclaimer"><a href="../en/ArchWiki:General_disclaimer.html" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico">
	</ul>
	<div style="clear: both;"></div>
</footer>



</body>
</html>
